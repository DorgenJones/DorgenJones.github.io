<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.3">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.3" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Hexo, NexT" />


<meta property="og:type" content="website">
<meta property="og:title" content="Zamperini">
<meta property="og:url" content="https://dorgenjones.github.io/page/3/index.html">
<meta property="og:site_name" content="Zamperini">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zamperini">
<meta name="twitter:card" content="summary">






  <link rel="canonical" href="https://dorgenjones.github.io/page/3/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>Zamperini</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Zamperini</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2018/04/26/rpc/dubbo/6.dubbo-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/26/rpc/dubbo/6.dubbo-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" itemprop="url">Dubbo 负载均衡</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-26T00:00:00+08:00">2018-04-26</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/dubbo/" itemprop="url" rel="index"><span itemprop="name">dubbo</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><h2 id="一致性HASH算法"><a href="#一致性HASH算法" class="headerlink" title="一致性HASH算法"></a>一致性HASH算法</h2><p>适合场景：</p>
<ul>
<li><strong>均衡性(Balance)</strong>：<br>  平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</li>
<li><strong>单调性(Monotonicity)</strong>：当缓冲区大小变化时一致性哈希(Consistent hashing)尽量保护已分配的内容不会被重新映射到新缓冲区。（线性Hash就不能保证）</li>
<li><strong>分散性(Spread)</strong>：避免相同内容被存储到不同缓冲中去，降低了系统存储的效率</li>
<li><strong>负载(Load)</strong>：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容</li>
</ul>
<blockquote>
<p>CARP: Common Access Redundancy Protocol共用地址冗余协议Common Access Redundancy Protocol，或简称 CARP 能够使多台主机共享同一 IP 地址。在某些配置中，这样做可以提高可用性，或实现负载均衡。这些主机也可以同时使用其他的不同的 IP 地址。</p>
</blockquote>
<p>##</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2018/04/25/rpc/dubbo/5.dubbo-%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/25/rpc/dubbo/5.dubbo-%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/" itemprop="url">Dubbo 服务调用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-25T00:00:00+08:00">2018-04-25</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/dubbo/" itemprop="url" rel="index"><span itemprop="name">dubbo</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="服务调用过程解析"><a href="#服务调用过程解析" class="headerlink" title="服务调用过程解析"></a>服务调用过程解析</h1><p>服务过程解析部分我们分两部分来讲，客户端发送请求、接收结果和服务端接受请求、响应结果过程。</p>
<h2 id="客户端发送请求、接收结果"><a href="#客户端发送请求、接收结果" class="headerlink" title="客户端发送请求、接收结果"></a>客户端发送请求、接收结果</h2><p>首先，调用客户端方法时，首先被<code>InvokerInvocationHandler</code>拦截，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">   String methodName = method.getName();</span><br><span class="line">   Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">   <span class="keyword">if</span> (method.getDeclaringClass() == Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> method.invoke(invoker, args);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="string">"toString"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> invoker.toString();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="string">"hashCode"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> invoker.hashCode();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="string">"equals"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> invoker.equals(args[<span class="number">0</span>]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//在服务引用过程分析中，提到这里的invoker。当不是没有`injvm`、`url`配置时，invoker是 XxxClusterInvoker</span></span><br><span class="line">   <span class="keyword">return</span> invoker.invoke(<span class="keyword">new</span> RpcInvocation(method, args)).recreate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们指定<code>XxxClusterInvoker</code>为<code>FailoverClusterInvoker</code>来分析整个流程。<br><code>FailoverClusterInvoker</code>的结构如下：<br><img src="/media/15202975233343.jpg" alt=""><br>所以，接下来会走进<code>AbstractClusterInvoker</code>的invoker方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">   LoadBalance loadbalance = <span class="keyword">null</span>;</span><br><span class="line">   <span class="comment">//根据参数列出所有可以使用的Invoker</span></span><br><span class="line">   List&lt;Invoker&lt;T&gt;&gt; invokers = list(invocation);</span><br><span class="line">   <span class="keyword">if</span> (invokers != <span class="keyword">null</span> &amp;&amp; !invokers.isEmpty()) &#123;</span><br><span class="line">       <span class="comment">// 根据Url，获取负载均衡器，这里先假定为`RandomLoadBalance`</span></span><br><span class="line">       loadbalance = ExtensionLoader.getExtensionLoader(LoadBalance<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">invokers</span>.<span class="title">get</span>(0).<span class="title">getUrl</span>()</span></span><br><span class="line"><span class="class">               .<span class="title">getMethodParameter</span>(<span class="title">invocation</span>.<span class="title">getMethodName</span>(), <span class="title">Constants</span>.<span class="title">LOADBALANCE_KEY</span>, <span class="title">Constants</span>.<span class="title">DEFAULT_LOADBALANCE</span>))</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class="line">   <span class="keyword">return</span> doInvoke(invocation, invokers, loadbalance);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">   <span class="comment">// 调用directory的list方法，这里的Directory为`RegistryDirectory`</span></span><br><span class="line">   List&lt;Invoker&lt;T&gt;&gt; invokers = directory.list(invocation);</span><br><span class="line">   <span class="keyword">return</span> invokers;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">   <span class="comment">// doList方法直接从Directory保存的InvokerMap中取出对应Service的Invokers</span></span><br><span class="line">   List&lt;Invoker&lt;T&gt;&gt; invokers = doList(invocation);</span><br><span class="line">   List&lt;Router&gt; localRouters = <span class="keyword">this</span>.routers;</span><br><span class="line">   <span class="comment">// 经过设置的Routers进行过滤出可以使用的Invokers</span></span><br><span class="line">   <span class="keyword">if</span> (localRouters != <span class="keyword">null</span> &amp;&amp; !localRouters.isEmpty()) &#123;</span><br><span class="line">       <span class="keyword">for</span> (Router router : localRouters) &#123;</span><br><span class="line">           <span class="keyword">if</span> (router.getUrl() == <span class="keyword">null</span> || router.getUrl().getParameter(Constants.RUNTIME_KEY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">               invokers = router.route(invokers, getConsumerUrl(), invocation);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> invokers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取完所有可用的<code>Invoker</code>后，继续看<code>FailoverClusterInvoker</code>的处理逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">   List&lt;Invoker&lt;T&gt;&gt; copyinvokers = invokers;</span><br><span class="line">   <span class="comment">//失败重试次数</span></span><br><span class="line">   <span class="keyword">int</span> len = getUrl().getMethodParameter(invocation.getMethodName(), Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">       len = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   List&lt;Invoker&lt;T&gt;&gt; invoked = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(copyinvokers.size()); <span class="comment">// invoked invokers.</span></span><br><span class="line">    <span class="comment">//len-1次重试</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           checkWhetherDestroyed();</span><br><span class="line">           copyinvokers = list(invocation);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">       Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyinvokers, invoked);</span><br><span class="line">       invoked.add(invoker);</span><br><span class="line">       RpcContext.getContext().setInvokers((List) invoked);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Result result = invoker.invoke(invocation);</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125;...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> Invoker&lt;T&gt; <span class="title">select</span><span class="params">(LoadBalance loadbalance, Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (invokers == <span class="keyword">null</span> || invokers.isEmpty())</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   String methodName = invocation == <span class="keyword">null</span> ? <span class="string">""</span> : invocation.getMethodName();</span><br><span class="line">   <span class="keyword">boolean</span> sticky = invokers.get(<span class="number">0</span>).getUrl().getMethodParameter(methodName, Constants.CLUSTER_STICKY_KEY, Constants.DEFAULT_CLUSTER_STICKY);</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//如果带有粘性设置，则直接返回之前保存的`stickyInvoker`</span></span><br><span class="line">       <span class="keyword">if</span> (stickyInvoker != <span class="keyword">null</span> &amp;&amp; !invokers.contains(stickyInvoker)) &#123;</span><br><span class="line">           stickyInvoker = <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (sticky &amp;&amp; stickyInvoker != <span class="keyword">null</span> &amp;&amp; (selected == <span class="keyword">null</span> || !selected.contains(stickyInvoker))) &#123;</span><br><span class="line">           <span class="keyword">if</span> (availablecheck &amp;&amp; stickyInvoker.isAvailable()) &#123;</span><br><span class="line">               <span class="keyword">return</span> stickyInvoker;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 负载均衡器根据策略选出一个Invoker，这里的Invoker是DubboInvoker</span></span><br><span class="line">   Invoker&lt;T&gt; invoker = doSelect(loadbalance, invocation, invokers, selected);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (sticky) &#123;</span><br><span class="line">       stickyInvoker = invoker;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看<code>DubboInvoker</code>的处理逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">   RpcInvocation inv = (RpcInvocation) invocation;</span><br><span class="line">   <span class="keyword">final</span> String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">   inv.setAttachment(Constants.PATH_KEY, getUrl().getPath());</span><br><span class="line">   inv.setAttachment(Constants.VERSION_KEY, version);</span><br><span class="line"></span><br><span class="line">   ExchangeClient currentClient;</span><br><span class="line">   <span class="comment">// 当有多个client（对同一个服务提供者建立多个链接）时，则按轮询的方式选择一个Client发起调用。</span></span><br><span class="line">   <span class="keyword">if</span> (clients.length == <span class="number">1</span>) &#123;</span><br><span class="line">       currentClient = clients[<span class="number">0</span>];</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       currentClient = clients[index.getAndIncrement() % clients.length];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">boolean</span> isAsync = RpcUtils.isAsync(getUrl(), invocation);</span><br><span class="line">   <span class="keyword">boolean</span> isOneway = RpcUtils.isOneway(getUrl(), invocation);</span><br><span class="line">   <span class="keyword">int</span> timeout = getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line">   <span class="keyword">if</span> (isOneway) &#123;</span><br><span class="line">       <span class="comment">//单向调用，调用完即返回</span></span><br><span class="line">       <span class="keyword">boolean</span> isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, <span class="keyword">false</span>);</span><br><span class="line">       currentClient.send(inv, isSent);</span><br><span class="line">       RpcContext.getContext().setFuture(<span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> RpcResult();</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isAsync) &#123;</span><br><span class="line">       <span class="comment">//异步调用</span></span><br><span class="line">       ResponseFuture future = currentClient.request(inv, timeout);</span><br><span class="line">       RpcContext.getContext().setFuture(<span class="keyword">new</span> FutureAdapter&lt;Object&gt;(future));</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> RpcResult();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//同步调用</span></span><br><span class="line">       RpcContext.getContext().setFuture(<span class="keyword">null</span>);</span><br><span class="line">       <span class="comment">//这里最终的Client实现为`HeaderExchangeClient`</span></span><br><span class="line">       <span class="keyword">return</span> (Result) currentClient.request(inv, timeout).get();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而后，<code>HeaderExchangeClient</code>会调用<code>HeaderExchangeChannel</code>的<code>request</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>.getLocalAddress(), <span class="keyword">null</span>, <span class="string">"Failed to send request "</span> + request + <span class="string">", cause: The channel "</span> + <span class="keyword">this</span> + <span class="string">" is closed!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 创建一个Request，其带有Id属性，这个Id属性就是用来唯一标识请求</span></span><br><span class="line">   Request req = <span class="keyword">new</span> Request();</span><br><span class="line">   req.setVersion(<span class="string">"2.0.0"</span>);</span><br><span class="line">   req.setTwoWay(<span class="keyword">true</span>);</span><br><span class="line">   req.setData(request);</span><br><span class="line">   <span class="comment">//创建DefaultFuture实例时，会将其放在一个全局的Map中，用于请求返回时，设置结果</span></span><br><span class="line">   DefaultFuture future = <span class="keyword">new</span> DefaultFuture(channel, req, timeout);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//这里的channel即是NettyClient</span></span><br><span class="line">       channel.send(req);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">       future.cancel();</span><br><span class="line">       <span class="keyword">throw</span> e;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，值得一提的是<code>DefaultFuture</code>是客户端发送请求到获取结果的桥梁。<br><code>channel.send</code>下面即为<code>Netty</code>的处理逻辑：<br>这里会先经过<code>EncoderHandler</code>（<strong>NettyCodecAdapter.InternalEncoder</strong>）进行编码处理，最后由<code>NettyHandler</code>发送请求。<br>服务端结果响应后，会由<code>DecodeHandler</code>（<strong>NettyCodecAdapter.InternalDncoder</strong>）进行解码后，交由<code>NettyHanlder</code>处理。<br><img src="/media/15203256028069.jpg" alt=""><br><img src="/media/15203256208940.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2018/04/24/rpc/dubbo/4.dubbo-%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/24/rpc/dubbo/4.dubbo-%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8/" itemprop="url">Dubbo 服务引用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-24T00:00:00+08:00">2018-04-24</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/dubbo/" itemprop="url" rel="index"><span itemprop="name">dubbo</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="服务引用过程解析"><a href="#服务引用过程解析" class="headerlink" title="服务引用过程解析"></a>服务引用过程解析</h1><p>调用服务时，在XML中配置<code>&lt;dubbo:reference&gt;</code>和注册中心即可像调用一个内存方法一样调用远端服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:registry address=<span class="string">"multicast://224.5.6.7:1234"</span>/&gt;</span><br><span class="line">&lt;dubbo:reference id=<span class="string">"demoService"</span> check=<span class="string">"false"</span> <span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.alibaba.dubbo.demo.DemoService"</span> loadbalance=<span class="string">"leastactive"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;dubbo:reference&gt;</code>同样是由<code>DubboBeanDefinitionParser</code>进行解析，其被解析后成实例<code>ReferenceBean</code>。因此，其是服务引用过程的关键。<br><img src="/media/15202605904632.jpg" alt=""><br>可以看出，它是一个工厂Bean(实现<code>FactoryBean</code>接口)、<code>InitializingBean</code>接口。因此当有服务引用<code>demoService</code>时，会调用<code>getObject()</code>返回代理的对象。所以<code>getObject()</code>即是关键服务。因为实现了<code>InitializingBean</code>所以在向Spring暴露bean之前会调用<code>afterPropertiesSet</code>方法。<code>RefrenceBean</code>的<code>afterPropertiesSet</code>方法作用跟<code>ServiceBean</code>的<code>afterPropertiesSet</code>一样，从Spring容器中获取<code>Consumer</code>、<code>Application</code>、<code>Module</code>、<code>Registeries</code>、<code>Monitor</code>、<code>Protocol</code>对象设置到其属性中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (getConsumer() == <span class="keyword">null</span>) &#123;</span><br><span class="line">       Map&lt;String, ConsumerConfig&gt; consumerConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ConsumerConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">       <span class="keyword">if</span> (consumerConfigMap != <span class="keyword">null</span> &amp;&amp; consumerConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           ConsumerConfig consumerConfig = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">for</span> (ConsumerConfig config : consumerConfigMap.values()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                  consumerConfig = config;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (consumerConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">               setConsumer(consumerConfig);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ...<span class="comment">//获取`Application`、`Module`、`Registeries`、`Monitor`、`Protocol`</span></span><br><span class="line">   Boolean b = isInit();</span><br><span class="line">   <span class="keyword">if</span> (b == <span class="keyword">null</span> &amp;&amp; getConsumer() != <span class="keyword">null</span>) &#123;</span><br><span class="line">       b = getConsumer().isInit();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//若配置了init则会提前初始化。调用getObject方法</span></span><br><span class="line">   <span class="keyword">if</span> (b != <span class="keyword">null</span> &amp;&amp; b.booleanValue()) &#123;</span><br><span class="line">       getObject();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getObject</code>最终会调用<code>init</code>方法，<code>init</code>方法中会组装所有配置的属性然后根据这些属性来创建代理对象<code>createProxy</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取所有配置属性组装成map</span></span><br><span class="line">   Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">   Map&lt;Object, Object&gt; attributes = <span class="keyword">new</span> HashMap&lt;Object, Object&gt;();</span><br><span class="line">   map.put(Constants.SIDE_KEY, Constants.CONSUMER_SIDE);</span><br><span class="line">   map.put(Constants.DUBBO_VERSION_KEY, Version.getVersion());</span><br><span class="line">   map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">   <span class="keyword">if</span> (ConfigUtils.getPid() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!isGeneric()) &#123;</span><br><span class="line">       String revision = Version.getVersion(interfaceClass, version);</span><br><span class="line">       <span class="keyword">if</span> (revision != <span class="keyword">null</span> &amp;&amp; revision.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           map.put(<span class="string">"revision"</span>, revision);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line">       <span class="keyword">if</span> (methods.length == <span class="number">0</span>) &#123;</span><br><span class="line">           map.put(<span class="string">"methods"</span>, Constants.ANY_VALUE);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           map.put(<span class="string">"methods"</span>, StringUtils.join(<span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(methods)), <span class="string">","</span>));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   map.put(Constants.INTERFACE_KEY, interfaceName);</span><br><span class="line">   appendParameters(map, application);</span><br><span class="line">   appendParameters(map, <span class="keyword">module</span>);</span><br><span class="line">   appendParameters(map, consumer, Constants.DEFAULT_KEY);</span><br><span class="line">   appendParameters(map, <span class="keyword">this</span>);</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 根据组装成的属性 map 创建代理</span></span><br><span class="line">   ref = createProxy(map);</span><br><span class="line">   ConsumerModel consumerModel = <span class="keyword">new</span> ConsumerModel(getUniqueServiceName(), <span class="keyword">this</span>, ref, interfaceClass.getMethods());</span><br><span class="line">   ApplicationModel.initConsumerModel(getUniqueServiceName(), consumerModel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当配置<code>injvm=true</code>时，且当前JVM有对应服务时，<code>createProxy</code>会直接应用本地的服务，本章为了涵盖更多的内容，因此会专注于远端服务引用的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createProxy</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">   URL tmpUrl = <span class="keyword">new</span> URL(<span class="string">"temp"</span>, <span class="string">"localhost"</span>, <span class="number">0</span>, map);</span><br><span class="line">   <span class="comment">// 当用户配置了url属性，则创建的是点对点的服务。</span></span><br><span class="line">   <span class="keyword">if</span> (url != <span class="keyword">null</span> &amp;&amp; url.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       String[] us = Constants.SEMICOLON_SPLIT_PATTERN.split(url);</span><br><span class="line">       <span class="keyword">if</span> (us != <span class="keyword">null</span> &amp;&amp; us.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (String u : us) &#123;</span><br><span class="line">               URL url = URL.valueOf(u);</span><br><span class="line">               <span class="keyword">if</span> (url.getPath() == <span class="keyword">null</span> || url.getPath().length() == <span class="number">0</span>) &#123;</span><br><span class="line">                   url = url.setPath(interfaceName);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">                   urls.add(url.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   urls.add(ClusterUtils.mergeUrl(url, map));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//获取注册中心的配置，装配URL</span></span><br><span class="line">       <span class="comment">//URL示例:registry://224.5.6.7:1234/com.alibaba.dubbo.registry.RegistryService?application=demo-consumer&amp;dubbo=2.0.0&amp;pid=1269&amp;qos.port=33333&amp;registry=multicast&amp;timestamp=1520264898587</span></span><br><span class="line">       List&lt;URL&gt; us = loadRegistries(<span class="keyword">false</span>);</span><br><span class="line">       <span class="keyword">if</span> (us != <span class="keyword">null</span> &amp;&amp; !us.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">for</span> (URL u : us) &#123;</span><br><span class="line">               URL monitorUrl = loadMonitor(u);</span><br><span class="line">               <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));</span><br><span class="line">               &#125;</span><br><span class="line">               urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (urls.size() == <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="comment">//之前的章节里说过，refprotocol是Protocol的自适应对象，其在执行refer时，会获取`url.getProtocol()`属性决定调用哪个拓展。</span></span><br><span class="line">       <span class="comment">//根据上面的URL可知是RegistryProtocol</span></span><br><span class="line">       invoker = refprotocol.refer(interfaceClass, urls.get(<span class="number">0</span>));</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       List&lt;Invoker&lt;?&gt;&gt; invokers = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;?&gt;&gt;();</span><br><span class="line">       URL registryURL = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">           invokers.add(refprotocol.refer(interfaceClass, url));</span><br><span class="line">           <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">               registryURL = url; <span class="comment">// use last registry url</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (registryURL != <span class="keyword">null</span>) &#123; <span class="comment">// registry url is available</span></span><br><span class="line">           <span class="comment">// use AvailableCluster only when register's cluster is available</span></span><br><span class="line">           URL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);</span><br><span class="line">           invoker = cluster.join(<span class="keyword">new</span> StaticDirectory(u, invokers));</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123; <span class="comment">// not a registry url</span></span><br><span class="line">           invoker = cluster.join(<span class="keyword">new</span> StaticDirectory(invokers));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// create service proxy</span></span><br><span class="line">   <span class="comment">//经过上面的处理后，invoker现在已是XxxClusterInvoker，下面我们以FailoverClusterInvoker为例来</span></span><br><span class="line">   <span class="keyword">return</span> (T) proxyFactory.getProxy(invoker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>proxyFactory</code>是个扩展点，有<code>JdkProxyFactory</code>和<code>JavassistProxyFactory</code>。进一步可以看到，配置的拦截器都是<code>InvokerInvocationHandler</code>。因此当调用<code>Client</code>方法时，都会被其拦截，调用其<code>invoke</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (T) Proxy.getProxy(interfaces).newInstance(<span class="keyword">new</span> InvokerInvocationHandler(invoker));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), interfaces, <span class="keyword">new</span> InvokerInvocationHandler(invoker));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">   url = url.setProtocol(url.getParameter(Constants.REGISTRY_KEY, Constants.DEFAULT_REGISTRY)).removeParameter(Constants.REGISTRY_KEY);</span><br><span class="line">   <span class="comment">// 根据URL获取具体的注册器实例，比如这里`MulticastRegistry`</span></span><br><span class="line">   Registry registry = registryFactory.getRegistry(url);</span><br><span class="line">   <span class="keyword">if</span> (RegistryService<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">type</span>)) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> proxyFactory.getInvoker((T) registry, type, url);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//  ...</span></span><br><span class="line">   <span class="keyword">return</span> doRefer(cluster, registry, type, url);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doRefer</span><span class="params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建目录，创建目录的同时也会创建路由器，在其父类`AbstractDirectory`中`setRouters`中进行创建</span></span><br><span class="line">   RegistryDirectory&lt;T&gt; directory = <span class="keyword">new</span> RegistryDirectory&lt;T&gt;(type, url);</span><br><span class="line">   directory.setRegistry(registry);</span><br><span class="line">   directory.setProtocol(protocol);</span><br><span class="line"></span><br><span class="line">   Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;String, String&gt;(directory.getUrl().getParameters());</span><br><span class="line">   URL subscribeUrl = <span class="keyword">new</span> URL(Constants.CONSUMER_PROTOCOL, parameters.remove(Constants.REGISTER_IP_KEY), <span class="number">0</span>, type.getName(), parameters);</span><br><span class="line">   <span class="keyword">if</span> (!Constants.ANY_VALUE.equals(url.getServiceInterface())</span><br><span class="line">           &amp;&amp; url.getParameter(Constants.REGISTER_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="comment">//向注册中心注册服务消费者信息</span></span><br><span class="line">       registry.register(subscribeUrl.addParameters(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY,</span><br><span class="line">               Constants.CHECK_KEY, String.valueOf(<span class="keyword">false</span>)));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 目录向注册中心订阅服务，第一次订阅或者当服务提供者信息发生改变时注册中心会将更新通知到目录</span></span><br><span class="line">   directory.subscribe(subscribeUrl.addParameter(Constants.CATEGORY_KEY,</span><br><span class="line">           Constants.PROVIDERS_CATEGORY</span><br><span class="line">                   + <span class="string">","</span> + Constants.CONFIGURATORS_CATEGORY</span><br><span class="line">                   + <span class="string">","</span> + Constants.ROUTERS_CATEGORY));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 集群将目录合并到虚拟的`XxxClusterInvoker`中，而`XxxClusterInvoker`是一种虚拟的Invoker，起分发的作用。</span></span><br><span class="line">   <span class="comment">// cluster自适应类型会根据`url.cluster`属性判断实际类型，默认为`FailoverCluster`，join后返回的是`FailoverClusterInvoker`，</span></span><br><span class="line">   Invoker invoker = cluster.join(directory);</span><br><span class="line">   ProviderConsumerRegTable.registerConsuemr(invoker, url, subscribeUrl, directory);</span><br><span class="line">   <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//`AbstractDirectory`中`setRouters`逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setRouters</span><span class="params">(List&lt;Router&gt; routers)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// copy list</span></span><br><span class="line">   routers = routers == <span class="keyword">null</span> ? <span class="keyword">new</span> ArrayList&lt;Router&gt;() : <span class="keyword">new</span> ArrayList&lt;Router&gt;(routers);</span><br><span class="line"></span><br><span class="line">   String routerkey = url.getParameter(Constants.ROUTER_KEY);</span><br><span class="line">   <span class="keyword">if</span> (routerkey != <span class="keyword">null</span> &amp;&amp; routerkey.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">//根据url.route属性创建Router实例</span></span><br><span class="line">       RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">routerkey</span>)</span>;</span><br><span class="line">       routers.add(routerFactory.getRouter(url));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 最后加上MockInvokerSelector，作用是当一个请求被配置使用mock，router则保证只有带有MOCK协议的invokers才会出现在提供者列表上</span></span><br><span class="line">   routers.add(<span class="keyword">new</span> MockInvokersSelector());</span><br><span class="line">   Collections.sort(routers);</span><br><span class="line">   <span class="keyword">this</span>.routers = routers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，实际上<code>Router</code>的作用是起过滤作用的，过滤出所有符合条件的<code>Invoker</code>。<br>再来继续看下第一次订阅或者当服务提供者信息发生改变时注册中心通知目录的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">   List&lt;URL&gt; invokerUrls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">   List&lt;URL&gt; routerUrls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">   List&lt;URL&gt; configuratorUrls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">   <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">       String protocol = url.getProtocol();</span><br><span class="line">       String category = url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);</span><br><span class="line">       <span class="comment">//分类处理：当时Route信息时，则更新Routers;</span></span><br><span class="line">       <span class="comment">//        当为服务提供者时则，则刷新服务提供者</span></span><br><span class="line">       <span class="keyword">if</span> (Constants.ROUTERS_CATEGORY.equals(category)</span><br><span class="line">               || Constants.ROUTE_PROTOCOL.equals(protocol)) &#123;</span><br><span class="line">           routerUrls.add(url);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.CONFIGURATORS_CATEGORY.equals(category)</span><br><span class="line">               || Constants.OVERRIDE_PROTOCOL.equals(protocol)) &#123;</span><br><span class="line">           configuratorUrls.add(url);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.PROVIDERS_CATEGORY.equals(category)) &#123;</span><br><span class="line">           invokerUrls.add(url);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    ...</span><br><span class="line">   <span class="comment">// routers</span></span><br><span class="line">   <span class="keyword">if</span> (routerUrls != <span class="keyword">null</span> &amp;&amp; !routerUrls.isEmpty()) &#123;</span><br><span class="line">       List&lt;Router&gt; routers = toRouters(routerUrls);</span><br><span class="line">       <span class="keyword">if</span> (routers != <span class="keyword">null</span>) &#123; <span class="comment">// null - do nothing</span></span><br><span class="line">           setRouters(routers);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 刷新Invokers</span></span><br><span class="line">   refreshInvoker(invokerUrls);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshInvoker</span><span class="params">(List&lt;URL&gt; invokerUrls)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.forbidden = <span class="keyword">false</span>; <span class="comment">// Allow to access</span></span><br><span class="line">   Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap = <span class="keyword">this</span>.urlInvokerMap; <span class="comment">// local reference</span></span><br><span class="line">   <span class="keyword">if</span> (invokerUrls.isEmpty() &amp;&amp; <span class="keyword">this</span>.cachedInvokerUrls != <span class="keyword">null</span>) &#123;</span><br><span class="line">       invokerUrls.addAll(<span class="keyword">this</span>.cachedInvokerUrls);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">this</span>.cachedInvokerUrls = <span class="keyword">new</span> HashSet&lt;URL&gt;();</span><br><span class="line">       <span class="keyword">this</span>.cachedInvokerUrls.addAll(invokerUrls);<span class="comment">//Cached invoker urls, convenient for comparison</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (invokerUrls.isEmpty()) &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//将url转换为Invoker</span></span><br><span class="line">   Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = toInvokers(invokerUrls);</span><br><span class="line">   Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; newMethodInvokerMap = toMethodInvokers(newUrlInvokerMap);</span><br><span class="line">   <span class="keyword">this</span>.methodInvokerMap = multiGroup ? toMergeMethodInvokerMap(newMethodInvokerMap) : newMethodInvokerMap;</span><br><span class="line">   <span class="keyword">this</span>.urlInvokerMap = newUrlInvokerMap;</span><br><span class="line">   <span class="comment">//关闭无用的Invokers</span></span><br><span class="line">   destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Invoker&lt;T&gt;&gt; toInvokers(List&lt;URL&gt; urls) &#123;</span><br><span class="line">   Set&lt;String&gt; keys = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">   Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = <span class="keyword">new</span> HashMap&lt;String, Invoker&lt;T&gt;&gt;();</span><br><span class="line">   <span class="keyword">for</span> (URL providerUrl : urls) &#123;</span><br><span class="line">    <span class="comment">////URL: dubbo://192.168.199.105:32323/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-consumer&amp;check=false&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;loadbalance=leastactive&amp;methods=sayHello&amp;pid=1723&amp;qos.port=33333&amp;register.ip=192.168.199.105&amp;remote.timestamp=1520264874377&amp;scope=remote&amp;side=consumer&amp;timestamp=1520268138014</span></span><br><span class="line">       URL url = mergeUrl(providerUrl);</span><br><span class="line">       String key = url.toFullString(); <span class="comment">// The parameter urls are sorted</span></span><br><span class="line">       <span class="keyword">if</span> (keys.contains(key)) &#123; <span class="comment">// Repeated url</span></span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       keys.add(key);</span><br><span class="line">       Map&lt;String, Invoker&lt;T&gt;&gt; localUrlInvokerMap = <span class="keyword">this</span>.urlInvokerMap; <span class="comment">// local reference</span></span><br><span class="line">       Invoker&lt;T&gt; invoker = localUrlInvokerMap == <span class="keyword">null</span> ? <span class="keyword">null</span> : localUrlInvokerMap.get(key);</span><br><span class="line">       <span class="keyword">if</span> (invoker == <span class="keyword">null</span>) &#123; <span class="comment">// Not in the cache, refer again</span></span><br><span class="line">           <span class="keyword">boolean</span> enabled = <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">if</span> (url.hasParameter(Constants.DISABLED_KEY)) &#123;</span><br><span class="line">               enabled = !url.getParameter(Constants.DISABLED_KEY, <span class="keyword">false</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               enabled = url.getParameter(Constants.ENABLED_KEY, <span class="keyword">true</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">                <span class="comment">//引用服务的关键，调用DubboProtocol.refer</span></span><br><span class="line">               invoker = <span class="keyword">new</span> InvokerDelegate&lt;T&gt;(protocol.refer(serviceType, url), url, providerUrl);</span><br><span class="line">               newUrlInvokerMap.put(key, invoker);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   keys.clear();</span><br><span class="line">   <span class="keyword">return</span> newUrlInvokerMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DubboProtocol.refer</code>用来创建传输层的Clients，并建立长连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; serviceType, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">   optimizeSerialization(url);</span><br><span class="line">   <span class="comment">// create rpc invoker.</span></span><br><span class="line">   <span class="comment">//getClients即是用来创建客户端连接</span></span><br><span class="line">   DubboInvoker&lt;T&gt; invoker = <span class="keyword">new</span> DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);</span><br><span class="line">   invokers.add(invoker);</span><br><span class="line">   <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getClients</code>会间接调用某种类型(<code>XxxTransporter</code>)的传输器<code>connect</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">`getClients`</span><br><span class="line">-&gt; `HeaderExchanger.connect`</span><br><span class="line">    -&gt;<span class="keyword">new</span> HeaderExchangeClient(Transporters.connect(url, <span class="keyword">new</span> DecodeHandler(<span class="keyword">new</span> HeaderExchangeHandler(handler))), <span class="keyword">true</span>)</span><br><span class="line">        -&gt; `Transporter.connect`</span><br><span class="line">```Getclients`会</span><br><span class="line">假定我们使用`Netty`做传输层，则`Transporter.connect`会创建一个`NettyClient`，它会在构造函数内进行初始化后`Netty`客户端模式的配置然后建立连接。</span><br><span class="line">重点来看下初始化`NettyClient`的逻辑：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">   NettyHelper.setNettyLoggerFactory();</span><br><span class="line">   bootstrap = <span class="keyword">new</span> ClientBootstrap(channelFactory);</span><br><span class="line">   bootstrap.setOption(<span class="string">"keepAlive"</span>, <span class="keyword">true</span>);</span><br><span class="line">   bootstrap.setOption(<span class="string">"tcpNoDelay"</span>, <span class="keyword">true</span>);</span><br><span class="line">   bootstrap.setOption(<span class="string">"connectTimeoutMillis"</span>, getTimeout());</span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="keyword">final</span> NettyHandler nettyHandler = <span class="keyword">new</span> NettyHandler(getUrl(), <span class="keyword">this</span>);</span><br><span class="line">   bootstrap.setPipelineFactory(<span class="keyword">new</span> ChannelPipelineFactory() &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ChannelPipeline <span class="title">getPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">//这里封装了编码器和解码器逻辑</span></span><br><span class="line">           NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyClient.<span class="keyword">this</span>);</span><br><span class="line">           ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line">           <span class="comment">//解码，用途接收结果后的解码</span></span><br><span class="line">           pipeline.addLast(<span class="string">"decoder"</span>, adapter.getDecoder());</span><br><span class="line">           <span class="comment">//用于发送请求的编码</span></span><br><span class="line">           pipeline.addLast(<span class="string">"encoder"</span>, adapter.getEncoder());</span><br><span class="line">           <span class="comment">// 发送请求的出口和处理请求的入口</span></span><br><span class="line">           pipeline.addLast(<span class="string">"handler"</span>, nettyHandler);</span><br><span class="line">           <span class="keyword">return</span> pipeline;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>另外一方面，值得一提的是<code>HeaderExchangeClient</code>和<code>HeaderExchangeServer</code>，都带有心跳功能，他们会周期扫描当前所有的<code>Channel</code>，如果该<code>Channel</code>最近一个周期内没被读或写的话，则发送一次心跳请求，若心跳超时则进行重连。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeaderExchangeClient</span><span class="params">(Client client, <span class="keyword">boolean</span> needHeartbeat)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">if</span> (needHeartbeat) &#123;</span><br><span class="line">       startHeatbeatTimer();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startHeatbeatTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stopHeartbeatTimer();</span><br><span class="line">   <span class="keyword">if</span> (heartbeat &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 定时运行心跳任务</span></span><br><span class="line">       heartbeatTimer = scheduled.scheduleWithFixedDelay(</span><br><span class="line">               <span class="keyword">new</span> HeartBeatTask(<span class="keyword">new</span> HeartBeatTask.ChannelProvider() &#123;</span><br><span class="line">                   <span class="function"><span class="keyword">public</span> Collection&lt;Channel&gt; <span class="title">getChannels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                       <span class="keyword">return</span> Collections.&lt;Channel&gt;singletonList(HeaderExchangeClient.<span class="keyword">this</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;, heartbeat, heartbeatTimeout),</span><br><span class="line">               heartbeat, heartbeat, TimeUnit.MILLISECONDS);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 进一步看 HeartBeatTask的run方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">   <span class="keyword">for</span> (Channel channel : channelProvider.getChannels()) &#123;</span><br><span class="line">       <span class="keyword">if</span> (channel.isClosed()) &#123;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       Long lastRead = (Long) channel.getAttribute(</span><br><span class="line">               HeaderExchangeHandler.KEY_READ_TIMESTAMP);</span><br><span class="line">       Long lastWrite = (Long) channel.getAttribute(</span><br><span class="line">               HeaderExchangeHandler.KEY_WRITE_TIMESTAMP);</span><br><span class="line">       <span class="comment">//如果上一次rpc操作时间到现在已经超过心跳周期，则发起一起心跳</span></span><br><span class="line">       <span class="keyword">if</span> ((lastRead != <span class="keyword">null</span> &amp;&amp; now - lastRead &gt; heartbeat)</span><br><span class="line">               || (lastWrite != <span class="keyword">null</span> &amp;&amp; now - lastWrite &gt; heartbeat)) &#123;</span><br><span class="line">           Request req = <span class="keyword">new</span> Request();</span><br><span class="line">           req.setVersion(<span class="string">"2.0.0"</span>);</span><br><span class="line">           req.setTwoWay(<span class="keyword">true</span>);</span><br><span class="line">           req.setEvent(Request.HEARTBEAT_EVENT);</span><br><span class="line">           channel.send(req);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (lastRead != <span class="keyword">null</span> &amp;&amp; now - lastRead &gt; heartbeatTimeout) &#123;</span><br><span class="line">           <span class="keyword">if</span> (channel <span class="keyword">instanceof</span> Client) &#123;</span><br><span class="line">               ((Client) channel).reconnect();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               channel.close();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对的，在<code>NettyServer</code>和<code>NettyClient</code>构造函数里，可以看到<code>ChannelHandlers.wrap(handler...)</code>这段逻辑。深入进去后会发现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ChannelHandler <span class="title">wrapInternal</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> MultiMessageHandler(<span class="keyword">new</span> `HeartbeatHandler`(ExtensionLoader.getExtensionLoader(Dispatcher<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">           .<span class="title">getAdaptiveExtension</span>().<span class="title">dispatch</span>(<span class="title">handler</span>, <span class="title">url</span>)))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会在ChannelHandler中嵌入一个<code>HeartbeatHandler</code>，用来处理心跳请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">   setReadTimestamp(channel);</span><br><span class="line">   <span class="comment">// 如果是心跳请求，则直接返回`Response`</span></span><br><span class="line">   <span class="keyword">if</span> (isHeartbeatRequest(message)) &#123;</span><br><span class="line">       Request req = (Request) message;</span><br><span class="line">       <span class="keyword">if</span> (req.isTwoWay()) &#123;</span><br><span class="line">           Response res = <span class="keyword">new</span> Response(req.getId(), req.getVersion());</span><br><span class="line">           res.setEvent(Response.HEARTBEAT_EVENT);</span><br><span class="line">           channel.send(res);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果是心跳返回结果，...</span></span><br><span class="line">   <span class="keyword">if</span> (isHeartbeatResponse(message)) &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   handler.received(channel, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2018/04/23/rpc/dubbo/3.dubbo-%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/23/rpc/dubbo/3.dubbo-%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/" itemprop="url">Dubbo 服务暴露</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-23T00:00:00+08:00">2018-04-23</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/dubbo/" itemprop="url" rel="index"><span itemprop="name">dubbo</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="服务暴露过程解析"><a href="#服务暴露过程解析" class="headerlink" title="服务暴露过程解析"></a>服务暴露过程解析</h1><p>当在XML文件中配置下面内容，启动时<code>Dubbo</code>即会发布<code>demoService</code>服务，服务调用者皆可并在注册中心查到此服务提供者，并向其发起调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:application name=<span class="string">"demo-provider"</span>/&gt;</span><br><span class="line">&lt;dubbo:registry address=<span class="string">"multicast://224.5.6.7:1234"</span>/&gt;</span><br><span class="line">&lt;dubbo:protocol name=<span class="string">"dubbo"</span> port=<span class="string">"32321"</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">"demoService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.alibaba.dubbo.demo.provider.DemoServiceImpl"</span>/&gt;</span><br><span class="line"><span class="comment">//服务发布</span></span><br><span class="line">&lt;dubbo:service <span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.alibaba.dubbo.demo.DemoService"</span> ref=<span class="string">"demoService"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>其中<code>&lt;dubbo:service&gt;</code>用来初始化发布服务，其会被<code>DubboBeanDefinitionParser</code>解析成<code>ServiceBean</code>，并放在Spring容器中。<code>afterPropertiesSet</code>方法初始化<code>ServiceBean</code>。</p>
<p>其主要是从<code>Spring容器</code>中获取<code>Provider</code>、<code>Application</code>、<code>Module</code>、<code>Registeries</code>、<code>Monitor</code>、<code>Protocol</code>对象设置到属性中。</p>
<ul>
<li>没有配置<code>delay</code>属性时，直接调用<code>export</code>暴露服务</li>
<li>配置了<code>delay</code>属性时，则会在Spring实例完所有bean后，发布<code>ContextRefreshEvent</code>事件时，调用<code>ServiceBean</code>(实现<code>ApplicationListener</code>接口)的<code>onApplicationEvent</code>方法进行<code>export</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (getProvider() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 获取所有Provider</span></span><br><span class="line">      Map&lt;String, ProviderConfig&gt; providerConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProviderConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">      <span class="keyword">if</span> (providerConfigMap != <span class="keyword">null</span> &amp;&amp; providerConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          Map&lt;String, ProtocolConfig&gt; protocolConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">          <span class="keyword">if</span> ((protocolConfigMap == <span class="keyword">null</span> || protocolConfigMap.size() == <span class="number">0</span>)</span><br><span class="line">                  &amp;&amp; providerConfigMap.size() &gt; <span class="number">1</span>) &#123; <span class="comment">// backward compatibility</span></span><br><span class="line">              List&lt;ProviderConfig&gt; providerConfigs = <span class="keyword">new</span> ArrayList&lt;ProviderConfig&gt;();</span><br><span class="line">              <span class="keyword">for</span> (ProviderConfig config : providerConfigMap.values()) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (config.isDefault() != <span class="keyword">null</span> &amp;&amp; config.isDefault().booleanValue()) &#123;</span><br><span class="line">                      providerConfigs.add(config);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (!providerConfigs.isEmpty()) &#123;</span><br><span class="line">                  setProviders(providerConfigs);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!isDelay()) &#123;</span><br><span class="line">      export();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>export</code>方法最关键的部分是执行<code>doExportUrls</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//获取注册中心的URL，向多个注册中心发布服务</span></span><br><span class="line">   List&lt;URL&gt; registryURLs = loadRegistries(<span class="keyword">true</span>);</span><br><span class="line">   <span class="comment">// protocols即为`ServiceBean`初始化时从`Spring`容器中获取的对象集合</span></span><br><span class="line">   <span class="comment">//用Protocol挨个暴露服务</span></span><br><span class="line">   <span class="keyword">for</span> (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">       doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>&#123;</span><br><span class="line">   String name = protocolConfig.getName();</span><br><span class="line">   <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">       name = <span class="string">"dubbo"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 拼装参数</span></span><br><span class="line">   Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">   map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);</span><br><span class="line">   map.put(Constants.DUBBO_VERSION_KEY, Version.getVersion());</span><br><span class="line">   map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">   <span class="keyword">if</span> (ConfigUtils.getPid() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">   &#125;</span><br><span class="line">   appendParameters(map, application);</span><br><span class="line">   appendParameters(map, <span class="keyword">module</span>);</span><br><span class="line">   appendParameters(map, provider, Constants.DEFAULT_KEY);</span><br><span class="line">   appendParameters(map, protocolConfig);</span><br><span class="line">   appendParameters(map, <span class="keyword">this</span>);</span><br><span class="line">   ...</span><br><span class="line">   String scope = url.getParameter(Constants.SCOPE_KEY);</span><br><span class="line">   <span class="comment">// scope为local时，只向本地暴露服务</span></span><br><span class="line">   <span class="keyword">if</span> (!Constants.SCOPE_REMOTE.toString().equalsIgnoreCase(scope)) &#123;</span><br><span class="line">      exportLocal(url);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// scope为remote时，向注册中心暴露服务</span></span><br><span class="line">   <span class="keyword">if</span> (!Constants.SCOPE_LOCAL.toString().equalsIgnoreCase(scope)) &#123;</span><br><span class="line">     <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">         logger.info(<span class="string">"Export dubbo service "</span> + interfaceClass.getName() + <span class="string">" to url "</span> + url);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (registryURLs != <span class="keyword">null</span> &amp;&amp; !registryURLs.isEmpty()) &#123;</span><br><span class="line">         <span class="keyword">for</span> (URL registryURL : registryURLs) &#123;</span><br><span class="line">         <span class="comment">// registryURL:</span></span><br><span class="line">             url = url.addParameterIfAbsent(<span class="string">"dynamic"</span>, registryURL.getParameter(<span class="string">"dynamic"</span>));</span><br><span class="line">             URL monitorUrl = loadMonitor(registryURL);</span><br><span class="line">             <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                 logger.info(<span class="string">"Register dubbo service "</span> + interfaceClass.getName() + <span class="string">" url "</span> + url + <span class="string">" to registry "</span> + registryURL);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//通过代理工厂生成一个Invoker</span></span><br><span class="line">             Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</span><br><span class="line">             <span class="comment">//创建一个代理Invoker，包装Invoker并带有元数据</span></span><br><span class="line">             DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">//调用protocol暴露服务    </span></span><br><span class="line">             Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">             exporters.add(exporter);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; ...</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，就是<code>Protocol</code>进行暴露以及发布服务：<br><code>ServiceBean</code>中的<code>Protocol</code>对应的是自适应类型<code>Protocol</code>，调用<code>export</code>方法时，其会根据参数Invoker的URL属性<code>url.getProtocol()</code>来判定调用哪个<code>Protocol</code>对象。上文中的<code>registryURL.getProtocol</code>为<code>registry</code>，所以回去调用<code>RegistryProtocol</code>（会先调用包装类<code>ProtocolListenerWrapper</code>、<code>ProtocolFilterWrapper</code>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">   <span class="comment">//本地暴露服务</span></span><br><span class="line">   <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker);</span><br><span class="line">   URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line">   <span class="comment">//获取注册组件</span></span><br><span class="line">   <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">   <span class="keyword">final</span> URL registedProviderUrl = getRegistedProviderUrl(originInvoker);</span><br><span class="line">   <span class="keyword">boolean</span> register = registedProviderUrl.getParameter(<span class="string">"register"</span>, <span class="keyword">true</span>);</span><br><span class="line">   ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registedProviderUrl);</span><br><span class="line">   <span class="keyword">if</span> (register) &#123;</span><br><span class="line">       register(registryUrl, registedProviderUrl);</span><br><span class="line">       ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(<span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(registedProviderUrl);</span><br><span class="line">   <span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class="line">   overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">   registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> DestroyableExporter&lt;T&gt;(exporter, originInvoker, overrideSubscribeUrl, registedProviderUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的逻辑，可以分为两大部分：第一部分就是 本地服务暴露的逻辑，另一部分是注册服务的逻辑。因此，下面分别从这两部分说：</p>
<h2 id="本地服务暴露："><a href="#本地服务暴露：" class="headerlink" title="本地服务暴露："></a>本地服务暴露：</h2><p><code>doLocalExport</code>就是服务本地暴露的主体代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">ExporterChangeableWrapper&lt;T&gt; <span class="title">doLocalExport</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> </span>&#123;</span><br><span class="line">   String key = getCacheKey(originInvoker);</span><br><span class="line">   ExporterChangeableWrapper&lt;T&gt; exporter = (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);</span><br><span class="line">   <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (bounds) &#123;</span><br><span class="line">           exporter = (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);</span><br><span class="line">           <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//getProviderUrl提取出要暴露的服务Url信息：dubbo://172.19.154.24:32321/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;bind.ip=172.19.154.24&amp;bind.port=32321&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=5464&amp;qos.port=22222&amp;scope=remote&amp;side=provider&amp;timestamp=1520158786026</span></span><br><span class="line">               <span class="keyword">final</span> Invoker&lt;?&gt; invokerDelegete = <span class="keyword">new</span> InvokerDelegete&lt;T&gt;(originInvoker, getProviderUrl(originInvoker));</span><br><span class="line">               <span class="comment">// protocol.export(invokerDelegete)根据url.getProtocol最终调用DubboProtocol的export方法</span></span><br><span class="line">               exporter = <span class="keyword">new</span> ExporterChangeableWrapper&lt;T&gt;((Exporter&lt;T&gt;) protocol.export(invokerDelegete), originInvoker);</span><br><span class="line">               bounds.put(key, exporter);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> exporter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//DubboProtocol.export():</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">   URL url = invoker.getUrl();</span><br><span class="line">   <span class="comment">//key: com.alibaba.dubbo.demo.DemoService:32321</span></span><br><span class="line">   String key = serviceKey(url);</span><br><span class="line">   DubboExporter&lt;T&gt; exporter = <span class="keyword">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">   <span class="comment">// *** 当RPC调用时，也通过key在这个exporterMap中取Exporter ***</span></span><br><span class="line">   exporterMap.put(key, exporter);</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 创建Server,监听端口,开启服务:</span></span><br><span class="line">   openServer(url);</span><br><span class="line">   optimizeSerialization(url);</span><br><span class="line">   <span class="keyword">return</span> exporter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openServer</span><br><span class="line"> -&gt; createServer</span><br><span class="line">    -&gt; Exchangers.bind(url, requestHandler)</span><br></pre></td></tr></table></figure>
<p>其中<code>requestHandler</code>为<code>DubboProtocol</code>的成员变量，当客户端发送请求时将由它进行处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ExchangeHandler requestHandler = <span class="keyword">new</span> ExchangeHandlerAdapter() &#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">reply</span><span class="params">(ExchangeChannel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Invocation) &#123;</span><br><span class="line">           Invocation inv = (Invocation) message;</span><br><span class="line">           Invoker&lt;?&gt; invoker = getInvoker(channel, inv);</span><br><span class="line">           ...</span><br><span class="line">           RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());</span><br><span class="line">           <span class="comment">// 最终同反射的方式调用业务逻辑</span></span><br><span class="line">           <span class="keyword">return</span> invoker.invoke(inv);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line"><span class="comment">//从exporterMap中获取Exporter和Invoker</span></span><br><span class="line">Invoker&lt;?&gt; getInvoker(Channel channel, Invocation inv) <span class="keyword">throws</span> RemotingException &#123;</span><br><span class="line">   ...</span><br><span class="line">   DubboExporter&lt;?&gt; exporter = (DubboExporter&lt;?&gt;) exporterMap.get(serviceKey);</span><br><span class="line">   <span class="keyword">return</span> exporter.getInvoker();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Exchangers.bind(url, requestHandler)</code>监听端口，开启服务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Exchangers.bind(url, requestHandler)</span><br><span class="line">    -&gt; HeaderExchanger.bind()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> HeaderExchangeServer(Transporters.bind(url, <span class="keyword">new</span> DecodeHandler(<span class="keyword">new</span> HeaderExchangeHandler(handler))));</span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Server <span class="title">bind</span><span class="params">(URL url, ChannelHandler... handlers)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">   ChannelHandler handler;</span><br><span class="line">   <span class="keyword">if</span> (handlers.length == <span class="number">1</span>) &#123;</span><br><span class="line">       handler = handlers[<span class="number">0</span>];</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       handler = <span class="keyword">new</span> ChannelHandlerDispatcher(handlers);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 获取Transporter是网络传输层的拓展，根据url中的server或者transporter来确定具体类型，这里先设定为Netty</span></span><br><span class="line">   <span class="keyword">return</span> getTransporter().bind(url, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NettyTransporter.bind()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">bind</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> NettyServer(url, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NettyServer</code>是监听端口，暴露服务的关键。其先设置<code>bindAddress</code>、<code>bindIp</code>、<code>bindPort</code>属性，然后调用<code>doOpen()</code>函数开启服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">   <span class="comment">// ChannelHandlers.wrap()对handler做了一层包装，在其中加上了心跳处理、多消息处理以及`Dispatcher`的逻辑（Dispatcher作用是消息派发）</span></span><br><span class="line">   <span class="keyword">super</span>(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));</span><br><span class="line">&#125;</span><br><span class="line">ChannelHandlers.wrap</span><br><span class="line">    -&gt;ChannelHandlers.getInstance().wrapInternal</span><br><span class="line">        -&gt; <span class="keyword">new</span> MultiMessageHandler(<span class="keyword">new</span> HeartbeatHandler(ExtensionLoader.getExtensionLoader(Dispatcher<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>().<span class="title">dispatch</span>(<span class="title">handler</span>, <span class="title">url</span>)))</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//熟悉<span class="title">Netty</span>的都明白这段的含义：设置<span class="title">boss</span>线程池、<span class="title">work</span>线程池大小，设置<span class="title">pipeline</span>，启动服务监听端口</span></span><br><span class="line"><span class="class"><span class="title">protected</span> <span class="title">void</span> <span class="title">doOpen</span>() <span class="title">throws</span> <span class="title">Throwable</span> </span>&#123;</span><br><span class="line">   NettyHelper.setNettyLoggerFactory();</span><br><span class="line">   ExecutorService boss = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"NettyServerBoss"</span>, <span class="keyword">true</span>));</span><br><span class="line">   ExecutorService worker = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"NettyServerWorker"</span>, <span class="keyword">true</span>));</span><br><span class="line">   ChannelFactory channelFactory = <span class="keyword">new</span> NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS));</span><br><span class="line">   bootstrap = <span class="keyword">new</span> ServerBootstrap(channelFactory);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> NettyHandler nettyHandler = <span class="keyword">new</span> NettyHandler(getUrl(), <span class="keyword">this</span>);</span><br><span class="line">   channels = nettyHandler.getChannels();</span><br><span class="line">   bootstrap.setPipelineFactory(<span class="keyword">new</span> ChannelPipelineFactory() &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ChannelPipeline <span class="title">getPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyServer.<span class="keyword">this</span>);</span><br><span class="line">           ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line">           pipeline.addLast(<span class="string">"decoder"</span>, adapter.getDecoder());</span><br><span class="line">           pipeline.addLast(<span class="string">"encoder"</span>, adapter.getEncoder());</span><br><span class="line">           pipeline.addLast(<span class="string">"handler"</span>, nettyHandler);</span><br><span class="line">           <span class="keyword">return</span> pipeline;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="comment">// bind</span></span><br><span class="line">   channel = bootstrap.bind(getBindAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">   <span class="comment">//export invoker</span></span><br><span class="line">   <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker);</span><br><span class="line">   URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line">   <span class="comment">//获取注册器</span></span><br><span class="line">   <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">   <span class="keyword">final</span> URL registedProviderUrl = getRegistedProviderUrl(originInvoker);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//to judge to delay publish whether or not</span></span><br><span class="line">   <span class="keyword">boolean</span> register = registedProviderUrl.getParameter(<span class="string">"register"</span>, <span class="keyword">true</span>);</span><br><span class="line">   ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registedProviderUrl);</span><br><span class="line">   <span class="keyword">if</span> (register) &#123;</span><br><span class="line">      <span class="comment">// 注册</span></span><br><span class="line">       register(registryUrl, registedProviderUrl);</span><br><span class="line">       ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(<span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(registedProviderUrl);</span><br><span class="line">   <span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class="line">   overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">   <span class="comment">//监听</span></span><br><span class="line">   registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dubbo官方文档中的demo服务默认用`MulticastRegistry`作注册器。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL registryUrl, URL registedProviderUrl)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//获取Registry</span></span><br><span class="line">   Registry registry = registryFactory.getRegistry(registryUrl);</span><br><span class="line">   <span class="comment">// 注册服务</span></span><br><span class="line">   registry.register(registedProviderUrl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以MulticastRegistry为例，最终会调用`doRegister(URL url)`服务：</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">   broadcast(Constants.REGISTER + <span class="string">" "</span> + url.toFullString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 广播注册消息</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">broadcast</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">byte</span>[] data = (msg + <span class="string">"\n"</span>).getBytes();</span><br><span class="line">       DatagramPacket hi = <span class="keyword">new</span> DatagramPacket(data, data.length, mutilcastAddress, mutilcastPort);</span><br><span class="line">       mutilcastSocket.send(hi);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结起来：</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2018/04/22/rpc/dubbo/2.dubbo-spi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/22/rpc/dubbo/2.dubbo-spi/" itemprop="url">Dubbo SPI拓展机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-22T00:00:00+08:00">2018-04-22</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/dubbo/" itemprop="url" rel="index"><span itemprop="name">dubbo</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SPI拓展机制（IOC、AOP、自适应拓展）"><a href="#SPI拓展机制（IOC、AOP、自适应拓展）" class="headerlink" title="SPI拓展机制（IOC、AOP、自适应拓展）"></a>SPI拓展机制（IOC、AOP、自适应拓展）</h1><p>Dubbo 官方文档 <a href="http://dubbo.io/books/dubbo-dev-book/SPI.html" target="_blank" rel="noopener">拓展点加载</a> 介绍了Dubbo的<strong>SPI拓展机制</strong>，总结起来如下：</p>
<blockquote>
<ol>
<li>是<code>JDK SPI</code>的加强版：<ul>
<li>只有使用的时候才会实例化拓展点，而摒弃<code>JDK SPI</code>一次性实例化所有拓展点</li>
<li>增加了对IOC、AOP的支持</li>
</ul>
</li>
<li>拓展的方法：在扩展类的 jar 包内，放置扩展点配置文件 <code>META-INF/dubbo/接口全限定名</code>，内容为：配置名=扩展实现类全限定名，多个实现类用换行符分隔。即可被Dubbo自动加载。</li>
<li>扩展点的特性：<ul>
<li>扩展点自动装配(<strong>IOC</strong>)：加载扩展点时，扩展点实现类的成员如果为其它扩展点类型，在会自动注入依赖的扩展点；</li>
<li>扩展点自动包装：<strong>AOP</strong>的一种实现方式，为拓展点自动添加一层包装，将某些可拓展的共有逻辑放在包装类(Wrapper)中。调用时，会先调用包装类的逻辑再调用拓展点的内容；</li>
<li>扩展点<strong>自适应</strong>：在拓展点方法执行的时候，根据调用的参数(<strong>URL</strong>)决定调用的是哪个拓展点实现，而不会在初始化时就直接指定是哪个拓展点；</li>
<li>扩展点自动激活：对于集合类拓展点，可以同时加载多个实现。自动激活可以简化配置，且可以编排它们的顺序。</li>
</ul>
</li>
</ol>
</blockquote>
<p><code>ExtensionLoader</code>是实现其SPI拓展机制的关键类，Dubbo会为每种类型拓展点都创建有一个<code>ExtensionLoader</code>实例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ExtensionLoader&lt;T&gt; <span class="title">getExtensionLoader</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//首先从缓存里获取</span></span><br><span class="line">   ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">   <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">       EXTENSION_LOADERS.putIfAbsent(type, <span class="keyword">new</span> ExtensionLoader&lt;T&gt;(type));</span><br><span class="line">       loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> loader;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//私有构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ExtensionLoader</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.type = type;</span><br><span class="line">   objectFactory = (type == ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其最主要的属性如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所处理的拓展点类型（接口类型）</span></span><br><span class="line">Class&lt;?&gt; type;</span><br><span class="line"><span class="comment">//拓展点工厂，用于在拓展点注入属性时获取属性的实例（从SPI中获取或者从Spring的上下文中获取）</span></span><br><span class="line">ExtensionFactory objectFactory;</span><br><span class="line"><span class="comment">//拓展点类和名称的映射</span></span><br><span class="line">ConcurrentMap&lt;Class&lt;?&gt;, String&gt; cachedNames = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, String&gt;();</span><br><span class="line"><span class="comment">// 名称和类的映射，类可能有多个名称</span></span><br><span class="line">Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt; cachedClasses = <span class="keyword">new</span> Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt;();</span><br><span class="line"><span class="comment">// 名称与激活拓展点注解的映射。</span></span><br><span class="line">Map&lt;String, Activate&gt; cachedActivates = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Activate&gt;();</span><br><span class="line"><span class="comment">//名称与拓展点实例的映射，一般一个拓展点只会有一个实例</span></span><br><span class="line">ConcurrentMap&lt;String, Holder&lt;Object&gt;&gt; cachedInstances = <span class="keyword">new</span></span><br><span class="line">ConcurrentHashMap&lt;String, Holder&lt;Object&gt;&gt;();</span><br><span class="line"><span class="comment">// 自适应拓展点实例</span></span><br><span class="line">Holder&lt;Object&gt; cachedAdaptiveInstance = <span class="keyword">new</span> Holder&lt;Object&gt;();</span><br><span class="line"><span class="comment">//自实例拓展点类型</span></span><br><span class="line">Class&lt;?&gt; cachedAdaptiveClass = <span class="keyword">null</span>;</span><br><span class="line">String cachedDefaultName;</span><br><span class="line"><span class="comment">//包装类集合 AOP</span></span><br><span class="line">Set&lt;Class&lt;?&gt;&gt; cachedWrapperClasses;</span><br></pre></td></tr></table></figure>

<p>对外暴露的最主要的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取自适应拓展</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getAdaptiveExtension</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//根据name获取特定的拓展实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getExtension</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="comment">// 根据条件获取当前扩展可自动激活的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getActivateExtension</span><span class="params">(URL url, String[] values, String group)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Dubbo初始化时，获取拓展点时一般是调用<code>getActivateExtension</code>获取自适应拓展点，然后在运行时调用方法时，根据实时的参数<code>URL</code>确定拓展点实例的name，调用<code>getExtension(name)</code>获取实例。下面我们依次看这三个实现方法：</p>
<h3 id="getAdaptiveExtension"><a href="#getAdaptiveExtension" class="headerlink" title="getAdaptiveExtension"></a>getAdaptiveExtension</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Object instance = cachedAdaptiveInstance.get();</span><br><span class="line">   <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (createAdaptiveInstanceError == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (cachedAdaptiveInstance) &#123;</span><br><span class="line">               instance = cachedAdaptiveInstance.get();</span><br><span class="line">               <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="comment">//没有时，创建</span></span><br><span class="line">                       instance = createAdaptiveExtension();</span><br><span class="line">                       cachedAdaptiveInstance.set(instance);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                       ...</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//先实例化自适应对象实例，后注入属性</span></span><br><span class="line">       <span class="keyword">return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br><span class="line">   &#125;...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class="line">   <span class="comment">//加载所有type类型类</span></span><br><span class="line">   getExtensionClasses();</span><br><span class="line">   <span class="comment">//若有自适应类信息，则直接返回</span></span><br><span class="line">   <span class="keyword">if</span> (cachedAdaptiveClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> cachedAdaptiveClass;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//没有时，自动生成自适应类(xxx$Adaptive)</span></span><br><span class="line">   <span class="keyword">return</span> cachedAdaptiveClass = createAdaptiveExtensionClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上文分析中有三个比较关键的方法<code>getExtensionClasses</code>、<code>createAdaptiveExtensionClass</code>、<code>injectExtension</code>。下面，我们重点来分析它们：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最终会调用loadExtensionClasses来加载所有type类型的Class</span></span><br><span class="line">getExtensionClass(String name)</span><br><span class="line">    - getExtensionClasses().get(name)</span><br><span class="line">        - loadExtensionClasses()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFile</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir)</span> </span>&#123;</span><br><span class="line">  String fileName = dir + type.getName();</span><br><span class="line">  Enumeration&lt;java.net.URL&gt; urls;</span><br><span class="line">  ClassLoader classLoader = findClassLoader();</span><br><span class="line">  <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">      urls = classLoader.getResources(fileName);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      urls = ClassLoader.getSystemResources(fileName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (urls == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">      java.net.URL url = urls.nextElement();</span><br><span class="line">      BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(url.openStream(), <span class="string">"utf-8"</span>));</span><br><span class="line">      String line = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> ci = line.indexOf(<span class="string">'#'</span>);</span><br><span class="line">          <span class="keyword">if</span> (ci &gt;= <span class="number">0</span>) line = line.substring(<span class="number">0</span>, ci);</span><br><span class="line">          line = line.trim();</span><br><span class="line">          <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              String name = <span class="keyword">null</span>;</span><br><span class="line">              <span class="keyword">int</span> i = line.indexOf(<span class="string">'='</span>);</span><br><span class="line">              <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                  name = line.substring(<span class="number">0</span>, i).trim();</span><br><span class="line">                  line = line.substring(i + <span class="number">1</span>).trim();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">//加载类</span></span><br><span class="line">                  Class&lt;?&gt; clazz = Class.forName(line, <span class="keyword">true</span>, classLoader);</span><br><span class="line">                  <span class="comment">//如果是自适应类，则设置</span></span><br><span class="line">                  <span class="keyword">if</span> (clazz.isAnnotationPresent(Adaptive<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                      <span class="keyword">if</span> (cachedAdaptiveClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                          cachedAdaptiveClass = clazz;</span><br><span class="line">                      &#125;...</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="keyword">try</span> &#123;</span><br><span class="line">                          <span class="comment">//如果有以type为入参的构造函数，则说明类是包装类，加入包装类缓存中</span></span><br><span class="line">                          clazz.getConstructor(type);</span><br><span class="line">                          Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;</span><br><span class="line">                          <span class="keyword">if</span> (wrappers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                              cachedWrapperClasses = <span class="keyword">new</span> ConcurrentHashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">                              wrappers = cachedWrapperClasses;</span><br><span class="line">                          &#125;</span><br><span class="line">                          wrappers.add(clazz);</span><br><span class="line">                      &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                          <span class="comment">//不是包装类时</span></span><br><span class="line">                          clazz.getConstructor();</span><br><span class="line">                          <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                              name = findAnnotationName(clazz);</span><br><span class="line">                              <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                                  <span class="keyword">if</span> (clazz.getSimpleName().length() &gt; type.getSimpleName().length()</span><br><span class="line">                                          &amp;&amp; clazz.getSimpleName().endsWith(type.getSimpleName())) &#123;</span><br><span class="line">                                      name = clazz.getSimpleName().substring(<span class="number">0</span>, clazz.getSimpleName().length() - type.getSimpleName().length()).toLowerCase();</span><br><span class="line">                                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No such extension name for the class "</span> + clazz.getName() + <span class="string">" in the config "</span> + url);</span><br><span class="line">                                  &#125;</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">                          String[] names = NAME_SEPARATOR.split(name);</span><br><span class="line">                          <span class="keyword">if</span> (names != <span class="keyword">null</span> &amp;&amp; names.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                              <span class="comment">//如果带有自动激活注解，则说明是自动激活类，缓存到...</span></span><br><span class="line">                              Activate activate = clazz.getAnnotation(Activate<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                              <span class="keyword">if</span> (activate != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                  cachedActivates.put(names[<span class="number">0</span>], activate);</span><br><span class="line">                              &#125;</span><br><span class="line">                              <span class="keyword">for</span> (String n : names) &#123;</span><br><span class="line">                                  <span class="keyword">if</span> (!cachedNames.containsKey(clazz)) &#123;</span><br><span class="line">                                      cachedNames.put(clazz, n);</span><br><span class="line">                                  &#125;</span><br><span class="line">                                  Class&lt;?&gt; c = extensionClasses.get(n);</span><br><span class="line">                                  <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                      extensionClasses.put(n, clazz);</span><br><span class="line">                                  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != clazz) &#123;</span><br><span class="line">                                                 ...</span><br><span class="line">                                  &#125;</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;...</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="comment">// end of while read lines</span></span><br><span class="line">  &#125; <span class="comment">// end of while urls</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当没有自适应类时，需要自动拼装自适应类，并编译。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;</span><br><span class="line">   <span class="comment">//生成自适应类代码</span></span><br><span class="line">   <span class="comment">//自适应方法的内容，会根据type方法上@Adaptive的属性生成</span></span><br><span class="line">   String code = createAdaptiveExtensionClassCode();</span><br><span class="line">   ClassLoader classLoader = findClassLoader();</span><br><span class="line">   com.alibaba.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>()</span>;</span><br><span class="line">   <span class="comment">//编译</span></span><br><span class="line">   <span class="keyword">return</span> compiler.compile(code, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建类后，需要注入属性，<code>injectExtension</code>方法负责其工作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">injectExtension</span><span class="params">(T instance)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (objectFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (method.getName().startsWith(<span class="string">"set"</span>)</span><br><span class="line">                  &amp;&amp; method.getParameterTypes().length == <span class="number">1</span></span><br><span class="line">                  &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">              Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  String property = method.getName().length() &gt; <span class="number">3</span> ? method.getName().substring(<span class="number">3</span>, <span class="number">4</span>).toLowerCase() + method.getName().substring(<span class="number">4</span>) : <span class="string">""</span>;</span><br><span class="line">                  <span class="comment">// 获取自适应的属性</span></span><br><span class="line">                  Object object = objectFactory.getExtension(pt, property);</span><br><span class="line">                 <span class="comment">// 注入属性</span></span><br><span class="line">                  <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      method.invoke(instance, object);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; ...</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getExtension"><a href="#getExtension" class="headerlink" title="getExtension"></a>getExtension</h3><p>在<code>getAdapativeExtension</code>执行中，已经加载了所有的<code>type</code>拓展类，初始化了<code>type</code>对应的<code>ExtensionLoader</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//loadFile中加载的所有拓展类</span></span><br><span class="line">   Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">   <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> findException(name);</span><br><span class="line">   &#125;</span><br><span class="line">   T instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">   <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//创建对象</span></span><br><span class="line">       EXTENSION_INSTANCES.putIfAbsent(clazz, (T) clazz.newInstance());</span><br><span class="line">       instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//注入属性</span></span><br><span class="line">   injectExtension(instance);</span><br><span class="line">   <span class="comment">//如果有包装类，进行包装</span></span><br><span class="line">   Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line">   <span class="keyword">if</span> (wrapperClasses != <span class="keyword">null</span> &amp;&amp; !wrapperClasses.isEmpty()) &#123;</span><br><span class="line">       <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">           instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getActivateExtension"><a href="#getActivateExtension" class="headerlink" title="getActivateExtension"></a>getActivateExtension</h3><p>根据条件获取当前扩展可自动激活的实现。比如<code>Filter</code>、<code>InvokerListener</code>、<code>ExporterListener</code>。<br><code>getActivateExtension</code>有多个重载函数，最主要的实现在下面这个函数中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getActivateExtension</span><span class="params">(URL url, String[] values, String group)</span> </span>&#123;</span><br><span class="line">   List&lt;T&gt; exts = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">   List&lt;String&gt; names = values == <span class="keyword">null</span> ? <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">0</span>) : Arrays.asList(values);</span><br><span class="line">   <span class="keyword">if</span> (!names.contains(Constants.REMOVE_VALUE_PREFIX + Constants.DEFAULT_KEY)) &#123;</span><br><span class="line">       getExtensionClasses();</span><br><span class="line">       <span class="keyword">for</span> (Map.Entry&lt;String, Activate&gt; entry : cachedActivates.entrySet()) &#123;</span><br><span class="line">           String name = entry.getKey();</span><br><span class="line">           Activate activate = entry.getValue();</span><br><span class="line">           <span class="keyword">if</span> (isMatchGroup(group, activate.group())) &#123;</span><br><span class="line">               T ext = getExtension(name);</span><br><span class="line">               <span class="keyword">if</span> (!names.contains(name)</span><br><span class="line">                       &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)</span><br><span class="line">                       &amp;&amp; isActive(activate, url)) &#123;</span><br><span class="line">                   exts.add(ext);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       Collections.sort(exts, ActivateComparator.COMPARATOR);</span><br><span class="line">   &#125;</span><br><span class="line">   List&lt;T&gt; usrs = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; names.size(); i++) &#123;</span><br><span class="line">       String name = names.get(i);</span><br><span class="line">       <span class="keyword">if</span> (!name.startsWith(Constants.REMOVE_VALUE_PREFIX)</span><br><span class="line">               &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)) &#123;</span><br><span class="line">           <span class="keyword">if</span> (Constants.DEFAULT_KEY.equals(name)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!usrs.isEmpty()) &#123;</span><br><span class="line">                   exts.addAll(<span class="number">0</span>, usrs);</span><br><span class="line">                   usrs.clear();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               T ext = getExtension(name);</span><br><span class="line">               usrs.add(ext);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!usrs.isEmpty()) &#123;</span><br><span class="line">       exts.addAll(usrs);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> exts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>讲完它的原理，来看几个源码中的例子更好的理解下：</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2018/04/21/rpc/dubbo/1.dubbo%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/21/rpc/dubbo/1.dubbo%E7%AE%80%E4%BB%8B/" itemprop="url">Dubbo</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-21T00:00:00+08:00">2018-04-21</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/dubbo/" itemprop="url" rel="index"><span itemprop="name">dubbo</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h1><p>Dubbo是阿里开源的一套基于Java的高性能RPC框架。经常听人提起它，正好前段时间看了下新美大的RPC框架，因此闲暇中翻开代码来咀嚼了一番，收获颇多，也很有感触！！</p>
<p>本文主要涵盖以下内容：</p>
<ul>
<li>SPI拓展机制（IOC、AOP、自适应拓展）</li>
<li>服务暴露解析</li>
<li>服务引用解析</li>
<li>服务调用过程解析（请求、响应、编解码）</li>
<li>服务发布订阅与通知</li>
<li>组件解析与比较(Cluster、LoadBalancer、Directory、Router、Registry)</li>
</ul>
<p>其中，会大量结合源码讲解整个过程！</p>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul>
<li><strong>SPI</strong>（<code>IOC</code>、<code>AOP</code>）✅</li>
<li><strong>执行流程</strong></li>
<li><strong>初始化过程</strong><ul>
<li><strong>服务注册、发现</strong></li>
<li><strong>服务变更</strong></li>
</ul>
</li>
<li><strong>负载均衡</strong></li>
<li><strong>服务降级</strong></li>
<li><strong>失败重试</strong></li>
<li><strong>服务监控</strong></li>
<li><strong>传输层实现</strong><ul>
<li>NettyServer</li>
<li>NettyClient</li>
<li>NettyHandler</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2018/04/12/rpc/netty/6.netty-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/12/rpc/netty/6.netty-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" itemprop="url">Netty 内存管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-12T00:00:00+08:00">2018-04-12</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/netty/" itemprop="url" rel="index"><span itemprop="name">netty</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p><strong>Netty</strong>的内存管理有两部分要点：自适应内存大小算法和真实的内存管理：</p>
<p>再讲之前我们再来看看数据读取的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">  <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">  <span class="comment">// 用来分配ByteBuf内存的 PooledByteBufAllocator</span></span><br><span class="line">  <span class="keyword">final</span> ByteBufAllocator allocator = config.getAllocator();</span><br><span class="line">  <span class="comment">// 用来决定分配多大的 ByteBuf (自适应缓存分配大小)，以防止缓存分配过多或过少</span></span><br><span class="line">  <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();</span><br><span class="line">  allocHandle.reset(config);</span><br><span class="line">  ByteBuf byteBuf = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">boolean</span> close = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// allocator.ioBuffer(allocHandle.guess());</span></span><br><span class="line">      byteBuf = allocHandle.allocate(allocator);</span><br><span class="line">      <span class="comment">// 在读取的过程中，alloHandle会记录读取了多少字节</span></span><br><span class="line">      allocHandle.lastBytesRead(doReadBytes(byteBuf));</span><br><span class="line">      <span class="keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// nothing was read. release the buffer.</span></span><br><span class="line">          byteBuf.release();</span><br><span class="line">          byteBuf = <span class="keyword">null</span>;</span><br><span class="line">          close = allocHandle.lastBytesRead() &lt; <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      allocHandle.incMessagesRead(<span class="number">1</span>);</span><br><span class="line">      readPending = <span class="keyword">false</span>;</span><br><span class="line">      pipeline.fireChannelRead(byteBuf);</span><br><span class="line">      byteBuf = <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line">  <span class="comment">// 跟据本次读取的字节，计算下一次应该分配的ByteBuf大小</span></span><br><span class="line">  allocHandle.readComplete();</span><br><span class="line">  pipeline.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (close) &#123;</span><br><span class="line">      closeOnRead(pipeline);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到两个在内存分配管理上比较重要的<code>Allocator</code>、<code>AllocHandle</code>。</p>
<p><strong>Allocator</strong> 是用来分配内存的，而<strong>AllocHandle</strong>则是用来辅助分配内存的，决定在不知道内存空间有多大的情况下预分配多大的<strong>ByteBuf</strong>。</p>
<h2 id="AllocHandle-决定分配ByteBuf大小"><a href="#AllocHandle-决定分配ByteBuf大小" class="headerlink" title="AllocHandle(决定分配ByteBuf大小)"></a>AllocHandle(决定分配ByteBuf大小)</h2><p><strong>AllocHandle</strong>，其实现有多种。这里，重点来看<code>AdaptiveRecvByteBufAllocator.HandleImpl</code>：</p>
<p>在<code>AdaptiveRecvByteBufAllocator</code>内部会维护以下信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化时的配置</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MINIMUM = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAXIMUM = <span class="number">65536</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index的自增值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INDEX_INCREMENT = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// index自建值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INDEX_DECREMENT = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SIZE_TABLE 用来存放分配大小的尺度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] SIZE_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据最小配置大小得到的在SIZE_TABLE中的下标</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> minIndex;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxIndex;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> initial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">   List&lt;Integer&gt; sizeTable = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">16</span>; i &lt; <span class="number">512</span>; i += <span class="number">16</span>) &#123;</span><br><span class="line">       sizeTable.add(i);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">512</span>; i &gt; <span class="number">0</span>; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">       sizeTable.add(i);</span><br><span class="line">   &#125;</span><br><span class="line">   SIZE_TABLE = <span class="keyword">new</span> <span class="keyword">int</span>[sizeTable.size()];</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE_TABLE.length; i ++) &#123;</span><br><span class="line">       SIZE_TABLE[i] = sizeTable.get(i);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 初始化完成后，sizeTable : 16, 32, 48, 64, ..., 496,512,1024,2048...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在读取数据的时候，<code>alloHandle</code>会记录一次读取总共读取了多少字节（<code>lastBytesRead</code>），完成读取后会调用<code>readComplete</code>会计算下次应该分配多大内存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  record(totalBytesRead());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">record</span><span class="params">(<span class="keyword">int</span> actualReadBytes)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 是否比（当前缩容后）的大小还要小</span></span><br><span class="line">  <span class="keyword">if</span> (actualReadBytes &lt;= SIZE_TABLE[Math.max(<span class="number">0</span>, index - INDEX_DECREMENT - <span class="number">1</span>)]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (decreaseNow) &#123;</span><br><span class="line">          index = Math.max(index - INDEX_DECREMENT, minIndex);</span><br><span class="line">          nextReceiveBufferSize = SIZE_TABLE[index];</span><br><span class="line">          decreaseNow = <span class="keyword">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          decreaseNow = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 是否比当前扩容后的大小还要大      </span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actualReadBytes &gt;= nextReceiveBufferSize) &#123;</span><br><span class="line">      index = Math.min(index + INDEX_INCREMENT, maxIndex);</span><br><span class="line">      nextReceiveBufferSize = SIZE_TABLE[index];</span><br><span class="line">      decreaseNow = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当决定分配内存大小的时候调用的是<code>guess</code>方法，可以看出正式上一次计算出的大小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">guess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nextReceiveBufferSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Allocator-内存分配"><a href="#Allocator-内存分配" class="headerlink" title="Allocator 内存分配"></a>Allocator 内存分配</h2><p>Allocator的内存分配实现有以下两个：<br><img src="/media/15283341055629.jpg" alt=""></p>
<ul>
<li><strong>PooledByteBufAllocator：</strong>基于内存池的字节缓冲区分配器</li>
<li><strong>UnpooledByteBufAllocator：</strong>普通的字节缓存区分配器</li>
</ul>
<p>##TODO</p>
<ul>
<li><a href="https://vinoit.me/2017/06/23/netty-memory-recycle/" target="_blank" rel="noopener">非内存池的内存回收</a></li>
<li>内存池对象分配</li>
<li>Netty之有效规避内存泄漏</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2018/04/11/rpc/netty/5.netty-server/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/11/rpc/netty/5.netty-server/" itemprop="url">Netty 服务接收请求&响应</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-11T00:00:00+08:00">2018-04-11</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/netty/" itemprop="url" rel="index"><span itemprop="name">netty</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="服务端创建连接并响应请求"><a href="#服务端创建连接并响应请求" class="headerlink" title="服务端创建连接并响应请求"></a>服务端创建连接并响应请求</h1><p>客户端与服务端通讯必须先创建连接。<br>在前文介绍服务端初始化的时候说道初始化的时候会向<code>boss</code>线程注册一个<code>OP_ACCEPT</code>事件。客户端请求链接时即会触发此事件。当<strong>boss线程池</strong>中的<code>NioEventLoop</code>在循环的时候检测到此事件时，会触发<code>NioMessageUnsafe.read</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">  <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">  <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</span><br><span class="line">  allocHandle.reset(config);</span><br><span class="line">  <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line">  Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">          <span class="comment">// NioServerSocketChannel.doReadMessage</span></span><br><span class="line">          <span class="keyword">int</span> localRead = doReadMessages(readBuf);</span><br><span class="line">          <span class="keyword">if</span> (localRead == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (localRead &lt; <span class="number">0</span>) &#123;</span><br><span class="line">              closed = <span class="keyword">true</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          allocHandle.incMessagesRead(localRead);</span><br><span class="line">      &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      exception = t;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> size = readBuf.size();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">      readPending = <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 触发 ChannelHandler的 channelRead方法，经过LoggingHandler最后到ServerBootstrapAcceptor</span></span><br><span class="line">      pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line">  &#125;</span><br><span class="line">  readBuf.clear();</span><br><span class="line">  allocHandle.readComplete();</span><br><span class="line">  pipeline.fireChannelReadComplete();</span><br><span class="line">  <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">      closed = closeOnReadError(exception);</span><br><span class="line">      pipeline.fireExceptionCaught(exception);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">      inputShutdown = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (isOpen()) &#123;</span><br><span class="line">          close(voidPromise());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="comment">// 从ServerSocketChannel.accept一个SocketChannel</span></span><br><span class="line">   SocketChannel ch = SocketUtils.accept(javaChannel());</span><br><span class="line">   <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</span><br><span class="line">       buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和<code>Client</code>端的不同之处即在于<code>doReadMessages</code>方法。此处调用的是<code>NioServerSocketChannel.doReadMessage</code>。<br>其调用的是原生<code>ServerSocketChannel.accept</code>方法来获取一个<code>SocektChannel</code>然后封装在<code>NioSocetChannel</code>中，并将其传递到<strong>ServerBootstrapAcceptor</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Channel child = (Channel) msg;</span><br><span class="line">  <span class="comment">// 将初始化时设置的childHandler 加入到pipeline 中</span></span><br><span class="line">  child.pipeline().addLast(childHandler);</span><br><span class="line">  setChannelOptions(child, childOptions, logger);</span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</span><br><span class="line">      child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 往reactor线程池中注入，即跟某个`NioEventLoop`绑定。</span></span><br><span class="line">      childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                  forceClose(child, future.cause());</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      forceClose(child, t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，将初始化时配置的<code>childHandler</code>加到<code>Channel</code>的<code>pipeline</code>中，然后将<code>Channel</code>注册到某个 <strong>Reactor线程</strong> 上，然后开始监听<code>OP_READ</code>读事件。<br>此后与客户端的通讯工作即会在<strong>Reactor线程</strong>中进行，其过程与<code>Client</code>中一致，因此这里不再复述。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2018/04/09/rpc/netty/4.netty-client/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/09/rpc/netty/4.netty-client/" itemprop="url">Netty 客户端请求&响应</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-09T00:00:00+08:00">2018-04-09</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/netty/" itemprop="url" rel="index"><span itemprop="name">netty</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="客户端请求发送与获取响应"><a href="#客户端请求发送与获取响应" class="headerlink" title="客户端请求发送与获取响应"></a>客户端请求发送与获取响应</h1><p>在<code>Netty</code>里，发送请求的过程可以分为两步：1. 将请求写到缓存队列中，2.将缓存队列中的请求进行 <strong>flush</strong> —– 调用原生的<code>SocketChannel</code>进行发送。</p>
<p><strong>在客户端初始化时</strong>，讲到客户端的<code>Channel</code>会在<code>Selector</code>上注册<code>OP_READ</code>操作，当有服务端响应结果时，则触发<code>OP_READ</code>事件。</p>
<h2 id="请求发送"><a href="#请求发送" class="headerlink" title="请求发送"></a>请求发送</h2><p>首先来看发送请求的过程：<strong>SocketChannel</strong> 有两个方法用于发送请求，<code>write</code>和<code>writeAndFlush</code>，其中<code>write</code>用于将请求<code>ByteBuf</code>放入发送队列中，<code>writeAndFlush</code>则将请求发送到队列中，并把发送队列中的数据发送出去。这里以<code>writeAndFlush</code>来讲解整个过程<br>调用<code>writeAndFlush</code>方法最终会调用<code>AbstractChannelHandlerContext.write</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, <span class="keyword">boolean</span> flush, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">   AbstractChannelHandlerContext next = findContextOutbound();</span><br><span class="line">   <span class="keyword">final</span> Object m = pipeline.touch(msg, next);</span><br><span class="line">   EventExecutor executor = next.executor();</span><br><span class="line">   <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">       <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">           next.invokeWriteAndFlush(m, promise);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           next.invokeWrite(m, promise);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       AbstractWriteTask task;</span><br><span class="line">       <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">           task = WriteAndFlushTask.newInstance(next, m, promise);</span><br><span class="line">       &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">           task = WriteTask.newInstance(next, m, promise);</span><br><span class="line">       &#125;</span><br><span class="line">       safeExecute(executor, task, promise, m);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其判断发起请求操作 <code>channel</code> 的对应的线程上下文中，不是则创建任务并将其扔进<code>EventLoop</code>的任务队列中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeWriteAndFlush</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">       invokeWrite0(msg, promise);</span><br><span class="line">       invokeFlush0();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       writeAndFlush(msg, promise);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeWrite0</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">   ((ChannelOutboundHandler) handler()).write(<span class="keyword">this</span>, msg, promise);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeFlush0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ((ChannelOutboundHandler) handler()).flush(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就可以看到<code>invokeWrite0</code>和<code>invokeFlush0</code>两个过程：</p>
<ol>
<li>invokeWrite0调用链如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">HeadContext.write</span><br><span class="line">-&gt; AbstractChannel.unsafe.write</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">  ChannelOutboundBuffer outboundBuffer = <span class="keyword">this</span>.outboundBuffer;</span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  msg = filterOutboundMessage(msg);</span><br><span class="line">  size = pipeline.estimatorHandle().size(msg);</span><br><span class="line">  <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  outboundBuffer.addMessage(msg, size, promise);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMessage</span><span class="params">(Object msg, <span class="keyword">int</span> size, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">   Entry entry = Entry.newInstance(msg, size, total(msg), promise);</span><br><span class="line">   <span class="keyword">if</span> (tailEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">       flushedEntry = <span class="keyword">null</span>;</span><br><span class="line">       tailEntry = entry;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       Entry tail = tailEntry;</span><br><span class="line">       tail.next = entry;</span><br><span class="line">       tailEntry = entry;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (unflushedEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">       unflushedEntry = entry;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终可以看到，write的过程是将<code>msg</code>包装进<code>Entry</code>然后加到<code>outboundBuffer</code>中，并没有做真正的发送。</p>
<p>在看<code>flush</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ChannelOutboundBuffer outboundBuffer = <span class="keyword">this</span>.outboundBuffer;</span><br><span class="line">  <span class="keyword">if</span> (outboundBuffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将之前加进去的数据设置为flushed，可以开始发送</span></span><br><span class="line">  outboundBuffer.addFlush();</span><br><span class="line">  <span class="comment">// 将可以发送的消息进行发送</span></span><br><span class="line">  flush0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flush方法先讲<code>outboundBuffer</code>之前<code>add</code>的消息标记为已发送，然后调用<strong>flush0</strong>进行真正的发送。</p>
<h2 id="获取响应"><a href="#获取响应" class="headerlink" title="获取响应"></a>获取响应</h2><p>当 <strong>Server</strong> 端接收到请求并处理后返回结果给<strong>Client</strong>端。<strong>Client</strong>端的<code>NioEventLoop.Selector</code>会告诉客户端数据已准备好可读触发<strong>unsafe.read</strong>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">  <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">  <span class="keyword">final</span> ByteBufAllocator allocator = config.getAllocator();</span><br><span class="line">  <span class="comment">// ByteBuf 内存分配器（内存分配策略是Netty里值得深入理解的一块，后文中我们将单独领出来说）</span></span><br><span class="line">  <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();</span><br><span class="line">  allocHandle.reset(config);</span><br><span class="line">  ByteBuf byteBuf = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">boolean</span> close = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">      byteBuf = allocHandle.allocate(allocator);</span><br><span class="line">      <span class="comment">// 从SocketChannel中读取数据到byteBuf中</span></span><br><span class="line">      allocHandle.lastBytesRead(doReadBytes(byteBuf));</span><br><span class="line">      <span class="keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          byteBuf.release();</span><br><span class="line">          byteBuf = <span class="keyword">null</span>;</span><br><span class="line">          close = allocHandle.lastBytesRead() &lt; <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      allocHandle.incMessagesRead(<span class="number">1</span>);</span><br><span class="line">      readPending = <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 触发数据读取事件，调用channelHanlder的channelRead方法</span></span><br><span class="line">      pipeline.fireChannelRead(byteBuf);</span><br><span class="line">      byteBuf = <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line">  allocHandle.readComplete();</span><br><span class="line">  <span class="comment">// 调用channelHandler的channelReadComplete方法</span></span><br><span class="line">  pipeline.fireChannelReadComplete();</span><br><span class="line">  <span class="keyword">if</span> (close) &#123;</span><br><span class="line">      closeOnRead(pipeline);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到大体流程是，先调用<strong>allocHandle</strong>分配一个<strong>ByteBuf</strong>，然后从<code>ScoketChannel</code>中读取数据，触发<strong>pipeline.fireChannelRead</strong>（执行<code>channelHandler</code>的<code>channelRead</code>方法）方法，读取完成后再执行<strong>pipeline.fireChannelReadComplete</strong>方法（执行<code>channelHandler</code>的<code>channelRead</code>方法）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2018/04/08/rpc/netty/3.netty-nioeventloop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/08/rpc/netty/3.netty-nioeventloop/" itemprop="url">Netty NioEventLoop</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-08T00:00:00+08:00">2018-04-08</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/netty/" itemprop="url" rel="index"><span itemprop="name">netty</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="NioEventLoop"><a href="#NioEventLoop" class="headerlink" title="NioEventLoop"></a>NioEventLoop</h1><p>在初始化过程中，<code>Client</code>和<code>Server</code>用的 <code>EventLoopGroup</code>是 <code>NioEventLoopGroup</code>，而其内部是<code>NioEventLoop</code>数组。<br><strong>NioEventLoop</strong>并不是一个纯粹的I/O线程，还负责处理两类任务：</p>
<ul>
<li><strong>系统Task：</strong> 当I/O线程和用户线程同时操作网路资源时，为了防止并发操作导致的锁竞争，将用户线程的操作封装成 Task放入消息队列中，由I/O线程负责执行，这样就实现了局部无锁化；</li>
<li><strong>定时任务：</strong> 通过<code>schedule</code>方法可以执行定时任务。<br>继续来看其<code>run</code>方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">       <span class="comment">// 唤醒 Selector</span></span><br><span class="line">       <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line">           <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">               select(wakenUp.getAndSet(<span class="keyword">false</span>));</span><br><span class="line">               <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">                   selector.wakeup();</span><br><span class="line">               &#125;</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">       &#125;</span><br><span class="line">       cancelledKeys = <span class="number">0</span>;</span><br><span class="line">       needsToSelectAgain = <span class="keyword">false</span>;</span><br><span class="line">       <span class="comment">// io任务比例，默认 50</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line">       <span class="comment">// 100时，则先执行io任务，再执行task</span></span><br><span class="line">       <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               processSelectedKeys();</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               runAllTasks();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//记录IO时间</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               processSelectedKeys();</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="comment">//反推任务能执行的时间长度</span></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">               runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到里面有个<code>ioRatio</code>，表示IO任务的比例。<br>当为<code>100%</code>时，先进行IO操作再执行任务；否则先进行IO操作，然后根据 <strong>IO操作的时间</strong> 来计算任务可以执行的时间长度。默认为<strong>50%</strong>。<br>再细看<code>processSelectedKeys</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (selectedKeys != <span class="keyword">null</span>) &#123;</span><br><span class="line">       processSelectedKeysOptimized();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       processSelectedKeysPlain(selector.selectedKeys());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeysOptimized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; selectedKeys.size; ++i) &#123;</span><br><span class="line">       <span class="keyword">final</span> SelectionKey k = selectedKeys.keys[i];</span><br><span class="line">       selectedKeys.keys[i] = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">final</span> Object a = k.attachment();</span><br><span class="line">       <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">           processSelectedKey(k, (AbstractNioChannel) a);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">int</span> readyOps = k.readyOps();</span><br><span class="line">       <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">int</span> ops = k.interestOps();</span><br><span class="line">           ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">           k.interestOps(ops);</span><br><span class="line">           unsafe.finishConnect();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">           ch.unsafe().forceFlush();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">           unsafe.read();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class="line">       unsafe.close(unsafe.voidPromise());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它遍历每个<code>SelectionKey</code>，查看有哪些已经准备好的操作，根据准备好的事件进行相应的操作。</p>
<p><strong>runAllTasks</strong>方法从 <code>taskQueue</code> 中获取所有的任务进行执行。对于<code>taskQueue</code>维护着的业务方提交的任务。在执行其<code>execute</code>方法的时候即把任务放进<code>taskQueue</code>中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avator.jpeg"
                alt="Zamperini" />
            
              <p class="site-author-name" itemprop="name">Zamperini</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/%7C%7C%20archive">
                
                    <span class="site-state-item-count">55</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/DorgenJones" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:dblpfilter@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/1938368215" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zamperini</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.0.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.3"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
