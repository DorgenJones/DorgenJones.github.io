<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://dorgenjones.github.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Zamperini">
<meta property="og:url" content="https://dorgenjones.github.io/page/3/index.html">
<meta property="og:site_name" content="Zamperini">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zamperini">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://dorgenjones.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Zamperini</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Zamperini</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">23</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">56</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2019/01/03/database/zbera/zebra/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.png">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/03/database/zbera/zebra/" class="post-title-link" itemprop="url">数据库中间件Zebra</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-03 14:51:53" itemprop="dateCreated datePublished" datetime="2019-01-03T14:51:53+08:00">2019-01-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-13 20:12:56" itemprop="dateModified" datetime="2020-02-13T20:12:56+08:00">2020-02-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/database/" itemprop="url" rel="index">
                    <span itemprop="name">database</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Zebra"><a href="#Zebra" class="headerlink" title="Zebra"></a>Zebra</h1><p>[TOC]</p>
<h2 id="Zebra是什么？能干甚么？"><a href="#Zebra是什么？能干甚么？" class="headerlink" title="Zebra是什么？能干甚么？"></a>Zebra是什么？能干甚么？</h2><p><code>Zebra</code>是一个在JDBC协议上开发的<strong>数据库连接池中间件</strong>，它不是真连接池(与DB直接交互的连接池)，而是对连接池做了一层包装。<br><img src="/media/15117842144905.jpg" alt=""><br><strong>功能：</strong></p>
<ol>
<li>支持适配目前主流的数据库连接池（如上图）</li>
<li>读写分离、分库分表</li>
<li>支持配置动态修改生效(连接池的配置、用户密码、数据库节点访问路由负载均衡配置)</li>
<li>CAT全方位监控（SQL执行情况、数据库连接数、端到端监控）</li>
<li>支持压测(改写表名)、SQL限流、黑白名单、SQL改写、<a href="https://wiki-in.sankuai.com/pages/viewpage.action?pageId=1169090716" target="_blank" rel="noopener">SQL审计</a>(日志审计，SQL安全监控)…</li>
</ol>
<h2 id="同类产品有哪些，以及比较？"><a href="#同类产品有哪些，以及比较？" class="headerlink" title="同类产品有哪些，以及比较？"></a>同类产品有哪些，以及比较？</h2><table>
<thead>
<tr>
<th>类别</th>
<th>案例</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>基于代理</td>
<td>mycat、cobor、atlas、jed</td>
<td>多语言支持、节省数据库连接</td>
<td>风险大(链路长)、实现难度大、共享连接时有风险</td>
</tr>
<tr>
<td>基于客户端(jdbc层)</td>
<td>tddl</td>
<td>直连数据库(风险较小)、更灵活</td>
<td>对于每种语言都需要重写sdk、富客户端的常见缺点</td>
</tr>
</tbody></table>
<p><strong>基于代理：</strong><br><img src="/media/15117932686716.jpg" alt=""></p>
<p><strong>基于客户端：</strong><br><img src="/media/15117932921029.jpg" alt="set up-w500"></p>
<blockquote>
<p>公司目前：北京侧 <code>Altas</code>居多，也有<code>Atlas</code>与<code>zebra</code>搭配使用（使用其压测处理、SQL监控特性），上海侧统一使用<code>zebra</code>。趋势是转向<strong>Zebra</strong>。<a href="https://wiki-ini.sankuai.com/pages/viewpage.action?pageId=686244717" target="_blank" rel="noopener">Atlas与Zebra的对比</a>。<strong>zebra秒杀Atlas?</strong><br><a href="https://wiki-ini.sankuai.com/pages/viewpage.action?pageId=1114400138" target="_blank" rel="noopener">数据库中间件比较</a></p>
</blockquote>
<p><strong><em>为什么美团一开始没有选择基于sdk的方式，而是基于代理的方式来做的？</em></strong></p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="/media/15117945912786.jpg" alt=""></p>
<ul>
<li>Zebra客户端做读写分离、分库分表、打点、监控</li>
<li>RDS、DBA管理平台维护配置信息</li>
<li>Lion监听配置更新，通知客户端生效变更</li>
<li>MHA保障主库的高可用性</li>
<li>zebra-monitor(<strong>自研</strong>)保障丛库的高可用性</li>
</ul>
<blockquote>
<p>MHA（Master High Availability）是作为MySQL高可用环境下，操作故障切换、主从提升的一套解决方案。MHA（Master High Availability）目前在MySQL高可用方面是一个相对成熟的解决方案。能做到30内完成故障切换。 <a href="http://ronaldbradford.com/#introduction" target="_blank" rel="noopener">官网</a>。<br>PS: <strong>Atlas</strong>维护主的高可用性也是MHA，且和Zebra是同一个MHA。</p>
</blockquote>
<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><h3 id="主库的高可用"><a href="#主库的高可用" class="headerlink" title="主库的高可用"></a>主库的高可用</h3><p>利用MHA进行master节点的可用性监控，在发生故障，master节点不可用时，<strong>MHA进行mysql层的主从切换</strong>，切换成功后通知zebra新master节点的IP，由zebra客户端负责应用访问层的切换。<a href="https://wiki-in.sankuai.com/pages/viewpage.action?pageId=614561285" target="_blank" rel="noopener">官方文档</a><br>切换流程如下：</p>
<p><img src="/media/15117954829456.jpg" alt=""></p>
<ol>
<li>MHA对MySQL集群进行监控管理</li>
<li>当主库发生故障时，MHA通知zebra对主库的写进行关闭，并进行MySQL集群的主从切换（切换期间应用无法写数据）</li>
<li>zebra禁止掉对故障集群的写操作</li>
<li>MHA切换成功，通知zebra新的写数据IP</li>
<li>zebra用新的写IP替换老IP，开放应用访问。</li>
</ol>
<h3 id="丛库的高可用"><a href="#丛库的高可用" class="headerlink" title="丛库的高可用"></a>丛库的高可用</h3><p>由<code>zebra-monitor</code>的监控服务负责，实时监控线上MySQL从库的健康状况，如果出现从库“故障”，将会通知zebra将读流量转移到其他可读节点，实现从库的“故障”转移。<br><img src="/media/15117960397314.jpg" alt=""></p>
<p><strong>丛库状态判断</strong>： zebra-monitor监控首先使用<code>select 1</code> 测试是否可以连通数据库，连接没有问题则使用 <code>show slave status</code> 获取到<code>second_behind_master</code>字段来得到该从库上的延迟，从而做出判断：</p>
<ul>
<li><p>markdown（故障）</p>
<ol>
<li>30s内从库连续ping不通； (从库宕机)</li>
<li>30s内 second_behind_master取到的延迟为null。 (主从同步中断)</li>
<li>延迟超过阈值。（可根据每个库的敏感程度进行个性化配置，需要进行另外配置）</li>
</ol>
<p><strong>故障处理：</strong>从库markdown，zebra客户端会收到通知动态刷新连接池配置，重建本地数据源配置，流量不会再走到故障丛库，老的数据源会在全部sql执行完成后被close。</p>
</li>
<li><p>markup(恢复)</p>
<ul>
<li>30s内能够连续ping通并且主从延迟为0.</li>
</ul>
</li>
</ul>
<p><strong>故障恢复：</strong>丛库恢复时，会通知客户端进行动态刷新数据源。</p>
<h1 id="Zebra-client"><a href="#Zebra-client" class="headerlink" title="Zebra-client"></a>Zebra-client</h1><p>##总览<br><img src="/media/15120548762216.jpg" alt=""></p>
<h3 id="推荐使用包搭配"><a href="#推荐使用包搭配" class="headerlink" title="推荐使用包搭配"></a>推荐使用包搭配</h3><p><strong>zebra-api</strong>、<strong>zebra-ds-monitor</strong>、<strong>mtrace-zebra</strong></p>
<h2 id="zebra-api"><a href="#zebra-api" class="headerlink" title="zebra-api"></a>zebra-api</h2><p><strong>ShardDataSource + m x GroupDataSource(Master + n x Slave)</strong><br><img src="/media/15118032253780.png" alt="set up-w600"></p>
<h3 id="SingleDataSource"><a href="#SingleDataSource" class="headerlink" title="SingleDataSource"></a>SingleDataSource</h3><ul>
<li>屏蔽底层DataSource的差异，通过<strong>C3p0DataSourceAdapter</strong>适配具体连接池配置，并根据配置创建指定类型的连接池。</li>
</ul>
<p><img src="/media/15118603297936.jpg" alt=""></p>
<h3 id="GroupDataSource"><a href="#GroupDataSource" class="headerlink" title="GroupDataSource"></a>GroupDataSource</h3><p><strong>GroupDataSource</strong>主要职能 <strong>读写分离、负载均衡与路由</strong>。但还有一个好处就是不需要写死配置(jdbcUrl、user|pwd、连接池配置，且配置修改可实时生效)。</p>
<p><img src="/media/15120563275340.jpg" alt=""></p>
<p><img src="/media/15120563707402.jpg" alt=""></p>
<p><img src="/media/15120564127233.jpg" alt=""></p>
<p><strong>读写分离策略：</strong> <a href="https://wiki-in.sankuai.com/pages/viewpage.action?pageId=735464033" target="_blank" rel="noopener">官方文档</a>：<br><img src="/media/15118644696383.jpg" alt="set up-w460"></p>
<p><strong>路由策略：</strong> <a href="https://wiki-in.sankuai.com/pages/viewpage.action?pageId=943490395" target="_blank" rel="noopener">官方文档</a>，见代码片段<br><img src="/media/15120566448649.jpg" alt="set up-w500"></p>
<h3 id="ShardDataSource"><a href="#ShardDataSource" class="headerlink" title="ShardDataSource"></a>ShardDataSource</h3><p><code>ShardDataSource</code>的职责是支持<strong>分库分表路由</strong>，除此之外还有并发执行等。<br><img src="/media/15118830559654.jpg" alt="set up-w600"></p>
<h4 id="分片规则："><a href="#分片规则：" class="headerlink" title="分片规则："></a>分片规则：</h4><p>利用脚本语言的灵活性，支持任意维度的分片：支持HASH、时间等，同时也可以使用Groovy内置的函数</p>
<p>示例脚本：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;shard-dimension dbRule=<span class="string">"(#id#.intValue() % 8).intdiv(2)"</span></span><br><span class="line">	dbIndexes=<span class="string">"id[0-3]"</span></span><br><span class="line">	tbRule=<span class="string">"#id#.intValue() % 2"</span></span><br><span class="line">	tbSuffix=<span class="string">"alldb:[0,7]"</span></span><br><span class="line">	isMaster=<span class="string">"true"</span>&gt;</span><br><span class="line">&lt;/shard-dimension&gt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RuleEngineBaseImpl</span> <span class="keyword">extends</span> <span class="title">com</span>.<span class="title">dianping</span>.<span class="title">zebra</span>.<span class="title">shard</span>.<span class="title">router</span>.<span class="title">rule</span>.<span class="title">engine</span>.<span class="title">RuleEngineBase</span> &#123;</span></span><br><span class="line">  Object execute(Map context) &#123;</span><br><span class="line">  (context.get(<span class="string">"id"</span>).intValue() % <span class="number">8</span>).intdiv(<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RuleEngineBaseImpl</span> <span class="keyword">extends</span> <span class="title">com</span>.<span class="title">dianping</span>.<span class="title">zebra</span>.<span class="title">shard</span>.<span class="title">router</span>.<span class="title">rule</span>.<span class="title">engine</span>.<span class="title">RuleEngineBase</span>&#123;</span></span><br><span class="line">  Object execute(Map context) &#123;</span><br><span class="line">    context.get(<span class="string">"id"</span>).intValue() % <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>SQL解析:</strong>利用<code>Druid</code>的<code>SqlParser</code>解析SQL成语法树，能从中直接获取SQL类型、SQL表名、参数名、Hint等…，以此为基础进行路由分库分表<br><strong>SQL路由:</strong> 根据SQL解析的结果以及配置的规则，通过运行规则运算脚本可以获得应该路由到哪个库的哪个表去执行。<br><strong>SQL改写:</strong>结合SQL解析器解析的结果、SQL路由的结果改写SQL语句(重设表名)<br><strong>并行执行:</strong>当路由结果需要到多个库的多张表中执行，则会使用线程池去并行执行结果并合并结果<br><strong>结果合并:</strong> 客户端将多库返回的所有结果加载到内存，进行合并操作</p>
</blockquote>
<h3 id="Filter链-Filter-Chain模式、责任链模式"><a href="#Filter链-Filter-Chain模式、责任链模式" class="headerlink" title="Filter链(Filter-Chain模式、责任链模式)"></a>Filter链(Filter-Chain模式、责任链模式)</h3><p><strong>Filter链</strong>是zebra实现可扩展性的机制。其作用相当于Spring AOP的<code>Interceptor</code>。<br>每个<strong>Filter</strong>可以在SQL执行的各个阶段起作用。比如<code>getConnection</code>、<code>prepareStatement</code>、<code>executeSingleStatement</code>。可以在<strong>Filter</strong>中实现监控连接池状态、SQL执行情况；改写SQL语句；改写SQL表名；SQL流控。</p>
<p><img src="/media/15118055319657.jpg" alt="set up-w600"><br><img src="/media/15118052735409.jpg" alt="set up-w600"></p>
<p>另外，业务方可以完全自行拓展<code>Filter</code>实现SQL执行统计、改写SQL等。（这里的<code>MtraceFilter</code>就是Mtrace的人员开发的。）</p>
<h4 id="怎么拓展？"><a href="#怎么拓展？" class="headerlink" title="怎么拓展？"></a>怎么拓展？</h4><ol>
<li>覆盖<strong>DefaultJdbcFilter</strong>，覆盖关注的SQL执行阶段对应的方法。</li>
<li>在META-INF中添加一个<code>zebra-filter.properties</code>中记录需要加入到<code>Filter链</code>中的自定义<code>Filter</code>:</li>
</ol>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">zebra.filter.mtrace</span>=<span class="string">com.meituan.mtrace.zebra.filter.MtraceFilter</span></span><br></pre></td></tr></table></figure>
<h2 id="zebra-dao"><a href="#zebra-dao" class="headerlink" title="zebra-dao"></a>zebra-dao</h2><p><strong>zebra-dao</strong>职责是<strong>异步化</strong>和<strong>物理分页</strong>。是在ORM框架<strong>MyBatis</strong>上做的一层封装（<a href="https://wiki-in.sankuai.com/pages/viewpage.action?pageId=507134914" target="_blank" rel="noopener">接入指南</a>）。</p>
<p><strong>异步化：</strong><br><code>MyBatis</code>中对每个访问层接口，都会生成一个代理对象，每个代理对象对应的<code>InvocationHandler</code>为<code>MapperProxy</code>。<br>而<code>zebra-dao</code>是在<code>MyBatis.MapperProxy</code>的代理对象上加了又加了一层代理<code>AsyncMapperProxy</code>。在<code>AsyncMapperProxy</code>中实现异步化。</p>
<blockquote>
<p>值得注意的是，这里异步化将请求放到线程池去执行，然后通过future.get()的形式，从IO模式上来说也只是阻塞模式，而不是NIO的方式；<br>另外，这里一个进程会共用一个线程池。</p>
</blockquote>
<p><strong>分页：</strong></p>
<ul>
<li><p>逻辑分页: 先从DB中拿出查询出来的所有的数据，而后再在内存中进行分页；</p>
</li>
<li><p>物理分页: 改写SQL，在SQL中加入分页部分的逻辑<code>limit 10,10</code>。</p>
</li>
<li><p>高级物理分页：不仅返回分页数据，同时也返回总数</p>
</li>
</ul>
<p><code>zebra-dao</code>实现分页的方式是实现MyBatis的<code>Interceptor</code>(<strong>PageInterceptor</strong>)。<code>Interceptor</code>是MyBatis的插件(另一种拓展性方式)，通过它可以在MyBatis的执行过程中插入一些额外的逻辑。这里<code>PageInterceptor</code>主要是作用针对<code>query</code>方法。具体做法是：    </p>
<ul>
<li>改写SQL在尾部添加 limit x,x；</li>
<li>如果是高级物理分页，则会再进行一次<code>select count(*)</code>查询，然后返回。<br><a href="">见源码片段</a></li>
</ul>
<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><h2 id="zebra-api-1"><a href="#zebra-api-1" class="headerlink" title="zebra-api"></a>zebra-api</h2><h3 id="GroupDataSource-1"><a href="#GroupDataSource-1" class="headerlink" title="GroupDataSource"></a>GroupDataSource</h3><p><code>GroupDataSource</code>初始化时，会从配置平台读取所有数据库节点的配置信息。然后依据这些信息来创建两种类型的代理数据源d <strong>FailOverDataSource</strong>和<strong>LoadBalancedDataSource</strong>。其中，<code>FailOverDataSource</code>用来连接和管理主节点故障的拒绝写等。<code>LoadBalancedDataSource</code>则是用来连接所有从节点，并负责从节点读流量的路由。</p>
<h4 id="读写策略"><a href="#读写策略" class="headerlink" title="读写策略"></a>读写策略</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">LoadBalancedDataSource readDataSource;</span><br><span class="line"></span><br><span class="line">FailOverDataSource writeDataSource;</span><br><span class="line"></span><br><span class="line"><span class="function">Connection <span class="title">getRealConnection</span><span class="params">(boolen forceWrite)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//是否进行了强行配置</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.routerType == RouterType.SLAVE_ONLY) &#123;</span><br><span class="line">    	<span class="keyword">return</span> getReadConnection();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.routerType == RouterType.MASTER_ONLY) &#123;</span><br><span class="line">    	<span class="keyword">return</span> getWriteConnection();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//主制度</span></span><br><span class="line">    <span class="keyword">if</span> (forceWrite) &#123;</span><br><span class="line">    	<span class="keyword">return</span> getWriteConnection();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!autoCommit ||</span><br><span class="line">    <span class="comment">// SQL中带有HINT</span></span><br><span class="line">    StringUtils.trimToEmpty(sql).contains(<span class="string">"/*+zebra:w*/"</span>)</span><br><span class="line">          || StringUtils.trimToEmpty(sql).contains(<span class="string">"/*master*/"</span>)) &#123;</span><br><span class="line">    	<span class="keyword">return</span> getWriteConnection();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readWriteStrategy != <span class="keyword">null</span> &amp;&amp; readWriteStrategy.shouldReadFromMaster()) &#123;</span><br><span class="line">    <span class="comment">//即设置了ZebraForceMasterHelper.forceMasterInLocalContext()</span></span><br><span class="line">    	<span class="keyword">return</span> getWriteConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过Druid parser解析出SQL的类型</span></span><br><span class="line">    SqlType sqlType = SqlUtils.getSqlType(sql);</span><br><span class="line">    <span class="keyword">if</span> (sqlType.isRead()) &#123;</span><br><span class="line">    	<span class="keyword">return</span> getReadConnection();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> getWriteConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Connection <span class="title">getReadConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readDataSource.getConnection();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Connection getWriteConnection &#123;</span><br><span class="line">    <span class="keyword">return</span> writeDataSource.getConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="路由策略-针对读流量-："><a href="#路由策略-针对读流量-：" class="headerlink" title="路由策略(针对读流量)："></a>路由策略(针对读流量)：</h4><p><strong>LoadBalanceDataSource</strong>中的<code>router</code>负责物理库和表的路由。</p>
<p>初始化时，会根据用户设置的配置信息(<code>idcAware</code>、..)，创建路由</p>
<ul>
<li>先将所有的数据库节点信息按是否与本地机器在同一个区域，分为两个集合 <code>localRegionRouter</code>、<code>remoteRegionRouter</code>；</li>
<li>跟据配置的路由策略（<code>IdcAwareRouter</code>、<code>CenterWeightRouter</code>、<code>RegionAwareRouter</code>）选择不同的实际路由器。</li>
<li>(1) 如果设置的只是区域感知的话，则直接按权重路由<code>WeightDataSourceRouter</code></li>
<li>(2) 如果设置的是<code>CenterAware</code>，则将选择的是<code>CenterAwareRouter</code></li>
<li>(3) 如果设置的是<code>IdcAware</code>，也是<code>CenterAwareRouter</code>，只是<code>CenterAwareRouter</code>中还有一个<code>IdcAwareRouter</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RegionAwareRouter</span><span class="params">(Map&lt;String, DataSourceConfig&gt; dataSourceConfigs, String configManagerType,</span></span></span><br><span class="line"><span class="function"><span class="params">			String routerStrategy)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.regionManager = ZebraRegionManagerLoader.getRegionManager(configManagerType);</span><br><span class="line"></span><br><span class="line">	Map&lt;String, DataSourceConfig&gt; localRegionDataSourceConfigs = <span class="keyword">new</span> HashMap&lt;String, DataSourceConfig&gt;();</span><br><span class="line">	Map&lt;String, DataSourceConfig&gt; remoteRegionDataSourceConfigs = <span class="keyword">new</span> HashMap&lt;String, DataSourceConfig&gt;();</span><br><span class="line">  <span class="comment">//将所有的数据库节点分为同区域节点、和不同区域节点</span></span><br><span class="line">	<span class="keyword">for</span> (Map.Entry&lt;String, DataSourceConfig&gt; entry : dataSourceConfigs.entrySet()) &#123;</span><br><span class="line">		String dsId = entry.getKey();</span><br><span class="line">		DataSourceConfig config = entry.getValue();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Matcher matcher = JDBC_URL_PATTERN.matcher(config.getJdbcUrl());</span><br><span class="line">			<span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">				String url = matcher.group(<span class="number">1</span>);</span><br><span class="line">				String[] urlAndPort = url.split(<span class="string">":"</span>);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (urlAndPort != <span class="keyword">null</span> &amp;&amp; urlAndPort.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (<span class="keyword">this</span>.regionManager.isInLocalRegion(urlAndPort[<span class="number">0</span>])) &#123;</span><br><span class="line">						localRegionDataSourceConfigs.put(dsId, config);</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						remoteRegionDataSourceConfigs.put(dsId, config);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				remoteRegionDataSourceConfigs.put(dsId, config);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">			logger.warn(String.format(</span><br><span class="line">					<span class="string">"Cannot recognize the idc for jdbcUrl(%s), so put this datasource in the other region by default."</span>,</span><br><span class="line">					config.getJdbcUrl()));</span><br><span class="line">			remoteRegionDataSourceConfigs.put(dsId, config);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//如果路由策略配置的只是同区域优先，则同区域内部走权重路由</span></span><br><span class="line">	<span class="keyword">if</span> (Constants.ROUTER_STRATEGY_REGION_AWARE_ROUTER.equals(routerStrategy)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (localRegionDataSourceConfigs.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.localRegionRouter = <span class="keyword">new</span> WeightDataSourceRouter(localRegionDataSourceConfigs);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (remoteRegionDataSourceConfigs.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.remoteRegionRouter = <span class="keyword">new</span> WeightDataSourceRouter(remoteRegionDataSourceConfigs);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 如果设置的是中心感知或机房感知</span></span><br><span class="line">		<span class="keyword">boolean</span> idcAware = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (Constants.ROUTER_STRATEGY_IDC_AWARE_ROUTER.equals(routerStrategy)) &#123;</span><br><span class="line">			idcAware = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (localRegionDataSourceConfigs.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.localRegionRouter = <span class="keyword">new</span> CenterAwareRouter(localRegionDataSourceConfigs, configManagerType,</span><br><span class="line">					idcAware);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (remoteRegionDataSourceConfigs.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.remoteRegionRouter = <span class="keyword">new</span> CenterAwareRouter(remoteRegionDataSourceConfigs, configManagerType,</span><br><span class="line">					idcAware);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CenterAwareRouter</span> <span class="keyword">implements</span> <span class="title">DataSourceRouter</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> DataSourceRouter localCenterRouter;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">CenterAwareRouter</span><span class="params">(Map&lt;String, DataSourceConfig&gt; dataSourceConfigs, String configManagerType,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">boolean</span> idcAware)</span> </span>&#123;</span><br><span class="line">			...</span><br><span class="line">    	<span class="keyword">if</span> (idcAware) &#123;</span><br><span class="line">    		localCenterSourceConfigs.putAll(localIdcSourceConfigs);</span><br><span class="line">    		<span class="keyword">if</span> (localCenterSourceConfigs.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    		<span class="comment">//IdcAwareRouter的节点必定在同中心</span></span><br><span class="line">    			<span class="keyword">this</span>.localCenterRouter = <span class="keyword">new</span> IdcAwareRouter(localCenterSourceConfigs, configManagerType);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouterTarget <span class="title">select</span><span class="params">(RouterContext routerContext)</span> </span>&#123;</span><br><span class="line">    	RouterTarget routerTarget = <span class="keyword">null</span>;</span><br><span class="line">    	<span class="comment">//存在同机房路由，则有同机房路由</span></span><br><span class="line">    	<span class="keyword">if</span> (localCenterRouter != <span class="keyword">null</span>) &#123;</span><br><span class="line">    		routerTarget = localCenterRouter.select(routerContext);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span> (routerTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">    		<span class="keyword">for</span> (WeightDataSourceRouter weightDataSourceRouter : priorityCenterIdcAwareRouters) &#123;</span><br><span class="line">    			routerTarget = weightDataSourceRouter.select(routerContext);</span><br><span class="line">    			<span class="keyword">if</span> (routerTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">    				<span class="keyword">return</span> routerTarget;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> routerTarget;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ShardDataSource-1"><a href="#ShardDataSource-1" class="headerlink" title="ShardDataSource"></a>ShardDataSource</h3><h4 id="分库分表原理"><a href="#分库分表原理" class="headerlink" title="分库分表原理"></a>分库分表原理</h4><p><code>ShardDataSource</code>中的<strong>DefaultShardRouter</strong>负责分库分表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//路由规则：根据分库分表规则和运行时参数，计算出应该到的库名和表名</span></span><br><span class="line">RouterRule routerRule;</span><br><span class="line"><span class="comment">//负责RouterRule计算的结果改写SQL，形成带有物理表名的SQL</span></span><br><span class="line">SQLRewrite sqlRewrite = <span class="keyword">new</span> DefaultSQLRewrite();</span><br></pre></td></tr></table></figure>
<p>执行路由的逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RouterResult <span class="title">router</span><span class="params">(<span class="keyword">final</span> String sql, List&lt;Object&gt; params)</span> <span class="keyword">throws</span> ShardRouterException, ShardParseException </span>&#123;</span><br><span class="line">	RouterResult routerResult = <span class="keyword">new</span> RouterResult();</span><br><span class="line">	<span class="comment">//解析SQL得出表名等信息</span></span><br><span class="line">	SQLParsedResult parsedResult = SQLParser.parseWithCache(sql);</span><br><span class="line">    <span class="comment">//根据SQL解析结果找出对应表逻辑名的分片规则。</span></span><br><span class="line">	List&lt;TableShardRule&gt; findShardRules = findShardRules(parsedResult.getRouterContext(), params);</span><br><span class="line">	<span class="keyword">if</span> (findShardRules.size() == <span class="number">1</span>) &#123;</span><br><span class="line">		TableShardRule tableShardRule = findShardRules.get(<span class="number">0</span>);</span><br><span class="line">		<span class="comment">//执行逻辑表的分片规则获得物理库和表名</span></span><br><span class="line">		ShardEvalResult shardResult = tableShardRule.eval(<span class="keyword">new</span> ShardEvalContext(parsedResult, params));</span><br><span class="line">		routerResult.setMergeContext(<span class="keyword">new</span> MergeContext(parsedResult.getMergeContext()));</span><br><span class="line">		routerResult.setSqls(buildSqls(shardResult.getDbAndTables(), parsedResult, tableShardRule.getTableName()));</span><br><span class="line">		routerResult.setParams(buildParams(params, routerResult));</span><br><span class="line">		<span class="keyword">return</span> routerResult;</span><br><span class="line">	&#125;...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ShardEvalResult <span class="title">eval</span><span class="params">(ShardEvalContext matchContext)</span> </span>&#123;</span><br><span class="line">	ShardEvalResult result = <span class="keyword">new</span> ShardEvalResult(matchContext.getTableName());</span><br><span class="line">	<span class="keyword">for</span> (ColumnValue evalContext : matchContext.getColumnValues()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!evalContext.isUsed()) &#123;</span><br><span class="line">			evalContext.setUsed(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//通过库规则，获得在库的索引号</span></span><br><span class="line">			Object dbObj = dbRuleEngine.eval(evalContext.getValue());</span><br><span class="line">			Number dbPos = (Number)dbObj;</span><br><span class="line">			TableSets tableSet = tablesMappingManager.getTableSetsByPos(dbPos.intValue());</span><br><span class="line">			<span class="comment">//通过表规则，获得表的索引号</span></span><br><span class="line">			Number tablePos = (Number) tableRuleEngine.eval(evalContext.getValue());</span><br><span class="line">			String table = tableSet.getTableSets().get(tablePos.intValue());</span><br><span class="line">			result.addDbAndTable(tableSet.getDbIndex(), table);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="zebra-dao-1"><a href="#zebra-dao-1" class="headerlink" title="zebra-dao"></a>zebra-dao</h2><h3 id="异步化"><a href="#异步化" class="headerlink" title="异步化"></a>异步化</h3><p><strong>MyBatis</strong>中每个DAO都对应一个<code>MapperProxy</code>，zebra-dao中则是<code>AsyncMapperProxy</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncMapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否是带有回调的方法</span></span><br><span class="line">        <span class="keyword">if</span> (isCallbackMethod(method, args)) &#123;</span><br><span class="line">        	Method _method = getAnnotationMethod(method);</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        	Object[] newArgs = <span class="keyword">new</span> Object[args.length - <span class="number">1</span>];</span><br><span class="line">        	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        	AsyncDaoCallback callback = <span class="keyword">null</span>;</span><br><span class="line">        	<span class="keyword">for</span> (Object arg : args) &#123;</span><br><span class="line">        		<span class="keyword">if</span> (arg != <span class="keyword">null</span>) &#123;</span><br><span class="line">        			<span class="keyword">if</span> (!AsyncDaoCallback<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">arg</span>.<span class="title">getClass</span>())) </span>&#123;</span><br><span class="line">        				newArgs[i++] = arg;</span><br><span class="line">        			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        				callback = (AsyncDaoCallback) arg;</span><br><span class="line">        			&#125;</span><br><span class="line">        		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        			newArgs[i++] = arg;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">            <span class="comment">//异步执行，并设置回调</span></span><br><span class="line">        	AsyncMapperExecutor.executeRunnable(mapper, _method, newArgs, callback);</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Future<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">method</span>.<span class="title">getReturnType</span>())) </span>&#123;</span><br><span class="line">        <span class="comment">//返回值是Future，则也异步发起请求</span></span><br><span class="line">        	Method _method = getAnnotationMethod(method);       </span><br><span class="line">        	<span class="keyword">if</span> (_method != <span class="keyword">null</span>) &#123;</span><br><span class="line">        		<span class="keyword">return</span> AsyncMapperExecutor.submitCallback(mapper, _method, args);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//直接调用</span></span><br><span class="line">        	<span class="keyword">return</span> method.invoke(mapper, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分页-PageInterceptor"><a href="#分页-PageInterceptor" class="headerlink" title="分页 - PageInterceptor"></a>分页 - PageInterceptor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">Object[] args = invocation.getArgs();</span><br><span class="line">		Object rowBound = args[<span class="number">2</span>];</span><br><span class="line">MappedStatement ms = (MappedStatement) args[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (rowBound != <span class="keyword">null</span>) &#123;</span><br><span class="line">	RowBounds rb = (RowBounds) rowBound;</span><br><span class="line">	<span class="comment">// 无分页信息</span></span><br><span class="line">	<span class="keyword">if</span> (rb.getOffset() == RowBounds.NO_ROW_OFFSET &amp;&amp; rb.getLimit() == RowBounds.NO_ROW_LIMIT) &#123;</span><br><span class="line">		<span class="keyword">return</span> invocation.proceed();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		BoundSql boundSql = ms.getBoundSql(args[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">if</span> (rowBound <span class="keyword">instanceof</span> PageModel) &#123;</span><br><span class="line">			<span class="comment">// 高级物理分页</span></span><br><span class="line">			PageModel pageModel = (PageModel) rowBound;</span><br><span class="line">			<span class="comment">//首先获得次数</span></span><br><span class="line">			Object count = queryCount(invocation, args, ms, boundSql);</span><br><span class="line">			<span class="comment">//获取结果</span></span><br><span class="line">			Object records = queryLimit(invocation, args, ms, boundSql, pageModel);</span><br><span class="line">			pageModel.setRecordCount((Integer) ((List&lt;?&gt;) count).get(<span class="number">0</span>));</span><br><span class="line">			pageModel.setRecords((List&lt;?&gt;) records);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 物理分页</span></span><br><span class="line">			<span class="keyword">return</span> queryLimit(invocation, args, ms, boundSql, rb);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// without pagination</span></span><br><span class="line">	<span class="keyword">return</span> invocation.proceed();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">queryCount</span><span class="params">(Invocation invocation, Object[] args, MappedStatement ms, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过原始SQL生成select count(*)语句，通过SQL Parser解析SQL，再拼接SQL</span></span><br><span class="line">    String countSql = dialect.getCountSql(boundSql.getSql());</span><br><span class="line">	<span class="comment">//生成新的SQL</span></span><br><span class="line">	BoundSql newBoundSql = <span class="keyword">new</span> BoundSql(ms.getConfiguration(), countSql, boundSql.getParameterMappings(),</span><br><span class="line">			boundSql.getParameterObject());</span><br><span class="line">	<span class="comment">//生成新的Statement 去执行select count(*)</span></span><br><span class="line">	countRowStatement = buildMappedStatement(ms, <span class="keyword">new</span> SqlSqlSourceWrapper(newBoundSql), ms.getId() + <span class="string">"_COUNT"</span>,</span><br><span class="line">			resultMaps);</span><br><span class="line"></span><br><span class="line">	args[<span class="number">0</span>] = countRowStatement;</span><br><span class="line">	args[<span class="number">2</span>] = <span class="keyword">new</span> RowBounds();</span><br><span class="line">	args[<span class="number">3</span>] = <span class="keyword">null</span>;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">queryLimit</span><span class="params">(Invocation invocation, Object[] args, MappedStatement ms, BoundSql boundSql, RowBounds rb)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//生成带有limit的SQL</span></span><br><span class="line">	String limitSql = dialect.getLimitSql(boundSql.getSql(), rb.getOffset(), rb.getLimit());</span><br><span class="line">	BoundSql newBoundSql = <span class="keyword">new</span> BoundSql(ms.getConfiguration(), limitSql, boundSql.getParameterMappings(),</span><br><span class="line">			boundSql.getParameterObject());</span><br><span class="line">	<span class="comment">//构造新的Statement去执行分页语句</span></span><br><span class="line">	args[<span class="number">0</span>] = buildMappedStatement(ms, <span class="keyword">new</span> SqlSqlSourceWrapper(newBoundSql), ms.getId() + <span class="string">"_LIMIT"</span>,</span><br><span class="line">			ms.getResultMaps());</span><br><span class="line">	args[<span class="number">2</span>] = <span class="keyword">new</span> RowBounds();</span><br><span class="line">	args[<span class="number">3</span>] = <span class="keyword">null</span>;</span><br><span class="line">  	<span class="keyword">return</span> invocation.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SQL解析与改写"><a href="#SQL解析与改写" class="headerlink" title="SQL解析与改写"></a>SQL解析与改写</h2><p>Zebra在之前的版本中使用Antlr解析SQL，后来的版本替换成了Druid的 <strong>Sql Parser</strong>。<strong>Druid</strong>是个非常强大的工具，它支持达9种数据库类型SQL(db2|h2|mysql|hive|oracle…)。<br>这里我们以<strong>MySQL</strong>为例来介绍其SQL解析过程。<br><img src="/media/15119598460937.jpg" alt=""></p>
<p>SQL的解析过程，分为<strong>词法分析</strong>和<strong>语法分析</strong>：</p>
<ul>
<li><strong>词法分析</strong>用来识别词汇，如关键字等。<code>Lexer</code>就是用于词法分析的词法分析器。每个词法器都有自己的词汇库，<code>KeyWords</code>就是词汇库，且是所有数据库共用的词汇库。<code>MySQLLexer</code>是<code>Lexer</code>的子类。是用来专门解析<code>MySQL</code>的SQL语句。它的词汇库也在<code>KeyWords</code>加上了<code>MySQL</code>特有的关键字<code>LIMIT</code>、<code>IDENTIFIED</code>等；</li>
<li><strong>语法分析</strong>是在词法分析的基础上进行语法分析。生成一颗AST(<code>abstract syntax tree</code><strong>抽象语法树</strong>)。且其过程中也会判断用户的输入是否符合语法逻辑；</li>
</ul>
<p>先来看一个词法分析的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"select * from order where cinema_id = 11 order by id, user_id"</span>;</span><br><span class="line">Lexer lexer = <span class="keyword">new</span> Lexer(sql);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  <span class="comment">//触发下一个词识别，识别过程即在其中。(各种if|switch，有限状态机)</span></span><br><span class="line">  lexer.nextToken();</span><br><span class="line">  <span class="comment">//获取识别的词</span></span><br><span class="line">  Token tok = lexer.token();</span><br><span class="line">  <span class="comment">//标识符</span></span><br><span class="line">  <span class="keyword">if</span> (tok == Token.IDENTIFIER) &#123;</span><br><span class="line">      System.out.println(tok.name() + <span class="string">"\t\t"</span> + lexer.stringVal());</span><br><span class="line">  <span class="comment">//数字</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tok == Token.LITERAL_INT) &#123;</span><br><span class="line">      System.out.println(tok.name() + <span class="string">"\t\t"</span> + lexer.numberString());</span><br><span class="line">  <span class="comment">//其他类型</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(tok.name() + <span class="string">"\t\t\t"</span> + tok.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//条件判断，以及其在SQL中的位置</span></span><br><span class="line">  <span class="keyword">if</span> (tok == Token.WHERE) &#123;</span><br><span class="line">      System.out.println(<span class="string">"where pos : "</span> + lexer.pos());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//结束标记</span></span><br><span class="line">  <span class="keyword">if</span> (tok == Token.EOF) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其输出结果是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT			SELECT</span><br><span class="line">STAR			*</span><br><span class="line">FROM			FROM</span><br><span class="line">ORDER			ORDER</span><br><span class="line">WHERE			WHERE</span><br><span class="line">where pos : <span class="number">25</span></span><br><span class="line">IDENTIFIER		cinema_id</span><br><span class="line">EQ			=</span><br><span class="line">LITERAL_INT		<span class="number">11</span></span><br><span class="line">ORDER			ORDER</span><br><span class="line">BY			BY</span><br><span class="line">IDENTIFIER		id</span><br><span class="line">COMMA			,</span><br><span class="line">IDENTIFIER		user_id</span><br><span class="line">EOF			<span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p><strong>语法分析器</strong>在进行语法分析时，会根据词法分析器分析出的TOKEN、值来创建不同类型的节点，加到AST树中。<br>例如：</p>
<blockquote>
<p><code>SELECT</code> -&gt; <code>SQLSelect</code><br><code>Order by</code> -&gt; <code>SQLOrderBy</code><br><code>*</code> -&gt; <code>SQLSelectItem</code>(每个结果集字段一个SQLSelectItem)<br><code>FROM</code> -&gt; <code>SQLTableSource</code>，SQLExprTableSource或者<code>SQLSelect</code>(嵌套查询)</p>
</blockquote>
<p>以下面的例子来说明语法分析生成的结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>, movie_id <span class="keyword">from</span> <span class="keyword">order</span> <span class="keyword">where</span> cinema_id = <span class="number">11</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span>, user_id</span><br></pre></td></tr></table></figure>

<p>生成的语法树如下：<br><img src="/media/15119747197151.jpg" alt=""></p>
<p>对AST树信息的访问，<code>Druid</code>定义一套接口<code>SQLASTVisitor</code>。业务方可以实现接口加入特定信息收集逻辑。调用<code>SQLStatement.accept(visitor)</code>，<code>visitor</code>就会以类先序的顺序访问树上的所有节点。<br>下面给出一个自定义查找SQL中出现了哪些表名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableNameASTVisitor</span> <span class="keyword">implements</span> <span class="title">MySqlASTVisitor</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; tableNames = Lists.newArrayList();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">visit</span><span class="params">(SQLExprTableSource x)</span> </span>&#123;</span><br><span class="line">        SQLName name = x.getName();</span><br><span class="line">        <span class="keyword">if</span> (name!= <span class="keyword">null</span>) &#123;</span><br><span class="line">            tableNames.add(name.getSimpleName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">visit</span><span class="params">(SQLSelect x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">visit</span><span class="params">(SQLSelectStatement astNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getTableNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tableNames;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">String sql = <span class="string">"select id, name, movie_id from order where cinema_id = 11 order by id, user_id"</span>;</span><br><span class="line">SQLStatementParser parser = <span class="keyword">new</span> MySqlStatementParser(sql);</span><br><span class="line">SQLStatement statement = parser.parseStatement();</span><br><span class="line">TableNameASTVisitor visitor = <span class="keyword">new</span> TableNameASTVisitor();</span><br><span class="line">statement.accept(visitor);</span><br><span class="line">System.out.println(visitor.getTableNames());</span><br><span class="line"><span class="comment">//输出结果为 [order]</span></span><br></pre></td></tr></table></figure>
<p><strong>ShardRouter</strong>实现SQL改写的方式就是实现了一个<strong>Visitor</strong>-<strong>SimpleRewriteTableOutputVisitor</strong>，在其内部，将逻辑表名改写为路由后的物理表名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleRewriteTableOutputVisitor</span> <span class="keyword">extends</span> <span class="title">MySqlOutputVisitor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; tableMapping;</span><br><span class="line">    <span class="comment">//访问保存表信息的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">visit</span><span class="params">(SQLExprTableSource x)</span> </span>&#123;</span><br><span class="line">		SQLName name = (SQLName) x.getExpr();</span><br><span class="line">		String simpleName = name.getSimpleName();</span><br><span class="line">		<span class="keyword">boolean</span> hasQuote = simpleName.charAt(<span class="number">0</span>) == <span class="string">'`'</span>;</span><br><span class="line">		<span class="comment">//逻辑表名</span></span><br><span class="line">		String tableName = hasQuote ? parseTableName(simpleName) : simpleName;</span><br><span class="line">		<span class="comment">//物理表名</span></span><br><span class="line">		String finalTable = tableMapping.get(tableName);</span><br><span class="line">		...</span><br><span class="line">		print0(<span class="string">"`"</span> + finalTable + <span class="string">"`"</span>);</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2018/04/26/rpc/dubbo/6.dubbo-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.png">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/26/rpc/dubbo/6.dubbo-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" class="post-title-link" itemprop="url">Dubbo 负载均衡</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-26 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-26T00:00:00+08:00">2018-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-13 19:07:15" itemprop="dateModified" datetime="2020-02-13T19:07:15+08:00">2020-02-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dubbo/" itemprop="url" rel="index">
                    <span itemprop="name">dubbo</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><h2 id="一致性HASH算法"><a href="#一致性HASH算法" class="headerlink" title="一致性HASH算法"></a>一致性HASH算法</h2><p>适合场景：</p>
<ul>
<li><strong>均衡性(Balance)</strong>：<br>  平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</li>
<li><strong>单调性(Monotonicity)</strong>：当缓冲区大小变化时一致性哈希(Consistent hashing)尽量保护已分配的内容不会被重新映射到新缓冲区。（线性Hash就不能保证）</li>
<li><strong>分散性(Spread)</strong>：避免相同内容被存储到不同缓冲中去，降低了系统存储的效率</li>
<li><strong>负载(Load)</strong>：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容</li>
</ul>
<blockquote>
<p>CARP: Common Access Redundancy Protocol共用地址冗余协议Common Access Redundancy Protocol，或简称 CARP 能够使多台主机共享同一 IP 地址。在某些配置中，这样做可以提高可用性，或实现负载均衡。这些主机也可以同时使用其他的不同的 IP 地址。</p>
</blockquote>
<p>##</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2018/04/25/rpc/dubbo/5.dubbo-%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.png">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/25/rpc/dubbo/5.dubbo-%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/" class="post-title-link" itemprop="url">Dubbo 服务调用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-25 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-25T00:00:00+08:00">2018-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-13 20:10:39" itemprop="dateModified" datetime="2020-02-13T20:10:39+08:00">2020-02-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dubbo/" itemprop="url" rel="index">
                    <span itemprop="name">dubbo</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="服务调用过程解析"><a href="#服务调用过程解析" class="headerlink" title="服务调用过程解析"></a>服务调用过程解析</h1><p>服务过程解析部分我们分两部分来讲，客户端发送请求、接收结果和服务端接受请求、响应结果过程。</p>
<h2 id="客户端发送请求、接收结果"><a href="#客户端发送请求、接收结果" class="headerlink" title="客户端发送请求、接收结果"></a>客户端发送请求、接收结果</h2><p>首先，调用客户端方法时，首先被<code>InvokerInvocationHandler</code>拦截，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">   String methodName = method.getName();</span><br><span class="line">   Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">   <span class="keyword">if</span> (method.getDeclaringClass() == Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> method.invoke(invoker, args);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="string">"toString"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> invoker.toString();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="string">"hashCode"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> invoker.hashCode();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="string">"equals"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> invoker.equals(args[<span class="number">0</span>]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//在服务引用过程分析中，提到这里的invoker。当不是没有`injvm`、`url`配置时，invoker是 XxxClusterInvoker</span></span><br><span class="line">   <span class="keyword">return</span> invoker.invoke(<span class="keyword">new</span> RpcInvocation(method, args)).recreate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们指定<code>XxxClusterInvoker</code>为<code>FailoverClusterInvoker</code>来分析整个流程。<br><code>FailoverClusterInvoker</code>的结构如下：<br><img src="/media/15202975233343.jpg" alt=""><br>所以，接下来会走进<code>AbstractClusterInvoker</code>的invoker方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">   LoadBalance loadbalance = <span class="keyword">null</span>;</span><br><span class="line">   <span class="comment">//根据参数列出所有可以使用的Invoker</span></span><br><span class="line">   List&lt;Invoker&lt;T&gt;&gt; invokers = list(invocation);</span><br><span class="line">   <span class="keyword">if</span> (invokers != <span class="keyword">null</span> &amp;&amp; !invokers.isEmpty()) &#123;</span><br><span class="line">       <span class="comment">// 根据Url，获取负载均衡器，这里先假定为`RandomLoadBalance`</span></span><br><span class="line">       loadbalance = ExtensionLoader.getExtensionLoader(LoadBalance<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">invokers</span>.<span class="title">get</span>(0).<span class="title">getUrl</span>()</span></span><br><span class="line"><span class="class">               .<span class="title">getMethodParameter</span>(<span class="title">invocation</span>.<span class="title">getMethodName</span>(), <span class="title">Constants</span>.<span class="title">LOADBALANCE_KEY</span>, <span class="title">Constants</span>.<span class="title">DEFAULT_LOADBALANCE</span>))</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class="line">   <span class="keyword">return</span> doInvoke(invocation, invokers, loadbalance);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">   <span class="comment">// 调用directory的list方法，这里的Directory为`RegistryDirectory`</span></span><br><span class="line">   List&lt;Invoker&lt;T&gt;&gt; invokers = directory.list(invocation);</span><br><span class="line">   <span class="keyword">return</span> invokers;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">   <span class="comment">// doList方法直接从Directory保存的InvokerMap中取出对应Service的Invokers</span></span><br><span class="line">   List&lt;Invoker&lt;T&gt;&gt; invokers = doList(invocation);</span><br><span class="line">   List&lt;Router&gt; localRouters = <span class="keyword">this</span>.routers;</span><br><span class="line">   <span class="comment">// 经过设置的Routers进行过滤出可以使用的Invokers</span></span><br><span class="line">   <span class="keyword">if</span> (localRouters != <span class="keyword">null</span> &amp;&amp; !localRouters.isEmpty()) &#123;</span><br><span class="line">       <span class="keyword">for</span> (Router router : localRouters) &#123;</span><br><span class="line">           <span class="keyword">if</span> (router.getUrl() == <span class="keyword">null</span> || router.getUrl().getParameter(Constants.RUNTIME_KEY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">               invokers = router.route(invokers, getConsumerUrl(), invocation);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> invokers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取完所有可用的<code>Invoker</code>后，继续看<code>FailoverClusterInvoker</code>的处理逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">   List&lt;Invoker&lt;T&gt;&gt; copyinvokers = invokers;</span><br><span class="line">   <span class="comment">//失败重试次数</span></span><br><span class="line">   <span class="keyword">int</span> len = getUrl().getMethodParameter(invocation.getMethodName(), Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">       len = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   List&lt;Invoker&lt;T&gt;&gt; invoked = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(copyinvokers.size()); <span class="comment">// invoked invokers.</span></span><br><span class="line">    <span class="comment">//len-1次重试</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           checkWhetherDestroyed();</span><br><span class="line">           copyinvokers = list(invocation);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">       Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyinvokers, invoked);</span><br><span class="line">       invoked.add(invoker);</span><br><span class="line">       RpcContext.getContext().setInvokers((List) invoked);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Result result = invoker.invoke(invocation);</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125;...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> Invoker&lt;T&gt; <span class="title">select</span><span class="params">(LoadBalance loadbalance, Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (invokers == <span class="keyword">null</span> || invokers.isEmpty())</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   String methodName = invocation == <span class="keyword">null</span> ? <span class="string">""</span> : invocation.getMethodName();</span><br><span class="line">   <span class="keyword">boolean</span> sticky = invokers.get(<span class="number">0</span>).getUrl().getMethodParameter(methodName, Constants.CLUSTER_STICKY_KEY, Constants.DEFAULT_CLUSTER_STICKY);</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//如果带有粘性设置，则直接返回之前保存的`stickyInvoker`</span></span><br><span class="line">       <span class="keyword">if</span> (stickyInvoker != <span class="keyword">null</span> &amp;&amp; !invokers.contains(stickyInvoker)) &#123;</span><br><span class="line">           stickyInvoker = <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (sticky &amp;&amp; stickyInvoker != <span class="keyword">null</span> &amp;&amp; (selected == <span class="keyword">null</span> || !selected.contains(stickyInvoker))) &#123;</span><br><span class="line">           <span class="keyword">if</span> (availablecheck &amp;&amp; stickyInvoker.isAvailable()) &#123;</span><br><span class="line">               <span class="keyword">return</span> stickyInvoker;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 负载均衡器根据策略选出一个Invoker，这里的Invoker是DubboInvoker</span></span><br><span class="line">   Invoker&lt;T&gt; invoker = doSelect(loadbalance, invocation, invokers, selected);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (sticky) &#123;</span><br><span class="line">       stickyInvoker = invoker;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看<code>DubboInvoker</code>的处理逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">   RpcInvocation inv = (RpcInvocation) invocation;</span><br><span class="line">   <span class="keyword">final</span> String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">   inv.setAttachment(Constants.PATH_KEY, getUrl().getPath());</span><br><span class="line">   inv.setAttachment(Constants.VERSION_KEY, version);</span><br><span class="line"></span><br><span class="line">   ExchangeClient currentClient;</span><br><span class="line">   <span class="comment">// 当有多个client（对同一个服务提供者建立多个链接）时，则按轮询的方式选择一个Client发起调用。</span></span><br><span class="line">   <span class="keyword">if</span> (clients.length == <span class="number">1</span>) &#123;</span><br><span class="line">       currentClient = clients[<span class="number">0</span>];</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       currentClient = clients[index.getAndIncrement() % clients.length];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">boolean</span> isAsync = RpcUtils.isAsync(getUrl(), invocation);</span><br><span class="line">   <span class="keyword">boolean</span> isOneway = RpcUtils.isOneway(getUrl(), invocation);</span><br><span class="line">   <span class="keyword">int</span> timeout = getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line">   <span class="keyword">if</span> (isOneway) &#123;</span><br><span class="line">       <span class="comment">//单向调用，调用完即返回</span></span><br><span class="line">       <span class="keyword">boolean</span> isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, <span class="keyword">false</span>);</span><br><span class="line">       currentClient.send(inv, isSent);</span><br><span class="line">       RpcContext.getContext().setFuture(<span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> RpcResult();</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isAsync) &#123;</span><br><span class="line">       <span class="comment">//异步调用</span></span><br><span class="line">       ResponseFuture future = currentClient.request(inv, timeout);</span><br><span class="line">       RpcContext.getContext().setFuture(<span class="keyword">new</span> FutureAdapter&lt;Object&gt;(future));</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> RpcResult();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//同步调用</span></span><br><span class="line">       RpcContext.getContext().setFuture(<span class="keyword">null</span>);</span><br><span class="line">       <span class="comment">//这里最终的Client实现为`HeaderExchangeClient`</span></span><br><span class="line">       <span class="keyword">return</span> (Result) currentClient.request(inv, timeout).get();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而后，<code>HeaderExchangeClient</code>会调用<code>HeaderExchangeChannel</code>的<code>request</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>.getLocalAddress(), <span class="keyword">null</span>, <span class="string">"Failed to send request "</span> + request + <span class="string">", cause: The channel "</span> + <span class="keyword">this</span> + <span class="string">" is closed!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 创建一个Request，其带有Id属性，这个Id属性就是用来唯一标识请求</span></span><br><span class="line">   Request req = <span class="keyword">new</span> Request();</span><br><span class="line">   req.setVersion(<span class="string">"2.0.0"</span>);</span><br><span class="line">   req.setTwoWay(<span class="keyword">true</span>);</span><br><span class="line">   req.setData(request);</span><br><span class="line">   <span class="comment">//创建DefaultFuture实例时，会将其放在一个全局的Map中，用于请求返回时，设置结果</span></span><br><span class="line">   DefaultFuture future = <span class="keyword">new</span> DefaultFuture(channel, req, timeout);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//这里的channel即是NettyClient</span></span><br><span class="line">       channel.send(req);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">       future.cancel();</span><br><span class="line">       <span class="keyword">throw</span> e;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，值得一提的是<code>DefaultFuture</code>是客户端发送请求到获取结果的桥梁。<br><code>channel.send</code>下面即为<code>Netty</code>的处理逻辑：<br>这里会先经过<code>EncoderHandler</code>（<strong>NettyCodecAdapter.InternalEncoder</strong>）进行编码处理，最后由<code>NettyHandler</code>发送请求。<br>服务端结果响应后，会由<code>DecodeHandler</code>（<strong>NettyCodecAdapter.InternalDncoder</strong>）进行解码后，交由<code>NettyHanlder</code>处理。<br><img src="/media/15203256028069.jpg" alt=""><br><img src="/media/15203256208940.jpg" alt=""></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2018/04/24/rpc/dubbo/4.dubbo-%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.png">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/24/rpc/dubbo/4.dubbo-%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8/" class="post-title-link" itemprop="url">Dubbo 服务引用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-24 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-24T00:00:00+08:00">2018-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-13 20:10:19" itemprop="dateModified" datetime="2020-02-13T20:10:19+08:00">2020-02-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dubbo/" itemprop="url" rel="index">
                    <span itemprop="name">dubbo</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="服务引用过程解析"><a href="#服务引用过程解析" class="headerlink" title="服务引用过程解析"></a>服务引用过程解析</h1><p>调用服务时，在XML中配置<code>&lt;dubbo:reference&gt;</code>和注册中心即可像调用一个内存方法一样调用远端服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:registry address=<span class="string">"multicast://224.5.6.7:1234"</span>/&gt;</span><br><span class="line">&lt;dubbo:reference id=<span class="string">"demoService"</span> check=<span class="string">"false"</span> <span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.alibaba.dubbo.demo.DemoService"</span> loadbalance=<span class="string">"leastactive"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;dubbo:reference&gt;</code>同样是由<code>DubboBeanDefinitionParser</code>进行解析，其被解析后成实例<code>ReferenceBean</code>。因此，其是服务引用过程的关键。<br><img src="/media/15202605904632.jpg" alt=""><br>可以看出，它是一个工厂Bean(实现<code>FactoryBean</code>接口)、<code>InitializingBean</code>接口。因此当有服务引用<code>demoService</code>时，会调用<code>getObject()</code>返回代理的对象。所以<code>getObject()</code>即是关键服务。因为实现了<code>InitializingBean</code>所以在向Spring暴露bean之前会调用<code>afterPropertiesSet</code>方法。<code>RefrenceBean</code>的<code>afterPropertiesSet</code>方法作用跟<code>ServiceBean</code>的<code>afterPropertiesSet</code>一样，从Spring容器中获取<code>Consumer</code>、<code>Application</code>、<code>Module</code>、<code>Registeries</code>、<code>Monitor</code>、<code>Protocol</code>对象设置到其属性中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (getConsumer() == <span class="keyword">null</span>) &#123;</span><br><span class="line">       Map&lt;String, ConsumerConfig&gt; consumerConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ConsumerConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">       <span class="keyword">if</span> (consumerConfigMap != <span class="keyword">null</span> &amp;&amp; consumerConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           ConsumerConfig consumerConfig = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">for</span> (ConsumerConfig config : consumerConfigMap.values()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                  consumerConfig = config;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (consumerConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">               setConsumer(consumerConfig);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ...<span class="comment">//获取`Application`、`Module`、`Registeries`、`Monitor`、`Protocol`</span></span><br><span class="line">   Boolean b = isInit();</span><br><span class="line">   <span class="keyword">if</span> (b == <span class="keyword">null</span> &amp;&amp; getConsumer() != <span class="keyword">null</span>) &#123;</span><br><span class="line">       b = getConsumer().isInit();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//若配置了init则会提前初始化。调用getObject方法</span></span><br><span class="line">   <span class="keyword">if</span> (b != <span class="keyword">null</span> &amp;&amp; b.booleanValue()) &#123;</span><br><span class="line">       getObject();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getObject</code>最终会调用<code>init</code>方法，<code>init</code>方法中会组装所有配置的属性然后根据这些属性来创建代理对象<code>createProxy</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取所有配置属性组装成map</span></span><br><span class="line">   Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">   Map&lt;Object, Object&gt; attributes = <span class="keyword">new</span> HashMap&lt;Object, Object&gt;();</span><br><span class="line">   map.put(Constants.SIDE_KEY, Constants.CONSUMER_SIDE);</span><br><span class="line">   map.put(Constants.DUBBO_VERSION_KEY, Version.getVersion());</span><br><span class="line">   map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">   <span class="keyword">if</span> (ConfigUtils.getPid() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!isGeneric()) &#123;</span><br><span class="line">       String revision = Version.getVersion(interfaceClass, version);</span><br><span class="line">       <span class="keyword">if</span> (revision != <span class="keyword">null</span> &amp;&amp; revision.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           map.put(<span class="string">"revision"</span>, revision);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line">       <span class="keyword">if</span> (methods.length == <span class="number">0</span>) &#123;</span><br><span class="line">           map.put(<span class="string">"methods"</span>, Constants.ANY_VALUE);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           map.put(<span class="string">"methods"</span>, StringUtils.join(<span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(methods)), <span class="string">","</span>));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   map.put(Constants.INTERFACE_KEY, interfaceName);</span><br><span class="line">   appendParameters(map, application);</span><br><span class="line">   appendParameters(map, <span class="keyword">module</span>);</span><br><span class="line">   appendParameters(map, consumer, Constants.DEFAULT_KEY);</span><br><span class="line">   appendParameters(map, <span class="keyword">this</span>);</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 根据组装成的属性 map 创建代理</span></span><br><span class="line">   ref = createProxy(map);</span><br><span class="line">   ConsumerModel consumerModel = <span class="keyword">new</span> ConsumerModel(getUniqueServiceName(), <span class="keyword">this</span>, ref, interfaceClass.getMethods());</span><br><span class="line">   ApplicationModel.initConsumerModel(getUniqueServiceName(), consumerModel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当配置<code>injvm=true</code>时，且当前JVM有对应服务时，<code>createProxy</code>会直接应用本地的服务，本章为了涵盖更多的内容，因此会专注于远端服务引用的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createProxy</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">   URL tmpUrl = <span class="keyword">new</span> URL(<span class="string">"temp"</span>, <span class="string">"localhost"</span>, <span class="number">0</span>, map);</span><br><span class="line">   <span class="comment">// 当用户配置了url属性，则创建的是点对点的服务。</span></span><br><span class="line">   <span class="keyword">if</span> (url != <span class="keyword">null</span> &amp;&amp; url.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       String[] us = Constants.SEMICOLON_SPLIT_PATTERN.split(url);</span><br><span class="line">       <span class="keyword">if</span> (us != <span class="keyword">null</span> &amp;&amp; us.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (String u : us) &#123;</span><br><span class="line">               URL url = URL.valueOf(u);</span><br><span class="line">               <span class="keyword">if</span> (url.getPath() == <span class="keyword">null</span> || url.getPath().length() == <span class="number">0</span>) &#123;</span><br><span class="line">                   url = url.setPath(interfaceName);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">                   urls.add(url.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   urls.add(ClusterUtils.mergeUrl(url, map));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//获取注册中心的配置，装配URL</span></span><br><span class="line">       <span class="comment">//URL示例:registry://224.5.6.7:1234/com.alibaba.dubbo.registry.RegistryService?application=demo-consumer&amp;dubbo=2.0.0&amp;pid=1269&amp;qos.port=33333&amp;registry=multicast&amp;timestamp=1520264898587</span></span><br><span class="line">       List&lt;URL&gt; us = loadRegistries(<span class="keyword">false</span>);</span><br><span class="line">       <span class="keyword">if</span> (us != <span class="keyword">null</span> &amp;&amp; !us.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">for</span> (URL u : us) &#123;</span><br><span class="line">               URL monitorUrl = loadMonitor(u);</span><br><span class="line">               <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));</span><br><span class="line">               &#125;</span><br><span class="line">               urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (urls.size() == <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="comment">//之前的章节里说过，refprotocol是Protocol的自适应对象，其在执行refer时，会获取`url.getProtocol()`属性决定调用哪个拓展。</span></span><br><span class="line">       <span class="comment">//根据上面的URL可知是RegistryProtocol</span></span><br><span class="line">       invoker = refprotocol.refer(interfaceClass, urls.get(<span class="number">0</span>));</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       List&lt;Invoker&lt;?&gt;&gt; invokers = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;?&gt;&gt;();</span><br><span class="line">       URL registryURL = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">           invokers.add(refprotocol.refer(interfaceClass, url));</span><br><span class="line">           <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">               registryURL = url; <span class="comment">// use last registry url</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (registryURL != <span class="keyword">null</span>) &#123; <span class="comment">// registry url is available</span></span><br><span class="line">           <span class="comment">// use AvailableCluster only when register's cluster is available</span></span><br><span class="line">           URL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);</span><br><span class="line">           invoker = cluster.join(<span class="keyword">new</span> StaticDirectory(u, invokers));</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123; <span class="comment">// not a registry url</span></span><br><span class="line">           invoker = cluster.join(<span class="keyword">new</span> StaticDirectory(invokers));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// create service proxy</span></span><br><span class="line">   <span class="comment">//经过上面的处理后，invoker现在已是XxxClusterInvoker，下面我们以FailoverClusterInvoker为例来</span></span><br><span class="line">   <span class="keyword">return</span> (T) proxyFactory.getProxy(invoker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>proxyFactory</code>是个扩展点，有<code>JdkProxyFactory</code>和<code>JavassistProxyFactory</code>。进一步可以看到，配置的拦截器都是<code>InvokerInvocationHandler</code>。因此当调用<code>Client</code>方法时，都会被其拦截，调用其<code>invoke</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (T) Proxy.getProxy(interfaces).newInstance(<span class="keyword">new</span> InvokerInvocationHandler(invoker));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), interfaces, <span class="keyword">new</span> InvokerInvocationHandler(invoker));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">   url = url.setProtocol(url.getParameter(Constants.REGISTRY_KEY, Constants.DEFAULT_REGISTRY)).removeParameter(Constants.REGISTRY_KEY);</span><br><span class="line">   <span class="comment">// 根据URL获取具体的注册器实例，比如这里`MulticastRegistry`</span></span><br><span class="line">   Registry registry = registryFactory.getRegistry(url);</span><br><span class="line">   <span class="keyword">if</span> (RegistryService<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">type</span>)) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> proxyFactory.getInvoker((T) registry, type, url);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//  ...</span></span><br><span class="line">   <span class="keyword">return</span> doRefer(cluster, registry, type, url);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doRefer</span><span class="params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建目录，创建目录的同时也会创建路由器，在其父类`AbstractDirectory`中`setRouters`中进行创建</span></span><br><span class="line">   RegistryDirectory&lt;T&gt; directory = <span class="keyword">new</span> RegistryDirectory&lt;T&gt;(type, url);</span><br><span class="line">   directory.setRegistry(registry);</span><br><span class="line">   directory.setProtocol(protocol);</span><br><span class="line"></span><br><span class="line">   Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;String, String&gt;(directory.getUrl().getParameters());</span><br><span class="line">   URL subscribeUrl = <span class="keyword">new</span> URL(Constants.CONSUMER_PROTOCOL, parameters.remove(Constants.REGISTER_IP_KEY), <span class="number">0</span>, type.getName(), parameters);</span><br><span class="line">   <span class="keyword">if</span> (!Constants.ANY_VALUE.equals(url.getServiceInterface())</span><br><span class="line">           &amp;&amp; url.getParameter(Constants.REGISTER_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="comment">//向注册中心注册服务消费者信息</span></span><br><span class="line">       registry.register(subscribeUrl.addParameters(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY,</span><br><span class="line">               Constants.CHECK_KEY, String.valueOf(<span class="keyword">false</span>)));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 目录向注册中心订阅服务，第一次订阅或者当服务提供者信息发生改变时注册中心会将更新通知到目录</span></span><br><span class="line">   directory.subscribe(subscribeUrl.addParameter(Constants.CATEGORY_KEY,</span><br><span class="line">           Constants.PROVIDERS_CATEGORY</span><br><span class="line">                   + <span class="string">","</span> + Constants.CONFIGURATORS_CATEGORY</span><br><span class="line">                   + <span class="string">","</span> + Constants.ROUTERS_CATEGORY));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 集群将目录合并到虚拟的`XxxClusterInvoker`中，而`XxxClusterInvoker`是一种虚拟的Invoker，起分发的作用。</span></span><br><span class="line">   <span class="comment">// cluster自适应类型会根据`url.cluster`属性判断实际类型，默认为`FailoverCluster`，join后返回的是`FailoverClusterInvoker`，</span></span><br><span class="line">   Invoker invoker = cluster.join(directory);</span><br><span class="line">   ProviderConsumerRegTable.registerConsuemr(invoker, url, subscribeUrl, directory);</span><br><span class="line">   <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//`AbstractDirectory`中`setRouters`逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setRouters</span><span class="params">(List&lt;Router&gt; routers)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// copy list</span></span><br><span class="line">   routers = routers == <span class="keyword">null</span> ? <span class="keyword">new</span> ArrayList&lt;Router&gt;() : <span class="keyword">new</span> ArrayList&lt;Router&gt;(routers);</span><br><span class="line"></span><br><span class="line">   String routerkey = url.getParameter(Constants.ROUTER_KEY);</span><br><span class="line">   <span class="keyword">if</span> (routerkey != <span class="keyword">null</span> &amp;&amp; routerkey.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">//根据url.route属性创建Router实例</span></span><br><span class="line">       RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">routerkey</span>)</span>;</span><br><span class="line">       routers.add(routerFactory.getRouter(url));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 最后加上MockInvokerSelector，作用是当一个请求被配置使用mock，router则保证只有带有MOCK协议的invokers才会出现在提供者列表上</span></span><br><span class="line">   routers.add(<span class="keyword">new</span> MockInvokersSelector());</span><br><span class="line">   Collections.sort(routers);</span><br><span class="line">   <span class="keyword">this</span>.routers = routers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，实际上<code>Router</code>的作用是起过滤作用的，过滤出所有符合条件的<code>Invoker</code>。<br>再来继续看下第一次订阅或者当服务提供者信息发生改变时注册中心通知目录的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">   List&lt;URL&gt; invokerUrls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">   List&lt;URL&gt; routerUrls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">   List&lt;URL&gt; configuratorUrls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">   <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">       String protocol = url.getProtocol();</span><br><span class="line">       String category = url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);</span><br><span class="line">       <span class="comment">//分类处理：当时Route信息时，则更新Routers;</span></span><br><span class="line">       <span class="comment">//        当为服务提供者时则，则刷新服务提供者</span></span><br><span class="line">       <span class="keyword">if</span> (Constants.ROUTERS_CATEGORY.equals(category)</span><br><span class="line">               || Constants.ROUTE_PROTOCOL.equals(protocol)) &#123;</span><br><span class="line">           routerUrls.add(url);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.CONFIGURATORS_CATEGORY.equals(category)</span><br><span class="line">               || Constants.OVERRIDE_PROTOCOL.equals(protocol)) &#123;</span><br><span class="line">           configuratorUrls.add(url);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.PROVIDERS_CATEGORY.equals(category)) &#123;</span><br><span class="line">           invokerUrls.add(url);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    ...</span><br><span class="line">   <span class="comment">// routers</span></span><br><span class="line">   <span class="keyword">if</span> (routerUrls != <span class="keyword">null</span> &amp;&amp; !routerUrls.isEmpty()) &#123;</span><br><span class="line">       List&lt;Router&gt; routers = toRouters(routerUrls);</span><br><span class="line">       <span class="keyword">if</span> (routers != <span class="keyword">null</span>) &#123; <span class="comment">// null - do nothing</span></span><br><span class="line">           setRouters(routers);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 刷新Invokers</span></span><br><span class="line">   refreshInvoker(invokerUrls);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshInvoker</span><span class="params">(List&lt;URL&gt; invokerUrls)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.forbidden = <span class="keyword">false</span>; <span class="comment">// Allow to access</span></span><br><span class="line">   Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap = <span class="keyword">this</span>.urlInvokerMap; <span class="comment">// local reference</span></span><br><span class="line">   <span class="keyword">if</span> (invokerUrls.isEmpty() &amp;&amp; <span class="keyword">this</span>.cachedInvokerUrls != <span class="keyword">null</span>) &#123;</span><br><span class="line">       invokerUrls.addAll(<span class="keyword">this</span>.cachedInvokerUrls);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">this</span>.cachedInvokerUrls = <span class="keyword">new</span> HashSet&lt;URL&gt;();</span><br><span class="line">       <span class="keyword">this</span>.cachedInvokerUrls.addAll(invokerUrls);<span class="comment">//Cached invoker urls, convenient for comparison</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (invokerUrls.isEmpty()) &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//将url转换为Invoker</span></span><br><span class="line">   Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = toInvokers(invokerUrls);</span><br><span class="line">   Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; newMethodInvokerMap = toMethodInvokers(newUrlInvokerMap);</span><br><span class="line">   <span class="keyword">this</span>.methodInvokerMap = multiGroup ? toMergeMethodInvokerMap(newMethodInvokerMap) : newMethodInvokerMap;</span><br><span class="line">   <span class="keyword">this</span>.urlInvokerMap = newUrlInvokerMap;</span><br><span class="line">   <span class="comment">//关闭无用的Invokers</span></span><br><span class="line">   destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Invoker&lt;T&gt;&gt; toInvokers(List&lt;URL&gt; urls) &#123;</span><br><span class="line">   Set&lt;String&gt; keys = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">   Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = <span class="keyword">new</span> HashMap&lt;String, Invoker&lt;T&gt;&gt;();</span><br><span class="line">   <span class="keyword">for</span> (URL providerUrl : urls) &#123;</span><br><span class="line">    <span class="comment">////URL: dubbo://192.168.199.105:32323/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-consumer&amp;check=false&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;loadbalance=leastactive&amp;methods=sayHello&amp;pid=1723&amp;qos.port=33333&amp;register.ip=192.168.199.105&amp;remote.timestamp=1520264874377&amp;scope=remote&amp;side=consumer&amp;timestamp=1520268138014</span></span><br><span class="line">       URL url = mergeUrl(providerUrl);</span><br><span class="line">       String key = url.toFullString(); <span class="comment">// The parameter urls are sorted</span></span><br><span class="line">       <span class="keyword">if</span> (keys.contains(key)) &#123; <span class="comment">// Repeated url</span></span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       keys.add(key);</span><br><span class="line">       Map&lt;String, Invoker&lt;T&gt;&gt; localUrlInvokerMap = <span class="keyword">this</span>.urlInvokerMap; <span class="comment">// local reference</span></span><br><span class="line">       Invoker&lt;T&gt; invoker = localUrlInvokerMap == <span class="keyword">null</span> ? <span class="keyword">null</span> : localUrlInvokerMap.get(key);</span><br><span class="line">       <span class="keyword">if</span> (invoker == <span class="keyword">null</span>) &#123; <span class="comment">// Not in the cache, refer again</span></span><br><span class="line">           <span class="keyword">boolean</span> enabled = <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">if</span> (url.hasParameter(Constants.DISABLED_KEY)) &#123;</span><br><span class="line">               enabled = !url.getParameter(Constants.DISABLED_KEY, <span class="keyword">false</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               enabled = url.getParameter(Constants.ENABLED_KEY, <span class="keyword">true</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">                <span class="comment">//引用服务的关键，调用DubboProtocol.refer</span></span><br><span class="line">               invoker = <span class="keyword">new</span> InvokerDelegate&lt;T&gt;(protocol.refer(serviceType, url), url, providerUrl);</span><br><span class="line">               newUrlInvokerMap.put(key, invoker);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   keys.clear();</span><br><span class="line">   <span class="keyword">return</span> newUrlInvokerMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DubboProtocol.refer</code>用来创建传输层的Clients，并建立长连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; serviceType, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">   optimizeSerialization(url);</span><br><span class="line">   <span class="comment">// create rpc invoker.</span></span><br><span class="line">   <span class="comment">//getClients即是用来创建客户端连接</span></span><br><span class="line">   DubboInvoker&lt;T&gt; invoker = <span class="keyword">new</span> DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);</span><br><span class="line">   invokers.add(invoker);</span><br><span class="line">   <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getClients</code>会间接调用某种类型(<code>XxxTransporter</code>)的传输器<code>connect</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">`getClients`</span><br><span class="line">-&gt; `HeaderExchanger.connect`</span><br><span class="line">    -&gt;<span class="keyword">new</span> HeaderExchangeClient(Transporters.connect(url, <span class="keyword">new</span> DecodeHandler(<span class="keyword">new</span> HeaderExchangeHandler(handler))), <span class="keyword">true</span>)</span><br><span class="line">        -&gt; `Transporter.connect`</span><br><span class="line">```Getclients`会</span><br><span class="line">假定我们使用`Netty`做传输层，则`Transporter.connect`会创建一个`NettyClient`，它会在构造函数内进行初始化后`Netty`客户端模式的配置然后建立连接。</span><br><span class="line">重点来看下初始化`NettyClient`的逻辑：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">   NettyHelper.setNettyLoggerFactory();</span><br><span class="line">   bootstrap = <span class="keyword">new</span> ClientBootstrap(channelFactory);</span><br><span class="line">   bootstrap.setOption(<span class="string">"keepAlive"</span>, <span class="keyword">true</span>);</span><br><span class="line">   bootstrap.setOption(<span class="string">"tcpNoDelay"</span>, <span class="keyword">true</span>);</span><br><span class="line">   bootstrap.setOption(<span class="string">"connectTimeoutMillis"</span>, getTimeout());</span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="keyword">final</span> NettyHandler nettyHandler = <span class="keyword">new</span> NettyHandler(getUrl(), <span class="keyword">this</span>);</span><br><span class="line">   bootstrap.setPipelineFactory(<span class="keyword">new</span> ChannelPipelineFactory() &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ChannelPipeline <span class="title">getPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">//这里封装了编码器和解码器逻辑</span></span><br><span class="line">           NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyClient.<span class="keyword">this</span>);</span><br><span class="line">           ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line">           <span class="comment">//解码，用途接收结果后的解码</span></span><br><span class="line">           pipeline.addLast(<span class="string">"decoder"</span>, adapter.getDecoder());</span><br><span class="line">           <span class="comment">//用于发送请求的编码</span></span><br><span class="line">           pipeline.addLast(<span class="string">"encoder"</span>, adapter.getEncoder());</span><br><span class="line">           <span class="comment">// 发送请求的出口和处理请求的入口</span></span><br><span class="line">           pipeline.addLast(<span class="string">"handler"</span>, nettyHandler);</span><br><span class="line">           <span class="keyword">return</span> pipeline;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>另外一方面，值得一提的是<code>HeaderExchangeClient</code>和<code>HeaderExchangeServer</code>，都带有心跳功能，他们会周期扫描当前所有的<code>Channel</code>，如果该<code>Channel</code>最近一个周期内没被读或写的话，则发送一次心跳请求，若心跳超时则进行重连。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeaderExchangeClient</span><span class="params">(Client client, <span class="keyword">boolean</span> needHeartbeat)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">if</span> (needHeartbeat) &#123;</span><br><span class="line">       startHeatbeatTimer();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startHeatbeatTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stopHeartbeatTimer();</span><br><span class="line">   <span class="keyword">if</span> (heartbeat &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 定时运行心跳任务</span></span><br><span class="line">       heartbeatTimer = scheduled.scheduleWithFixedDelay(</span><br><span class="line">               <span class="keyword">new</span> HeartBeatTask(<span class="keyword">new</span> HeartBeatTask.ChannelProvider() &#123;</span><br><span class="line">                   <span class="function"><span class="keyword">public</span> Collection&lt;Channel&gt; <span class="title">getChannels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                       <span class="keyword">return</span> Collections.&lt;Channel&gt;singletonList(HeaderExchangeClient.<span class="keyword">this</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;, heartbeat, heartbeatTimeout),</span><br><span class="line">               heartbeat, heartbeat, TimeUnit.MILLISECONDS);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 进一步看 HeartBeatTask的run方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">   <span class="keyword">for</span> (Channel channel : channelProvider.getChannels()) &#123;</span><br><span class="line">       <span class="keyword">if</span> (channel.isClosed()) &#123;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       Long lastRead = (Long) channel.getAttribute(</span><br><span class="line">               HeaderExchangeHandler.KEY_READ_TIMESTAMP);</span><br><span class="line">       Long lastWrite = (Long) channel.getAttribute(</span><br><span class="line">               HeaderExchangeHandler.KEY_WRITE_TIMESTAMP);</span><br><span class="line">       <span class="comment">//如果上一次rpc操作时间到现在已经超过心跳周期，则发起一起心跳</span></span><br><span class="line">       <span class="keyword">if</span> ((lastRead != <span class="keyword">null</span> &amp;&amp; now - lastRead &gt; heartbeat)</span><br><span class="line">               || (lastWrite != <span class="keyword">null</span> &amp;&amp; now - lastWrite &gt; heartbeat)) &#123;</span><br><span class="line">           Request req = <span class="keyword">new</span> Request();</span><br><span class="line">           req.setVersion(<span class="string">"2.0.0"</span>);</span><br><span class="line">           req.setTwoWay(<span class="keyword">true</span>);</span><br><span class="line">           req.setEvent(Request.HEARTBEAT_EVENT);</span><br><span class="line">           channel.send(req);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (lastRead != <span class="keyword">null</span> &amp;&amp; now - lastRead &gt; heartbeatTimeout) &#123;</span><br><span class="line">           <span class="keyword">if</span> (channel <span class="keyword">instanceof</span> Client) &#123;</span><br><span class="line">               ((Client) channel).reconnect();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               channel.close();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对的，在<code>NettyServer</code>和<code>NettyClient</code>构造函数里，可以看到<code>ChannelHandlers.wrap(handler...)</code>这段逻辑。深入进去后会发现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ChannelHandler <span class="title">wrapInternal</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> MultiMessageHandler(<span class="keyword">new</span> `HeartbeatHandler`(ExtensionLoader.getExtensionLoader(Dispatcher<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">           .<span class="title">getAdaptiveExtension</span>().<span class="title">dispatch</span>(<span class="title">handler</span>, <span class="title">url</span>)))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会在ChannelHandler中嵌入一个<code>HeartbeatHandler</code>，用来处理心跳请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">   setReadTimestamp(channel);</span><br><span class="line">   <span class="comment">// 如果是心跳请求，则直接返回`Response`</span></span><br><span class="line">   <span class="keyword">if</span> (isHeartbeatRequest(message)) &#123;</span><br><span class="line">       Request req = (Request) message;</span><br><span class="line">       <span class="keyword">if</span> (req.isTwoWay()) &#123;</span><br><span class="line">           Response res = <span class="keyword">new</span> Response(req.getId(), req.getVersion());</span><br><span class="line">           res.setEvent(Response.HEARTBEAT_EVENT);</span><br><span class="line">           channel.send(res);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果是心跳返回结果，...</span></span><br><span class="line">   <span class="keyword">if</span> (isHeartbeatResponse(message)) &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   handler.received(channel, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2018/04/23/rpc/dubbo/3.dubbo-%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.png">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/23/rpc/dubbo/3.dubbo-%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/" class="post-title-link" itemprop="url">Dubbo 服务暴露</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-23 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-23T00:00:00+08:00">2018-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-13 19:07:00" itemprop="dateModified" datetime="2020-02-13T19:07:00+08:00">2020-02-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dubbo/" itemprop="url" rel="index">
                    <span itemprop="name">dubbo</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="服务暴露过程解析"><a href="#服务暴露过程解析" class="headerlink" title="服务暴露过程解析"></a>服务暴露过程解析</h1><p>当在XML文件中配置下面内容，启动时<code>Dubbo</code>即会发布<code>demoService</code>服务，服务调用者皆可并在注册中心查到此服务提供者，并向其发起调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:application name=<span class="string">"demo-provider"</span>/&gt;</span><br><span class="line">&lt;dubbo:registry address=<span class="string">"multicast://224.5.6.7:1234"</span>/&gt;</span><br><span class="line">&lt;dubbo:protocol name=<span class="string">"dubbo"</span> port=<span class="string">"32321"</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">"demoService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.alibaba.dubbo.demo.provider.DemoServiceImpl"</span>/&gt;</span><br><span class="line"><span class="comment">//服务发布</span></span><br><span class="line">&lt;dubbo:service <span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.alibaba.dubbo.demo.DemoService"</span> ref=<span class="string">"demoService"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>其中<code>&lt;dubbo:service&gt;</code>用来初始化发布服务，其会被<code>DubboBeanDefinitionParser</code>解析成<code>ServiceBean</code>，并放在Spring容器中。<code>afterPropertiesSet</code>方法初始化<code>ServiceBean</code>。</p>
<p>其主要是从<code>Spring容器</code>中获取<code>Provider</code>、<code>Application</code>、<code>Module</code>、<code>Registeries</code>、<code>Monitor</code>、<code>Protocol</code>对象设置到属性中。</p>
<ul>
<li>没有配置<code>delay</code>属性时，直接调用<code>export</code>暴露服务</li>
<li>配置了<code>delay</code>属性时，则会在Spring实例完所有bean后，发布<code>ContextRefreshEvent</code>事件时，调用<code>ServiceBean</code>(实现<code>ApplicationListener</code>接口)的<code>onApplicationEvent</code>方法进行<code>export</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (getProvider() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 获取所有Provider</span></span><br><span class="line">      Map&lt;String, ProviderConfig&gt; providerConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProviderConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">      <span class="keyword">if</span> (providerConfigMap != <span class="keyword">null</span> &amp;&amp; providerConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          Map&lt;String, ProtocolConfig&gt; protocolConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">          <span class="keyword">if</span> ((protocolConfigMap == <span class="keyword">null</span> || protocolConfigMap.size() == <span class="number">0</span>)</span><br><span class="line">                  &amp;&amp; providerConfigMap.size() &gt; <span class="number">1</span>) &#123; <span class="comment">// backward compatibility</span></span><br><span class="line">              List&lt;ProviderConfig&gt; providerConfigs = <span class="keyword">new</span> ArrayList&lt;ProviderConfig&gt;();</span><br><span class="line">              <span class="keyword">for</span> (ProviderConfig config : providerConfigMap.values()) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (config.isDefault() != <span class="keyword">null</span> &amp;&amp; config.isDefault().booleanValue()) &#123;</span><br><span class="line">                      providerConfigs.add(config);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (!providerConfigs.isEmpty()) &#123;</span><br><span class="line">                  setProviders(providerConfigs);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!isDelay()) &#123;</span><br><span class="line">      export();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>export</code>方法最关键的部分是执行<code>doExportUrls</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//获取注册中心的URL，向多个注册中心发布服务</span></span><br><span class="line">   List&lt;URL&gt; registryURLs = loadRegistries(<span class="keyword">true</span>);</span><br><span class="line">   <span class="comment">// protocols即为`ServiceBean`初始化时从`Spring`容器中获取的对象集合</span></span><br><span class="line">   <span class="comment">//用Protocol挨个暴露服务</span></span><br><span class="line">   <span class="keyword">for</span> (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">       doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>&#123;</span><br><span class="line">   String name = protocolConfig.getName();</span><br><span class="line">   <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">       name = <span class="string">"dubbo"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 拼装参数</span></span><br><span class="line">   Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">   map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);</span><br><span class="line">   map.put(Constants.DUBBO_VERSION_KEY, Version.getVersion());</span><br><span class="line">   map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">   <span class="keyword">if</span> (ConfigUtils.getPid() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">   &#125;</span><br><span class="line">   appendParameters(map, application);</span><br><span class="line">   appendParameters(map, <span class="keyword">module</span>);</span><br><span class="line">   appendParameters(map, provider, Constants.DEFAULT_KEY);</span><br><span class="line">   appendParameters(map, protocolConfig);</span><br><span class="line">   appendParameters(map, <span class="keyword">this</span>);</span><br><span class="line">   ...</span><br><span class="line">   String scope = url.getParameter(Constants.SCOPE_KEY);</span><br><span class="line">   <span class="comment">// scope为local时，只向本地暴露服务</span></span><br><span class="line">   <span class="keyword">if</span> (!Constants.SCOPE_REMOTE.toString().equalsIgnoreCase(scope)) &#123;</span><br><span class="line">      exportLocal(url);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// scope为remote时，向注册中心暴露服务</span></span><br><span class="line">   <span class="keyword">if</span> (!Constants.SCOPE_LOCAL.toString().equalsIgnoreCase(scope)) &#123;</span><br><span class="line">     <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">         logger.info(<span class="string">"Export dubbo service "</span> + interfaceClass.getName() + <span class="string">" to url "</span> + url);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (registryURLs != <span class="keyword">null</span> &amp;&amp; !registryURLs.isEmpty()) &#123;</span><br><span class="line">         <span class="keyword">for</span> (URL registryURL : registryURLs) &#123;</span><br><span class="line">         <span class="comment">// registryURL:</span></span><br><span class="line">             url = url.addParameterIfAbsent(<span class="string">"dynamic"</span>, registryURL.getParameter(<span class="string">"dynamic"</span>));</span><br><span class="line">             URL monitorUrl = loadMonitor(registryURL);</span><br><span class="line">             <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                 logger.info(<span class="string">"Register dubbo service "</span> + interfaceClass.getName() + <span class="string">" url "</span> + url + <span class="string">" to registry "</span> + registryURL);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//通过代理工厂生成一个Invoker</span></span><br><span class="line">             Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</span><br><span class="line">             <span class="comment">//创建一个代理Invoker，包装Invoker并带有元数据</span></span><br><span class="line">             DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">//调用protocol暴露服务    </span></span><br><span class="line">             Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">             exporters.add(exporter);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; ...</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，就是<code>Protocol</code>进行暴露以及发布服务：<br><code>ServiceBean</code>中的<code>Protocol</code>对应的是自适应类型<code>Protocol</code>，调用<code>export</code>方法时，其会根据参数Invoker的URL属性<code>url.getProtocol()</code>来判定调用哪个<code>Protocol</code>对象。上文中的<code>registryURL.getProtocol</code>为<code>registry</code>，所以回去调用<code>RegistryProtocol</code>（会先调用包装类<code>ProtocolListenerWrapper</code>、<code>ProtocolFilterWrapper</code>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">   <span class="comment">//本地暴露服务</span></span><br><span class="line">   <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker);</span><br><span class="line">   URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line">   <span class="comment">//获取注册组件</span></span><br><span class="line">   <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">   <span class="keyword">final</span> URL registedProviderUrl = getRegistedProviderUrl(originInvoker);</span><br><span class="line">   <span class="keyword">boolean</span> register = registedProviderUrl.getParameter(<span class="string">"register"</span>, <span class="keyword">true</span>);</span><br><span class="line">   ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registedProviderUrl);</span><br><span class="line">   <span class="keyword">if</span> (register) &#123;</span><br><span class="line">       register(registryUrl, registedProviderUrl);</span><br><span class="line">       ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(<span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(registedProviderUrl);</span><br><span class="line">   <span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class="line">   overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">   registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> DestroyableExporter&lt;T&gt;(exporter, originInvoker, overrideSubscribeUrl, registedProviderUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的逻辑，可以分为两大部分：第一部分就是 本地服务暴露的逻辑，另一部分是注册服务的逻辑。因此，下面分别从这两部分说：</p>
<h2 id="本地服务暴露："><a href="#本地服务暴露：" class="headerlink" title="本地服务暴露："></a>本地服务暴露：</h2><p><code>doLocalExport</code>就是服务本地暴露的主体代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">ExporterChangeableWrapper&lt;T&gt; <span class="title">doLocalExport</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> </span>&#123;</span><br><span class="line">   String key = getCacheKey(originInvoker);</span><br><span class="line">   ExporterChangeableWrapper&lt;T&gt; exporter = (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);</span><br><span class="line">   <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (bounds) &#123;</span><br><span class="line">           exporter = (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);</span><br><span class="line">           <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//getProviderUrl提取出要暴露的服务Url信息：dubbo://172.19.154.24:32321/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;bind.ip=172.19.154.24&amp;bind.port=32321&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=5464&amp;qos.port=22222&amp;scope=remote&amp;side=provider&amp;timestamp=1520158786026</span></span><br><span class="line">               <span class="keyword">final</span> Invoker&lt;?&gt; invokerDelegete = <span class="keyword">new</span> InvokerDelegete&lt;T&gt;(originInvoker, getProviderUrl(originInvoker));</span><br><span class="line">               <span class="comment">// protocol.export(invokerDelegete)根据url.getProtocol最终调用DubboProtocol的export方法</span></span><br><span class="line">               exporter = <span class="keyword">new</span> ExporterChangeableWrapper&lt;T&gt;((Exporter&lt;T&gt;) protocol.export(invokerDelegete), originInvoker);</span><br><span class="line">               bounds.put(key, exporter);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> exporter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//DubboProtocol.export():</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">   URL url = invoker.getUrl();</span><br><span class="line">   <span class="comment">//key: com.alibaba.dubbo.demo.DemoService:32321</span></span><br><span class="line">   String key = serviceKey(url);</span><br><span class="line">   DubboExporter&lt;T&gt; exporter = <span class="keyword">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">   <span class="comment">// *** 当RPC调用时，也通过key在这个exporterMap中取Exporter ***</span></span><br><span class="line">   exporterMap.put(key, exporter);</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 创建Server,监听端口,开启服务:</span></span><br><span class="line">   openServer(url);</span><br><span class="line">   optimizeSerialization(url);</span><br><span class="line">   <span class="keyword">return</span> exporter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openServer</span><br><span class="line"> -&gt; createServer</span><br><span class="line">    -&gt; Exchangers.bind(url, requestHandler)</span><br></pre></td></tr></table></figure>
<p>其中<code>requestHandler</code>为<code>DubboProtocol</code>的成员变量，当客户端发送请求时将由它进行处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ExchangeHandler requestHandler = <span class="keyword">new</span> ExchangeHandlerAdapter() &#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">reply</span><span class="params">(ExchangeChannel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Invocation) &#123;</span><br><span class="line">           Invocation inv = (Invocation) message;</span><br><span class="line">           Invoker&lt;?&gt; invoker = getInvoker(channel, inv);</span><br><span class="line">           ...</span><br><span class="line">           RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());</span><br><span class="line">           <span class="comment">// 最终同反射的方式调用业务逻辑</span></span><br><span class="line">           <span class="keyword">return</span> invoker.invoke(inv);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line"><span class="comment">//从exporterMap中获取Exporter和Invoker</span></span><br><span class="line">Invoker&lt;?&gt; getInvoker(Channel channel, Invocation inv) <span class="keyword">throws</span> RemotingException &#123;</span><br><span class="line">   ...</span><br><span class="line">   DubboExporter&lt;?&gt; exporter = (DubboExporter&lt;?&gt;) exporterMap.get(serviceKey);</span><br><span class="line">   <span class="keyword">return</span> exporter.getInvoker();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Exchangers.bind(url, requestHandler)</code>监听端口，开启服务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Exchangers.bind(url, requestHandler)</span><br><span class="line">    -&gt; HeaderExchanger.bind()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> HeaderExchangeServer(Transporters.bind(url, <span class="keyword">new</span> DecodeHandler(<span class="keyword">new</span> HeaderExchangeHandler(handler))));</span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Server <span class="title">bind</span><span class="params">(URL url, ChannelHandler... handlers)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">   ChannelHandler handler;</span><br><span class="line">   <span class="keyword">if</span> (handlers.length == <span class="number">1</span>) &#123;</span><br><span class="line">       handler = handlers[<span class="number">0</span>];</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       handler = <span class="keyword">new</span> ChannelHandlerDispatcher(handlers);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 获取Transporter是网络传输层的拓展，根据url中的server或者transporter来确定具体类型，这里先设定为Netty</span></span><br><span class="line">   <span class="keyword">return</span> getTransporter().bind(url, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NettyTransporter.bind()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">bind</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> NettyServer(url, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NettyServer</code>是监听端口，暴露服务的关键。其先设置<code>bindAddress</code>、<code>bindIp</code>、<code>bindPort</code>属性，然后调用<code>doOpen()</code>函数开启服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">   <span class="comment">// ChannelHandlers.wrap()对handler做了一层包装，在其中加上了心跳处理、多消息处理以及`Dispatcher`的逻辑（Dispatcher作用是消息派发）</span></span><br><span class="line">   <span class="keyword">super</span>(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));</span><br><span class="line">&#125;</span><br><span class="line">ChannelHandlers.wrap</span><br><span class="line">    -&gt;ChannelHandlers.getInstance().wrapInternal</span><br><span class="line">        -&gt; <span class="keyword">new</span> MultiMessageHandler(<span class="keyword">new</span> HeartbeatHandler(ExtensionLoader.getExtensionLoader(Dispatcher<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>().<span class="title">dispatch</span>(<span class="title">handler</span>, <span class="title">url</span>)))</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//熟悉<span class="title">Netty</span>的都明白这段的含义：设置<span class="title">boss</span>线程池、<span class="title">work</span>线程池大小，设置<span class="title">pipeline</span>，启动服务监听端口</span></span><br><span class="line"><span class="class"><span class="title">protected</span> <span class="title">void</span> <span class="title">doOpen</span>() <span class="title">throws</span> <span class="title">Throwable</span> </span>&#123;</span><br><span class="line">   NettyHelper.setNettyLoggerFactory();</span><br><span class="line">   ExecutorService boss = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"NettyServerBoss"</span>, <span class="keyword">true</span>));</span><br><span class="line">   ExecutorService worker = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"NettyServerWorker"</span>, <span class="keyword">true</span>));</span><br><span class="line">   ChannelFactory channelFactory = <span class="keyword">new</span> NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS));</span><br><span class="line">   bootstrap = <span class="keyword">new</span> ServerBootstrap(channelFactory);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> NettyHandler nettyHandler = <span class="keyword">new</span> NettyHandler(getUrl(), <span class="keyword">this</span>);</span><br><span class="line">   channels = nettyHandler.getChannels();</span><br><span class="line">   bootstrap.setPipelineFactory(<span class="keyword">new</span> ChannelPipelineFactory() &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ChannelPipeline <span class="title">getPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyServer.<span class="keyword">this</span>);</span><br><span class="line">           ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line">           pipeline.addLast(<span class="string">"decoder"</span>, adapter.getDecoder());</span><br><span class="line">           pipeline.addLast(<span class="string">"encoder"</span>, adapter.getEncoder());</span><br><span class="line">           pipeline.addLast(<span class="string">"handler"</span>, nettyHandler);</span><br><span class="line">           <span class="keyword">return</span> pipeline;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="comment">// bind</span></span><br><span class="line">   channel = bootstrap.bind(getBindAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">   <span class="comment">//export invoker</span></span><br><span class="line">   <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker);</span><br><span class="line">   URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line">   <span class="comment">//获取注册器</span></span><br><span class="line">   <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">   <span class="keyword">final</span> URL registedProviderUrl = getRegistedProviderUrl(originInvoker);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//to judge to delay publish whether or not</span></span><br><span class="line">   <span class="keyword">boolean</span> register = registedProviderUrl.getParameter(<span class="string">"register"</span>, <span class="keyword">true</span>);</span><br><span class="line">   ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registedProviderUrl);</span><br><span class="line">   <span class="keyword">if</span> (register) &#123;</span><br><span class="line">      <span class="comment">// 注册</span></span><br><span class="line">       register(registryUrl, registedProviderUrl);</span><br><span class="line">       ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(<span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(registedProviderUrl);</span><br><span class="line">   <span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class="line">   overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">   <span class="comment">//监听</span></span><br><span class="line">   registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dubbo官方文档中的demo服务默认用`MulticastRegistry`作注册器。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL registryUrl, URL registedProviderUrl)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//获取Registry</span></span><br><span class="line">   Registry registry = registryFactory.getRegistry(registryUrl);</span><br><span class="line">   <span class="comment">// 注册服务</span></span><br><span class="line">   registry.register(registedProviderUrl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以MulticastRegistry为例，最终会调用`doRegister(URL url)`服务：</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">   broadcast(Constants.REGISTER + <span class="string">" "</span> + url.toFullString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 广播注册消息</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">broadcast</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">byte</span>[] data = (msg + <span class="string">"\n"</span>).getBytes();</span><br><span class="line">       DatagramPacket hi = <span class="keyword">new</span> DatagramPacket(data, data.length, mutilcastAddress, mutilcastPort);</span><br><span class="line">       mutilcastSocket.send(hi);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结起来：</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2018/04/22/rpc/dubbo/2.dubbo-spi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.png">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/22/rpc/dubbo/2.dubbo-spi/" class="post-title-link" itemprop="url">Dubbo SPI拓展机制</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-22 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-22T00:00:00+08:00">2018-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-13 19:06:46" itemprop="dateModified" datetime="2020-02-13T19:06:46+08:00">2020-02-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dubbo/" itemprop="url" rel="index">
                    <span itemprop="name">dubbo</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SPI拓展机制（IOC、AOP、自适应拓展）"><a href="#SPI拓展机制（IOC、AOP、自适应拓展）" class="headerlink" title="SPI拓展机制（IOC、AOP、自适应拓展）"></a>SPI拓展机制（IOC、AOP、自适应拓展）</h1><p>Dubbo 官方文档 <a href="http://dubbo.io/books/dubbo-dev-book/SPI.html" target="_blank" rel="noopener">拓展点加载</a> 介绍了Dubbo的<strong>SPI拓展机制</strong>，总结起来如下：</p>
<blockquote>
<ol>
<li>是<code>JDK SPI</code>的加强版：<ul>
<li>只有使用的时候才会实例化拓展点，而摒弃<code>JDK SPI</code>一次性实例化所有拓展点</li>
<li>增加了对IOC、AOP的支持</li>
</ul>
</li>
<li>拓展的方法：在扩展类的 jar 包内，放置扩展点配置文件 <code>META-INF/dubbo/接口全限定名</code>，内容为：配置名=扩展实现类全限定名，多个实现类用换行符分隔。即可被Dubbo自动加载。</li>
<li>扩展点的特性：<ul>
<li>扩展点自动装配(<strong>IOC</strong>)：加载扩展点时，扩展点实现类的成员如果为其它扩展点类型，在会自动注入依赖的扩展点；</li>
<li>扩展点自动包装：<strong>AOP</strong>的一种实现方式，为拓展点自动添加一层包装，将某些可拓展的共有逻辑放在包装类(Wrapper)中。调用时，会先调用包装类的逻辑再调用拓展点的内容；</li>
<li>扩展点<strong>自适应</strong>：在拓展点方法执行的时候，根据调用的参数(<strong>URL</strong>)决定调用的是哪个拓展点实现，而不会在初始化时就直接指定是哪个拓展点；</li>
<li>扩展点自动激活：对于集合类拓展点，可以同时加载多个实现。自动激活可以简化配置，且可以编排它们的顺序。</li>
</ul>
</li>
</ol>
</blockquote>
<p><code>ExtensionLoader</code>是实现其SPI拓展机制的关键类，Dubbo会为每种类型拓展点都创建有一个<code>ExtensionLoader</code>实例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ExtensionLoader&lt;T&gt; <span class="title">getExtensionLoader</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//首先从缓存里获取</span></span><br><span class="line">   ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">   <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">       EXTENSION_LOADERS.putIfAbsent(type, <span class="keyword">new</span> ExtensionLoader&lt;T&gt;(type));</span><br><span class="line">       loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> loader;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//私有构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ExtensionLoader</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.type = type;</span><br><span class="line">   objectFactory = (type == ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其最主要的属性如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所处理的拓展点类型（接口类型）</span></span><br><span class="line">Class&lt;?&gt; type;</span><br><span class="line"><span class="comment">//拓展点工厂，用于在拓展点注入属性时获取属性的实例（从SPI中获取或者从Spring的上下文中获取）</span></span><br><span class="line">ExtensionFactory objectFactory;</span><br><span class="line"><span class="comment">//拓展点类和名称的映射</span></span><br><span class="line">ConcurrentMap&lt;Class&lt;?&gt;, String&gt; cachedNames = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, String&gt;();</span><br><span class="line"><span class="comment">// 名称和类的映射，类可能有多个名称</span></span><br><span class="line">Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt; cachedClasses = <span class="keyword">new</span> Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt;();</span><br><span class="line"><span class="comment">// 名称与激活拓展点注解的映射。</span></span><br><span class="line">Map&lt;String, Activate&gt; cachedActivates = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Activate&gt;();</span><br><span class="line"><span class="comment">//名称与拓展点实例的映射，一般一个拓展点只会有一个实例</span></span><br><span class="line">ConcurrentMap&lt;String, Holder&lt;Object&gt;&gt; cachedInstances = <span class="keyword">new</span></span><br><span class="line">ConcurrentHashMap&lt;String, Holder&lt;Object&gt;&gt;();</span><br><span class="line"><span class="comment">// 自适应拓展点实例</span></span><br><span class="line">Holder&lt;Object&gt; cachedAdaptiveInstance = <span class="keyword">new</span> Holder&lt;Object&gt;();</span><br><span class="line"><span class="comment">//自实例拓展点类型</span></span><br><span class="line">Class&lt;?&gt; cachedAdaptiveClass = <span class="keyword">null</span>;</span><br><span class="line">String cachedDefaultName;</span><br><span class="line"><span class="comment">//包装类集合 AOP</span></span><br><span class="line">Set&lt;Class&lt;?&gt;&gt; cachedWrapperClasses;</span><br></pre></td></tr></table></figure>

<p>对外暴露的最主要的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取自适应拓展</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getAdaptiveExtension</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//根据name获取特定的拓展实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getExtension</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="comment">// 根据条件获取当前扩展可自动激活的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getActivateExtension</span><span class="params">(URL url, String[] values, String group)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Dubbo初始化时，获取拓展点时一般是调用<code>getActivateExtension</code>获取自适应拓展点，然后在运行时调用方法时，根据实时的参数<code>URL</code>确定拓展点实例的name，调用<code>getExtension(name)</code>获取实例。下面我们依次看这三个实现方法：</p>
<h3 id="getAdaptiveExtension"><a href="#getAdaptiveExtension" class="headerlink" title="getAdaptiveExtension"></a>getAdaptiveExtension</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Object instance = cachedAdaptiveInstance.get();</span><br><span class="line">   <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (createAdaptiveInstanceError == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (cachedAdaptiveInstance) &#123;</span><br><span class="line">               instance = cachedAdaptiveInstance.get();</span><br><span class="line">               <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="comment">//没有时，创建</span></span><br><span class="line">                       instance = createAdaptiveExtension();</span><br><span class="line">                       cachedAdaptiveInstance.set(instance);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                       ...</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//先实例化自适应对象实例，后注入属性</span></span><br><span class="line">       <span class="keyword">return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br><span class="line">   &#125;...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class="line">   <span class="comment">//加载所有type类型类</span></span><br><span class="line">   getExtensionClasses();</span><br><span class="line">   <span class="comment">//若有自适应类信息，则直接返回</span></span><br><span class="line">   <span class="keyword">if</span> (cachedAdaptiveClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> cachedAdaptiveClass;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//没有时，自动生成自适应类(xxx$Adaptive)</span></span><br><span class="line">   <span class="keyword">return</span> cachedAdaptiveClass = createAdaptiveExtensionClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上文分析中有三个比较关键的方法<code>getExtensionClasses</code>、<code>createAdaptiveExtensionClass</code>、<code>injectExtension</code>。下面，我们重点来分析它们：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最终会调用loadExtensionClasses来加载所有type类型的Class</span></span><br><span class="line">getExtensionClass(String name)</span><br><span class="line">    - getExtensionClasses().get(name)</span><br><span class="line">        - loadExtensionClasses()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFile</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir)</span> </span>&#123;</span><br><span class="line">  String fileName = dir + type.getName();</span><br><span class="line">  Enumeration&lt;java.net.URL&gt; urls;</span><br><span class="line">  ClassLoader classLoader = findClassLoader();</span><br><span class="line">  <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">      urls = classLoader.getResources(fileName);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      urls = ClassLoader.getSystemResources(fileName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (urls == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">      java.net.URL url = urls.nextElement();</span><br><span class="line">      BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(url.openStream(), <span class="string">"utf-8"</span>));</span><br><span class="line">      String line = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> ci = line.indexOf(<span class="string">'#'</span>);</span><br><span class="line">          <span class="keyword">if</span> (ci &gt;= <span class="number">0</span>) line = line.substring(<span class="number">0</span>, ci);</span><br><span class="line">          line = line.trim();</span><br><span class="line">          <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              String name = <span class="keyword">null</span>;</span><br><span class="line">              <span class="keyword">int</span> i = line.indexOf(<span class="string">'='</span>);</span><br><span class="line">              <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                  name = line.substring(<span class="number">0</span>, i).trim();</span><br><span class="line">                  line = line.substring(i + <span class="number">1</span>).trim();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">//加载类</span></span><br><span class="line">                  Class&lt;?&gt; clazz = Class.forName(line, <span class="keyword">true</span>, classLoader);</span><br><span class="line">                  <span class="comment">//如果是自适应类，则设置</span></span><br><span class="line">                  <span class="keyword">if</span> (clazz.isAnnotationPresent(Adaptive<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                      <span class="keyword">if</span> (cachedAdaptiveClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                          cachedAdaptiveClass = clazz;</span><br><span class="line">                      &#125;...</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="keyword">try</span> &#123;</span><br><span class="line">                          <span class="comment">//如果有以type为入参的构造函数，则说明类是包装类，加入包装类缓存中</span></span><br><span class="line">                          clazz.getConstructor(type);</span><br><span class="line">                          Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;</span><br><span class="line">                          <span class="keyword">if</span> (wrappers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                              cachedWrapperClasses = <span class="keyword">new</span> ConcurrentHashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">                              wrappers = cachedWrapperClasses;</span><br><span class="line">                          &#125;</span><br><span class="line">                          wrappers.add(clazz);</span><br><span class="line">                      &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                          <span class="comment">//不是包装类时</span></span><br><span class="line">                          clazz.getConstructor();</span><br><span class="line">                          <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                              name = findAnnotationName(clazz);</span><br><span class="line">                              <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                                  <span class="keyword">if</span> (clazz.getSimpleName().length() &gt; type.getSimpleName().length()</span><br><span class="line">                                          &amp;&amp; clazz.getSimpleName().endsWith(type.getSimpleName())) &#123;</span><br><span class="line">                                      name = clazz.getSimpleName().substring(<span class="number">0</span>, clazz.getSimpleName().length() - type.getSimpleName().length()).toLowerCase();</span><br><span class="line">                                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No such extension name for the class "</span> + clazz.getName() + <span class="string">" in the config "</span> + url);</span><br><span class="line">                                  &#125;</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">                          String[] names = NAME_SEPARATOR.split(name);</span><br><span class="line">                          <span class="keyword">if</span> (names != <span class="keyword">null</span> &amp;&amp; names.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                              <span class="comment">//如果带有自动激活注解，则说明是自动激活类，缓存到...</span></span><br><span class="line">                              Activate activate = clazz.getAnnotation(Activate<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                              <span class="keyword">if</span> (activate != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                  cachedActivates.put(names[<span class="number">0</span>], activate);</span><br><span class="line">                              &#125;</span><br><span class="line">                              <span class="keyword">for</span> (String n : names) &#123;</span><br><span class="line">                                  <span class="keyword">if</span> (!cachedNames.containsKey(clazz)) &#123;</span><br><span class="line">                                      cachedNames.put(clazz, n);</span><br><span class="line">                                  &#125;</span><br><span class="line">                                  Class&lt;?&gt; c = extensionClasses.get(n);</span><br><span class="line">                                  <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                      extensionClasses.put(n, clazz);</span><br><span class="line">                                  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != clazz) &#123;</span><br><span class="line">                                                 ...</span><br><span class="line">                                  &#125;</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;...</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="comment">// end of while read lines</span></span><br><span class="line">  &#125; <span class="comment">// end of while urls</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当没有自适应类时，需要自动拼装自适应类，并编译。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;</span><br><span class="line">   <span class="comment">//生成自适应类代码</span></span><br><span class="line">   <span class="comment">//自适应方法的内容，会根据type方法上@Adaptive的属性生成</span></span><br><span class="line">   String code = createAdaptiveExtensionClassCode();</span><br><span class="line">   ClassLoader classLoader = findClassLoader();</span><br><span class="line">   com.alibaba.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>()</span>;</span><br><span class="line">   <span class="comment">//编译</span></span><br><span class="line">   <span class="keyword">return</span> compiler.compile(code, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建类后，需要注入属性，<code>injectExtension</code>方法负责其工作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">injectExtension</span><span class="params">(T instance)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (objectFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (method.getName().startsWith(<span class="string">"set"</span>)</span><br><span class="line">                  &amp;&amp; method.getParameterTypes().length == <span class="number">1</span></span><br><span class="line">                  &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">              Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  String property = method.getName().length() &gt; <span class="number">3</span> ? method.getName().substring(<span class="number">3</span>, <span class="number">4</span>).toLowerCase() + method.getName().substring(<span class="number">4</span>) : <span class="string">""</span>;</span><br><span class="line">                  <span class="comment">// 获取自适应的属性</span></span><br><span class="line">                  Object object = objectFactory.getExtension(pt, property);</span><br><span class="line">                 <span class="comment">// 注入属性</span></span><br><span class="line">                  <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      method.invoke(instance, object);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; ...</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getExtension"><a href="#getExtension" class="headerlink" title="getExtension"></a>getExtension</h3><p>在<code>getAdapativeExtension</code>执行中，已经加载了所有的<code>type</code>拓展类，初始化了<code>type</code>对应的<code>ExtensionLoader</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//loadFile中加载的所有拓展类</span></span><br><span class="line">   Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">   <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> findException(name);</span><br><span class="line">   &#125;</span><br><span class="line">   T instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">   <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//创建对象</span></span><br><span class="line">       EXTENSION_INSTANCES.putIfAbsent(clazz, (T) clazz.newInstance());</span><br><span class="line">       instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//注入属性</span></span><br><span class="line">   injectExtension(instance);</span><br><span class="line">   <span class="comment">//如果有包装类，进行包装</span></span><br><span class="line">   Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line">   <span class="keyword">if</span> (wrapperClasses != <span class="keyword">null</span> &amp;&amp; !wrapperClasses.isEmpty()) &#123;</span><br><span class="line">       <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">           instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getActivateExtension"><a href="#getActivateExtension" class="headerlink" title="getActivateExtension"></a>getActivateExtension</h3><p>根据条件获取当前扩展可自动激活的实现。比如<code>Filter</code>、<code>InvokerListener</code>、<code>ExporterListener</code>。<br><code>getActivateExtension</code>有多个重载函数，最主要的实现在下面这个函数中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getActivateExtension</span><span class="params">(URL url, String[] values, String group)</span> </span>&#123;</span><br><span class="line">   List&lt;T&gt; exts = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">   List&lt;String&gt; names = values == <span class="keyword">null</span> ? <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">0</span>) : Arrays.asList(values);</span><br><span class="line">   <span class="keyword">if</span> (!names.contains(Constants.REMOVE_VALUE_PREFIX + Constants.DEFAULT_KEY)) &#123;</span><br><span class="line">       getExtensionClasses();</span><br><span class="line">       <span class="keyword">for</span> (Map.Entry&lt;String, Activate&gt; entry : cachedActivates.entrySet()) &#123;</span><br><span class="line">           String name = entry.getKey();</span><br><span class="line">           Activate activate = entry.getValue();</span><br><span class="line">           <span class="keyword">if</span> (isMatchGroup(group, activate.group())) &#123;</span><br><span class="line">               T ext = getExtension(name);</span><br><span class="line">               <span class="keyword">if</span> (!names.contains(name)</span><br><span class="line">                       &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)</span><br><span class="line">                       &amp;&amp; isActive(activate, url)) &#123;</span><br><span class="line">                   exts.add(ext);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       Collections.sort(exts, ActivateComparator.COMPARATOR);</span><br><span class="line">   &#125;</span><br><span class="line">   List&lt;T&gt; usrs = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; names.size(); i++) &#123;</span><br><span class="line">       String name = names.get(i);</span><br><span class="line">       <span class="keyword">if</span> (!name.startsWith(Constants.REMOVE_VALUE_PREFIX)</span><br><span class="line">               &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)) &#123;</span><br><span class="line">           <span class="keyword">if</span> (Constants.DEFAULT_KEY.equals(name)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!usrs.isEmpty()) &#123;</span><br><span class="line">                   exts.addAll(<span class="number">0</span>, usrs);</span><br><span class="line">                   usrs.clear();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               T ext = getExtension(name);</span><br><span class="line">               usrs.add(ext);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!usrs.isEmpty()) &#123;</span><br><span class="line">       exts.addAll(usrs);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> exts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>讲完它的原理，来看几个源码中的例子更好的理解下：</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2018/04/21/rpc/dubbo/1.dubbo%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.png">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/21/rpc/dubbo/1.dubbo%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">Dubbo</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-21 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-21T00:00:00+08:00">2018-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-13 19:06:41" itemprop="dateModified" datetime="2020-02-13T19:06:41+08:00">2020-02-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dubbo/" itemprop="url" rel="index">
                    <span itemprop="name">dubbo</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h1><p>Dubbo是阿里开源的一套基于Java的高性能RPC框架。经常听人提起它，正好前段时间看了下新美大的RPC框架，因此闲暇中翻开代码来咀嚼了一番，收获颇多，也很有感触！！</p>
<p>本文主要涵盖以下内容：</p>
<ul>
<li>SPI拓展机制（IOC、AOP、自适应拓展）</li>
<li>服务暴露解析</li>
<li>服务引用解析</li>
<li>服务调用过程解析（请求、响应、编解码）</li>
<li>服务发布订阅与通知</li>
<li>组件解析与比较(Cluster、LoadBalancer、Directory、Router、Registry)</li>
</ul>
<p>其中，会大量结合源码讲解整个过程！</p>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul>
<li><strong>SPI</strong>（<code>IOC</code>、<code>AOP</code>）✅</li>
<li><strong>执行流程</strong></li>
<li><strong>初始化过程</strong><ul>
<li><strong>服务注册、发现</strong></li>
<li><strong>服务变更</strong></li>
</ul>
</li>
<li><strong>负载均衡</strong></li>
<li><strong>服务降级</strong></li>
<li><strong>失败重试</strong></li>
<li><strong>服务监控</strong></li>
<li><strong>传输层实现</strong><ul>
<li>NettyServer</li>
<li>NettyClient</li>
<li>NettyHandler</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2018/04/12/rpc/netty/6.netty-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.png">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/12/rpc/netty/6.netty-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">Netty 内存管理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-12 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-12T00:00:00+08:00">2018-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-13 20:11:10" itemprop="dateModified" datetime="2020-02-13T20:11:10+08:00">2020-02-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/netty/" itemprop="url" rel="index">
                    <span itemprop="name">netty</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p><strong>Netty</strong>的内存管理有两部分要点：自适应内存大小算法和真实的内存管理：</p>
<p>再讲之前我们再来看看数据读取的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">  <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">  <span class="comment">// 用来分配ByteBuf内存的 PooledByteBufAllocator</span></span><br><span class="line">  <span class="keyword">final</span> ByteBufAllocator allocator = config.getAllocator();</span><br><span class="line">  <span class="comment">// 用来决定分配多大的 ByteBuf (自适应缓存分配大小)，以防止缓存分配过多或过少</span></span><br><span class="line">  <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();</span><br><span class="line">  allocHandle.reset(config);</span><br><span class="line">  ByteBuf byteBuf = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">boolean</span> close = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// allocator.ioBuffer(allocHandle.guess());</span></span><br><span class="line">      byteBuf = allocHandle.allocate(allocator);</span><br><span class="line">      <span class="comment">// 在读取的过程中，alloHandle会记录读取了多少字节</span></span><br><span class="line">      allocHandle.lastBytesRead(doReadBytes(byteBuf));</span><br><span class="line">      <span class="keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// nothing was read. release the buffer.</span></span><br><span class="line">          byteBuf.release();</span><br><span class="line">          byteBuf = <span class="keyword">null</span>;</span><br><span class="line">          close = allocHandle.lastBytesRead() &lt; <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      allocHandle.incMessagesRead(<span class="number">1</span>);</span><br><span class="line">      readPending = <span class="keyword">false</span>;</span><br><span class="line">      pipeline.fireChannelRead(byteBuf);</span><br><span class="line">      byteBuf = <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line">  <span class="comment">// 跟据本次读取的字节，计算下一次应该分配的ByteBuf大小</span></span><br><span class="line">  allocHandle.readComplete();</span><br><span class="line">  pipeline.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (close) &#123;</span><br><span class="line">      closeOnRead(pipeline);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到两个在内存分配管理上比较重要的<code>Allocator</code>、<code>AllocHandle</code>。</p>
<p><strong>Allocator</strong> 是用来分配内存的，而<strong>AllocHandle</strong>则是用来辅助分配内存的，决定在不知道内存空间有多大的情况下预分配多大的<strong>ByteBuf</strong>。</p>
<h2 id="AllocHandle-决定分配ByteBuf大小"><a href="#AllocHandle-决定分配ByteBuf大小" class="headerlink" title="AllocHandle(决定分配ByteBuf大小)"></a>AllocHandle(决定分配ByteBuf大小)</h2><p><strong>AllocHandle</strong>，其实现有多种。这里，重点来看<code>AdaptiveRecvByteBufAllocator.HandleImpl</code>：</p>
<p>在<code>AdaptiveRecvByteBufAllocator</code>内部会维护以下信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化时的配置</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MINIMUM = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAXIMUM = <span class="number">65536</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index的自增值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INDEX_INCREMENT = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// index自建值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INDEX_DECREMENT = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SIZE_TABLE 用来存放分配大小的尺度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] SIZE_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据最小配置大小得到的在SIZE_TABLE中的下标</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> minIndex;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxIndex;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> initial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">   List&lt;Integer&gt; sizeTable = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">16</span>; i &lt; <span class="number">512</span>; i += <span class="number">16</span>) &#123;</span><br><span class="line">       sizeTable.add(i);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">512</span>; i &gt; <span class="number">0</span>; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">       sizeTable.add(i);</span><br><span class="line">   &#125;</span><br><span class="line">   SIZE_TABLE = <span class="keyword">new</span> <span class="keyword">int</span>[sizeTable.size()];</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE_TABLE.length; i ++) &#123;</span><br><span class="line">       SIZE_TABLE[i] = sizeTable.get(i);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 初始化完成后，sizeTable : 16, 32, 48, 64, ..., 496,512,1024,2048...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在读取数据的时候，<code>alloHandle</code>会记录一次读取总共读取了多少字节（<code>lastBytesRead</code>），完成读取后会调用<code>readComplete</code>会计算下次应该分配多大内存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  record(totalBytesRead());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">record</span><span class="params">(<span class="keyword">int</span> actualReadBytes)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 是否比（当前缩容后）的大小还要小</span></span><br><span class="line">  <span class="keyword">if</span> (actualReadBytes &lt;= SIZE_TABLE[Math.max(<span class="number">0</span>, index - INDEX_DECREMENT - <span class="number">1</span>)]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (decreaseNow) &#123;</span><br><span class="line">          index = Math.max(index - INDEX_DECREMENT, minIndex);</span><br><span class="line">          nextReceiveBufferSize = SIZE_TABLE[index];</span><br><span class="line">          decreaseNow = <span class="keyword">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          decreaseNow = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 是否比当前扩容后的大小还要大      </span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actualReadBytes &gt;= nextReceiveBufferSize) &#123;</span><br><span class="line">      index = Math.min(index + INDEX_INCREMENT, maxIndex);</span><br><span class="line">      nextReceiveBufferSize = SIZE_TABLE[index];</span><br><span class="line">      decreaseNow = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当决定分配内存大小的时候调用的是<code>guess</code>方法，可以看出正式上一次计算出的大小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">guess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nextReceiveBufferSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Allocator-内存分配"><a href="#Allocator-内存分配" class="headerlink" title="Allocator 内存分配"></a>Allocator 内存分配</h2><p>Allocator的内存分配实现有以下两个：<br><img src="/media/15283341055629.jpg" alt=""></p>
<ul>
<li><strong>PooledByteBufAllocator：</strong>基于内存池的字节缓冲区分配器</li>
<li><strong>UnpooledByteBufAllocator：</strong>普通的字节缓存区分配器</li>
</ul>
<p>##TODO</p>
<ul>
<li><a href="https://vinoit.me/2017/06/23/netty-memory-recycle/" target="_blank" rel="noopener">非内存池的内存回收</a></li>
<li>内存池对象分配</li>
<li>Netty之有效规避内存泄漏</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2018/04/11/rpc/netty/5.netty-server/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.png">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/11/rpc/netty/5.netty-server/" class="post-title-link" itemprop="url">Netty 服务接收请求&响应</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-11 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-11T00:00:00+08:00">2018-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-13 19:06:06" itemprop="dateModified" datetime="2020-02-13T19:06:06+08:00">2020-02-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/netty/" itemprop="url" rel="index">
                    <span itemprop="name">netty</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="服务端创建连接并响应请求"><a href="#服务端创建连接并响应请求" class="headerlink" title="服务端创建连接并响应请求"></a>服务端创建连接并响应请求</h1><p>客户端与服务端通讯必须先创建连接。<br>在前文介绍服务端初始化的时候说道初始化的时候会向<code>boss</code>线程注册一个<code>OP_ACCEPT</code>事件。客户端请求链接时即会触发此事件。当<strong>boss线程池</strong>中的<code>NioEventLoop</code>在循环的时候检测到此事件时，会触发<code>NioMessageUnsafe.read</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">  <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">  <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</span><br><span class="line">  allocHandle.reset(config);</span><br><span class="line">  <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line">  Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">          <span class="comment">// NioServerSocketChannel.doReadMessage</span></span><br><span class="line">          <span class="keyword">int</span> localRead = doReadMessages(readBuf);</span><br><span class="line">          <span class="keyword">if</span> (localRead == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (localRead &lt; <span class="number">0</span>) &#123;</span><br><span class="line">              closed = <span class="keyword">true</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          allocHandle.incMessagesRead(localRead);</span><br><span class="line">      &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      exception = t;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> size = readBuf.size();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">      readPending = <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 触发 ChannelHandler的 channelRead方法，经过LoggingHandler最后到ServerBootstrapAcceptor</span></span><br><span class="line">      pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line">  &#125;</span><br><span class="line">  readBuf.clear();</span><br><span class="line">  allocHandle.readComplete();</span><br><span class="line">  pipeline.fireChannelReadComplete();</span><br><span class="line">  <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">      closed = closeOnReadError(exception);</span><br><span class="line">      pipeline.fireExceptionCaught(exception);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">      inputShutdown = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (isOpen()) &#123;</span><br><span class="line">          close(voidPromise());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="comment">// 从ServerSocketChannel.accept一个SocketChannel</span></span><br><span class="line">   SocketChannel ch = SocketUtils.accept(javaChannel());</span><br><span class="line">   <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</span><br><span class="line">       buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和<code>Client</code>端的不同之处即在于<code>doReadMessages</code>方法。此处调用的是<code>NioServerSocketChannel.doReadMessage</code>。<br>其调用的是原生<code>ServerSocketChannel.accept</code>方法来获取一个<code>SocektChannel</code>然后封装在<code>NioSocetChannel</code>中，并将其传递到<strong>ServerBootstrapAcceptor</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Channel child = (Channel) msg;</span><br><span class="line">  <span class="comment">// 将初始化时设置的childHandler 加入到pipeline 中</span></span><br><span class="line">  child.pipeline().addLast(childHandler);</span><br><span class="line">  setChannelOptions(child, childOptions, logger);</span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</span><br><span class="line">      child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 往reactor线程池中注入，即跟某个`NioEventLoop`绑定。</span></span><br><span class="line">      childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                  forceClose(child, future.cause());</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      forceClose(child, t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，将初始化时配置的<code>childHandler</code>加到<code>Channel</code>的<code>pipeline</code>中，然后将<code>Channel</code>注册到某个 <strong>Reactor线程</strong> 上，然后开始监听<code>OP_READ</code>读事件。<br>此后与客户端的通讯工作即会在<strong>Reactor线程</strong>中进行，其过程与<code>Client</code>中一致，因此这里不再复述。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2018/04/09/rpc/netty/4.netty-client/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.png">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/09/rpc/netty/4.netty-client/" class="post-title-link" itemprop="url">Netty 客户端请求&响应</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-09 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-09T00:00:00+08:00">2018-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-13 19:06:01" itemprop="dateModified" datetime="2020-02-13T19:06:01+08:00">2020-02-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/netty/" itemprop="url" rel="index">
                    <span itemprop="name">netty</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="客户端请求发送与获取响应"><a href="#客户端请求发送与获取响应" class="headerlink" title="客户端请求发送与获取响应"></a>客户端请求发送与获取响应</h1><p>在<code>Netty</code>里，发送请求的过程可以分为两步：1. 将请求写到缓存队列中，2.将缓存队列中的请求进行 <strong>flush</strong> —– 调用原生的<code>SocketChannel</code>进行发送。</p>
<p><strong>在客户端初始化时</strong>，讲到客户端的<code>Channel</code>会在<code>Selector</code>上注册<code>OP_READ</code>操作，当有服务端响应结果时，则触发<code>OP_READ</code>事件。</p>
<h2 id="请求发送"><a href="#请求发送" class="headerlink" title="请求发送"></a>请求发送</h2><p>首先来看发送请求的过程：<strong>SocketChannel</strong> 有两个方法用于发送请求，<code>write</code>和<code>writeAndFlush</code>，其中<code>write</code>用于将请求<code>ByteBuf</code>放入发送队列中，<code>writeAndFlush</code>则将请求发送到队列中，并把发送队列中的数据发送出去。这里以<code>writeAndFlush</code>来讲解整个过程<br>调用<code>writeAndFlush</code>方法最终会调用<code>AbstractChannelHandlerContext.write</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, <span class="keyword">boolean</span> flush, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">   AbstractChannelHandlerContext next = findContextOutbound();</span><br><span class="line">   <span class="keyword">final</span> Object m = pipeline.touch(msg, next);</span><br><span class="line">   EventExecutor executor = next.executor();</span><br><span class="line">   <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">       <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">           next.invokeWriteAndFlush(m, promise);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           next.invokeWrite(m, promise);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       AbstractWriteTask task;</span><br><span class="line">       <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">           task = WriteAndFlushTask.newInstance(next, m, promise);</span><br><span class="line">       &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">           task = WriteTask.newInstance(next, m, promise);</span><br><span class="line">       &#125;</span><br><span class="line">       safeExecute(executor, task, promise, m);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其判断发起请求操作 <code>channel</code> 的对应的线程上下文中，不是则创建任务并将其扔进<code>EventLoop</code>的任务队列中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeWriteAndFlush</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">       invokeWrite0(msg, promise);</span><br><span class="line">       invokeFlush0();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       writeAndFlush(msg, promise);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeWrite0</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">   ((ChannelOutboundHandler) handler()).write(<span class="keyword">this</span>, msg, promise);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeFlush0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ((ChannelOutboundHandler) handler()).flush(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就可以看到<code>invokeWrite0</code>和<code>invokeFlush0</code>两个过程：</p>
<ol>
<li>invokeWrite0调用链如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">HeadContext.write</span><br><span class="line">-&gt; AbstractChannel.unsafe.write</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">  ChannelOutboundBuffer outboundBuffer = <span class="keyword">this</span>.outboundBuffer;</span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  msg = filterOutboundMessage(msg);</span><br><span class="line">  size = pipeline.estimatorHandle().size(msg);</span><br><span class="line">  <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  outboundBuffer.addMessage(msg, size, promise);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMessage</span><span class="params">(Object msg, <span class="keyword">int</span> size, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">   Entry entry = Entry.newInstance(msg, size, total(msg), promise);</span><br><span class="line">   <span class="keyword">if</span> (tailEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">       flushedEntry = <span class="keyword">null</span>;</span><br><span class="line">       tailEntry = entry;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       Entry tail = tailEntry;</span><br><span class="line">       tail.next = entry;</span><br><span class="line">       tailEntry = entry;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (unflushedEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">       unflushedEntry = entry;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终可以看到，write的过程是将<code>msg</code>包装进<code>Entry</code>然后加到<code>outboundBuffer</code>中，并没有做真正的发送。</p>
<p>在看<code>flush</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ChannelOutboundBuffer outboundBuffer = <span class="keyword">this</span>.outboundBuffer;</span><br><span class="line">  <span class="keyword">if</span> (outboundBuffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将之前加进去的数据设置为flushed，可以开始发送</span></span><br><span class="line">  outboundBuffer.addFlush();</span><br><span class="line">  <span class="comment">// 将可以发送的消息进行发送</span></span><br><span class="line">  flush0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flush方法先讲<code>outboundBuffer</code>之前<code>add</code>的消息标记为已发送，然后调用<strong>flush0</strong>进行真正的发送。</p>
<h2 id="获取响应"><a href="#获取响应" class="headerlink" title="获取响应"></a>获取响应</h2><p>当 <strong>Server</strong> 端接收到请求并处理后返回结果给<strong>Client</strong>端。<strong>Client</strong>端的<code>NioEventLoop.Selector</code>会告诉客户端数据已准备好可读触发<strong>unsafe.read</strong>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">  <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">  <span class="keyword">final</span> ByteBufAllocator allocator = config.getAllocator();</span><br><span class="line">  <span class="comment">// ByteBuf 内存分配器（内存分配策略是Netty里值得深入理解的一块，后文中我们将单独领出来说）</span></span><br><span class="line">  <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();</span><br><span class="line">  allocHandle.reset(config);</span><br><span class="line">  ByteBuf byteBuf = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">boolean</span> close = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">      byteBuf = allocHandle.allocate(allocator);</span><br><span class="line">      <span class="comment">// 从SocketChannel中读取数据到byteBuf中</span></span><br><span class="line">      allocHandle.lastBytesRead(doReadBytes(byteBuf));</span><br><span class="line">      <span class="keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          byteBuf.release();</span><br><span class="line">          byteBuf = <span class="keyword">null</span>;</span><br><span class="line">          close = allocHandle.lastBytesRead() &lt; <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      allocHandle.incMessagesRead(<span class="number">1</span>);</span><br><span class="line">      readPending = <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 触发数据读取事件，调用channelHanlder的channelRead方法</span></span><br><span class="line">      pipeline.fireChannelRead(byteBuf);</span><br><span class="line">      byteBuf = <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line">  allocHandle.readComplete();</span><br><span class="line">  <span class="comment">// 调用channelHandler的channelReadComplete方法</span></span><br><span class="line">  pipeline.fireChannelReadComplete();</span><br><span class="line">  <span class="keyword">if</span> (close) &#123;</span><br><span class="line">      closeOnRead(pipeline);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到大体流程是，先调用<strong>allocHandle</strong>分配一个<strong>ByteBuf</strong>，然后从<code>ScoketChannel</code>中读取数据，触发<strong>pipeline.fireChannelRead</strong>（执行<code>channelHandler</code>的<code>channelRead</code>方法）方法，读取完成后再执行<strong>pipeline.fireChannelReadComplete</strong>方法（执行<code>channelHandler</code>的<code>channelRead</code>方法）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zamperini"
      src="/images/avator.png">
  <p class="site-author-name" itemprop="name">Zamperini</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/DorgenJones" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;DorgenJones" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:dblpfilter@163.com" title="E-Mail → mailto:dblpfilter@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/1938368215" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;1938368215" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zamperini</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
