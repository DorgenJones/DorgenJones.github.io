<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.3">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.3" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Hexo, NexT" />


<meta property="og:type" content="website">
<meta property="og:title" content="Zamperini">
<meta property="og:url" content="https://dorgenjones.github.io/page/4/index.html">
<meta property="og:site_name" content="Zamperini">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zamperini">
<meta name="twitter:card" content="summary">






  <link rel="canonical" href="https://dorgenjones.github.io/page/4/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>Zamperini</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Zamperini</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2018/04/07/rpc/netty/2.netty%E5%88%9D%E5%A7%8B%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/07/rpc/netty/2.netty%E5%88%9D%E5%A7%8B%E5%8C%96/" itemprop="url">Netty 初始化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-07T00:00:00+08:00">2018-04-07</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/netty/" itemprop="url" rel="index"><span itemprop="name">netty</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>对于<code>Client</code>的初始化过程，本章主要会介绍怎样初始化<code>ChannelPipeline</code>以及与<code>Server</code>建立连接。<br><code>Server</code>初始化过程比<code>Client</code>端复杂一些，它分为两部分，分为<code>Acceptor</code>的处理链初始化过程和<code>Reactor</code>链的初始化过程。绑定端口提供服务的过程。</p>
<h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><p>首先来看<code>Client</code>的初始化代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置事件组，即线程组，会在构造函数中创建线程，默认情况下他会创建 CPU数*2个 线程</span></span><br><span class="line">EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// Client端启动辅助类</span></span><br><span class="line">  Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">  <span class="comment">// 设置Client端线程池，一般一个线程负责至少一个Channel</span></span><br><span class="line">  b.group(group)</span><br><span class="line">   <span class="comment">// 设置 Client 的 SocketChannel，也可以选择 像 EpollSocketChannel这种！</span></span><br><span class="line">   .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">          //添加配置项</span></span><br><span class="line"><span class="class">   .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">TCP_NODELAY</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">          // 设置 <span class="title">ChannelHandler</span>，这里的 <span class="title">ChannelInitializer</span>不是最终最终编制在 <span class="title">Pipeline</span>上的<span class="title">ChannelHandler</span>，而只是起一个初始化作用的<span class="title">Handler</span>，后文中会细说</span></span><br><span class="line"><span class="class">   .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">           ChannelPipeline p = ch.pipeline();</span><br><span class="line">           <span class="comment">//在其中添加业务定制的Handler</span></span><br><span class="line">           p.addLast(<span class="keyword">new</span> EchoClientHandler());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发起连接</span></span><br><span class="line">  ChannelFuture f = b.connect(HOST, PORT).sync();</span><br><span class="line">  <span class="comment">// 阻塞等待，一直等到链接关闭</span></span><br><span class="line">  <span class="comment">// Wait until the connection is closed.</span></span><br><span class="line">  f.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  group.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Bootstrap</strong>类是<code>Client</code>端的启动辅助类。<br>整个过程中，分为两大步，第一步进行参数设置，设置<strong>Bootstrap</strong>的参数，第二步则是发起连接。<br>在<strong>Bootstrap</strong>参数设置里，可以看到业务方配置了<code>group</code>（客户端事件线程池<code>EventLoopGroup</code>，后面单领出来讲解）、<code>Channel</code>的类型（比如对于<code>NIO</code>和<code>Epoll</code>Channel）和 <code>ChannelHandler</code>（这里的<strong>ChannelInitializer</strong> 是给业务放提供的入口，让业务将自定义的<code>ChannelHandler</code>编制进<code>Pipeline</code>）。</p>
<p><strong>发起连接：</strong> 利用设置的参数进行初始化处理链，注册事件、开启事件线程、发起连接的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Bootstrap.connect</span><br><span class="line">--&gt; Bootstrap.doResolveAndConnect</span><br><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doResolveAndConnect</span><span class="params">(<span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 初始化Channel，并将Channel注册到事件线程中</span></span><br><span class="line">   <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">   <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">   <span class="comment">// 解析地址 并创建连接</span></span><br><span class="line">   <span class="keyword">return</span> doResolveAndConnect0(channel, remoteAddress, localAddress, channel.newPromise());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>InitAndRegister</code>方法主要是初始化<code>Channel</code>并与某个<code>EventLoop</code>绑定。执行<code>doResolveAndConnect0</code>方法用于解析地址并创建连接。下面就来分别详细解析这两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Channel channel = <span class="keyword">null</span>;</span><br><span class="line">   channel =</span><br><span class="line">   <span class="comment">// 根据之前设置的Channel类型实例化一个Channel然后根绝配置的option设置参数</span></span><br><span class="line">   channelFactory.newChannel();</span><br><span class="line">   <span class="comment">//参数设置，options</span></span><br><span class="line">   init(channel);</span><br><span class="line">   <span class="comment">// 将channel和一个EventLoop绑定</span></span><br><span class="line">   ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">   <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>register</code>方法最终会调用<code>MultithreadEventLoopGroup.register</code>方法，而其只是按轮询的方式选择一个<code>SingleThreadEventLoop</code>执行<code>register</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ChannelFuture MultithreadEventExecutorGroup.register(Channel channel) &#123;</span><br><span class="line">   <span class="keyword">return</span> next().register(channel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//将Channel包装进ChannelPromise中，其主作用主要起一个回调的作用，比如当完成连接后会触发相应的监听器</span></span><br><span class="line">   <span class="keyword">return</span> register(<span class="keyword">new</span> DefaultChannelPromise(channel, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> ChannelFuture SingleThreadEventLoop.register(<span class="keyword">final</span> ChannelPromise promise) &#123;</span><br><span class="line">   ObjectUtil.checkNotNull(promise, <span class="string">"promise"</span>);</span><br><span class="line">promise.channel().unsafe().register(<span class="keyword">this</span>, promise);</span><br><span class="line">   <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>register</code>方法最终会调用<code>Channel</code>里的<code>Unsafe</code>（<strong>Unsafe</strong>是操作底层）的<code>register</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">  AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line">  <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">      register0(promise);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              register0(promise);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先给<code>Channel</code>赋一个<code>EventLoop</code>，因为是启动线程不是该<code>EventLoop</code>，所以将<code>register</code>操作丢给该<code>EventLoop</code>执行。<br>在<code>SingleThreadEventLoop.execute</code>方法里：<br>可以看到当前线程没启动的时候会开启该线程，并将任务丢进<code>EventLoop</code>的任务队列中，<code>EventLoop</code>线程执行时从任务队列中获取任务执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">   <span class="keyword">if</span> (inEventLoop) &#123;</span><br><span class="line">       addTask(task);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 开启线程</span></span><br><span class="line">       startThread();</span><br><span class="line">       <span class="comment">// 将注册任务加到任务队列中</span></span><br><span class="line">       addTask(task);</span><br><span class="line">       <span class="keyword">if</span> (isShutdown() &amp;&amp; removeTask(task)) &#123;</span><br><span class="line">           reject();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class="line">       wakeup(inEventLoop);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>regsiter0</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">  doRegister();</span><br><span class="line">  neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">  registered = <span class="keyword">true</span>;</span><br><span class="line">  safeSetSuccess(promise);</span><br><span class="line">  <span class="comment">// 触发 pipleline的编制，将业务自定义的handler加入到pipeline中</span></span><br><span class="line">  pipeline.fireChannelRegistered();</span><br><span class="line">  <span class="comment">// 当channel重新注册的时候，已经连接</span></span><br><span class="line">  <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">          <span class="comment">//触发 激活channel Active事件</span></span><br><span class="line">          pipeline.fireChannelActive();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">          <span class="comment">//</span></span><br><span class="line">          beginRead();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="comment">// 真正的注册，将channel注册到 EventLoop中的Selector上</span></span><br><span class="line">   selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成初始化处理链后，<strong>EchoClient</strong>的处理链如下：<br><img src="/media/15282181022734.jpg" alt=""></p>
<p>完成注册后，则开始创建连接（<code>Bootstrap.doConnect</code>），</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> Bootstrap.doConnect(</span><br><span class="line">       <span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise connectPromise) &#123;</span><br><span class="line">   <span class="comment">// 在register之后才会执行，排在register0任务之后</span></span><br><span class="line">   <span class="keyword">final</span> Channel channel = connectPromise.channel();</span><br><span class="line">   channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (localAddress == <span class="keyword">null</span>) &#123;</span><br><span class="line">               channel.connect(remoteAddress, connectPromise);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               channel.connect(remoteAddress, localAddress, connectPromise);</span><br><span class="line">           &#125;</span><br><span class="line">           connectPromise.addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到最终是会执行<code>Channel.connect</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> pipeline.connect(remoteAddress, promise);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture DefaultChannelPipeline.connect(SocketAddress remoteAddress, ChannelPromise promise) &#123;</span><br><span class="line">   <span class="keyword">return</span> tail.connect(remoteAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Channel.connect</code>方法则开始执行处理链，可以看到其从<code>TailContext</code>往前执行，执行<code>ChannelOutboundHandler.connect</code>方法，最终会执行<code>HeadContext.connect</code>方法。而其调用<code>Unsafe.connect</code>方法进行连接。最终调用原生<code>SocketChannel.connect</code>方法进行连接，连接成功后设置<code>Promise</code>状态通知监听者并执行<code>pipeline.fireChannelActive</code>。</p>
<p><code>Pipeline.fireChannelActive</code>是由<code>HeadContext</code>往前传递的，其会触发<code>EchoClientHandler</code>的<code>channelActive</code>方法，然后再会触发<code>readIfAutoRead</code>方法，将<code>NioSocketChannel</code>中的<code>selectionKey</code>设置为<code>SelectionKey.OP_READ</code>(<strong>对于ServerSocketChannel则设置为OP_ACCEPT</strong>)，以监听网络读事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HeadContext-&gt;EchoClientHandler: channelActive</span><br><span class="line">EchoClientHandler-&gt;EchoClientHandler:writeAndFlush(发送第一个消息)</span><br><span class="line">HeadContext-&gt;HeadContext:readIfAutoRead(设置读事件)</span><br></pre></td></tr></table></figure>
<p>到此<code>Client</code>初始化的过程就讲完了，下面我们将来讲解服务端内容。</p>
<h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><p>还是以<code>Echo</code>为例来讲解此过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// acceptor事件组</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//reactor事件组</span></span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">  b.group(bossGroup, workerGroup)</span><br><span class="line">    <span class="comment">//设置 ServerSocketChannel</span></span><br><span class="line">   .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">   .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 100)</span></span><br><span class="line"><span class="class">    // 在 <span class="title">Acceptor</span> 的处理链上添加 <span class="title">Handler</span></span></span><br><span class="line"><span class="class">   .<span class="title">handler</span>(<span class="title">new</span> <span class="title">LoggingHandler</span>(<span class="title">LogLevel</span>.<span class="title">INFO</span>))</span></span><br><span class="line"><span class="class">   // 设置 <span class="title">reactor</span>的处理链</span></span><br><span class="line"><span class="class">   .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">           ChannelPipeline p = ch.pipeline();</span><br><span class="line">           p.addLast(<span class="keyword">new</span> EchoServerHandler());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">  <span class="comment">// 绑定接口提供服务</span></span><br><span class="line">  ChannelFuture f = b.bind(PORT).sync();</span><br><span class="line">  f.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  bossGroup.shutdownGracefully();</span><br><span class="line">  workerGroup.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ServerBootstrap</strong> 是<code>Server</code>端的辅助启动类。用户使用的时候会配置 <code>Acceptor</code>和<code>Reactor</code>的事件线程组（<code>boosGroup</code>的线程个数和监听端口数相等）。设置<code>ServerSocketChannel</code>类型，设置参数<code>Channel</code>的参数<code>option</code>，然后在<code>Acceptor</code>的处理链上中添加<code>Handler</code>。最后<code>childHandler</code>配置<code>Reactor</code>处理链，再其上添加业务方定制的<code>Handler</code>。</p>
<p><code>bind</code>方法最终执行的是<code>doBind</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">   <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">   <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">   ChannelPromise promise = channel.newPromise();</span><br><span class="line">   <span class="comment">//绑定端口，开启服务</span></span><br><span class="line">   doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">   <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Channel channel = channelFactory.newChannel();</span><br><span class="line">   <span class="comment">//调用 ServerBootStrap.init</span></span><br><span class="line">   init(channel);</span><br><span class="line">   <span class="comment">// 将SeverBootStrap注册到线程池上，然后监听 OP_ACCEPT事件</span></span><br><span class="line">   ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">   <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在讲<code>Client</code>的初始化过程中，解释了<code>initAndRegister</code>的作用，实例化<code>SocektChannel</code>，并将其与一个<code>EventLoop</code>进行绑定，并将其注册到<code>EventLoop</code>的<code>Selector</code>上。这里，对于<code>ServerSocketChannel</code>会有所不同：<code>init</code>方法会调用<code>ServerBootStrap</code>的<code>init</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// ServerSocketChannel的pipeline</span></span><br><span class="line">   ChannelPipeline p = channel.pipeline();</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">   <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">   p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">           <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">           <span class="comment">// 将业务配置的channel加到 pipeline中</span></span><br><span class="line">           ChannelHandler handler = config.handler();</span><br><span class="line">           <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">               pipeline.addLast(handler);</span><br><span class="line">           &#125;</span><br><span class="line">           ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   <span class="comment">// ServerBootstrapAcceptor 在acceptor与reactor之间衔接</span></span><br><span class="line">                   pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                           ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其主要是在 <code>ServerSocketChannel</code> 的处理链上加上添加 <code>ChannelHandler</code>，包括业务方配置的 <code>LoggingHandler</code> 和 <strong>ServerBootstrapAcceptor</strong>（<strong>Acceptor</strong>，负责接收请求，然后把请求丢给<code>Reactor</code>线程）。</p>
<p>初始化完成后，boss线程的处理链：<br><img src="/media/15282656793219.jpg" alt=""></p>
<p>服务端到此就完成了初始化过程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2018/04/06/rpc/netty/1.netty%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/06/rpc/netty/1.netty%E7%AE%80%E4%BB%8B/" itemprop="url">Netty 简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-06T00:00:00+08:00">2018-04-06</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/netty/" itemprop="url" rel="index"><span itemprop="name">netty</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><p><strong>Netty</strong>可以说是Java领域不得不提的高性能通讯框架，就笔者之前所学习的开源代码，只要涉及到通讯的无不涉及。比如说<code>RocketMQ</code>、<code>Dubbo</code>、<code>ZooKeeper</code>、<code>MtThrift</code>以及后面要深入理解的<code>Zuul2</code>。<br>鉴于此，笔者决定深入挖掘一下<code>Netty</code>。笔者会从以下几方面来讲解：</p>
<ul>
<li><strong>Client、Server</strong> 初始化过程</li>
<li><strong>NioEventLoop</strong> 内部执行原理</li>
<li>客户端 发送请求与接收响应过程</li>
<li>服务端 接收请求与响应请求过程</li>
<li>Netty的内存管理算法与实现</li>
<li>Epoll实现与其他实现差别</li>
</ul>
<p>章节中主要以<code>Netty.example.echo</code>为例来讲解整个过程。另外，本章侧重于<code>Netty</code>的原理讲解，而不是使用。对于使用，可以查阅 <a href="http://netty.io/" target="_blank" rel="noopener">官方文档</a>。</p>
<p><img src="/media/15276615867353.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2018/03/22/mq/7.rocketmq-%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/22/mq/7.rocketmq-%E7%89%B9%E6%80%A7/" itemprop="url">RocketMQ 特性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-22T00:00:00+08:00">2018-03-22</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/rocketmq/" itemprop="url" rel="index"><span itemprop="name">rocketmq</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="7-特性"><a href="#7-特性" class="headerlink" title="7. 特性"></a>7. 特性</h1><h2 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h2><p>RocketMQ无法保证消息的绝对顺序，即所有消息都按发送顺序被消费。因为当有N多个消费者时，可能有的消息者拿到后来的消息但由于消费的比其他消费者快导致后来的消息先消费。<br>但是使用方可以保证局部有序。</p>
<p>RocketMQ提供API，让用户自己选择消息发送到哪个Queue：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTestjjj"</span>, tags[i % tags.length], <span class="string">"KEY"</span> + i, (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">SendResult sendResult = producer.send(msg, <span class="keyword">new</span> MessageQueueSelector() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">         Integer id = (Integer) arg;</span><br><span class="line">         <span class="keyword">int</span> index = id % mqs.size();</span><br><span class="line">         <span class="keyword">return</span> mqs.get(index);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;, orderId);</span><br></pre></td></tr></table></figure>
<p>根据指定的id来选择发往哪个队列，这样同一标识的消息会按时间先后顺序发往队列。<br>再者，在<code>Consumer</code>重负载的时候，如果是顺序消息会锁住消息不然其他<code>Consumer</code>进行消费。<br>最后，当消息到达<code>Consumer</code>本地时，选择以顺序的形式进行消费<code>ConsumeMessageOrderlyService</code>，则可保证消息按时间顺序消费。</p>
<p>顺序性也带来一定的弊端：</p>
<ul>
<li>并行度会成为消息系统的瓶颈</li>
<li>更多的异常处理。消费端出现问题，就会导致真个流程阻塞。</li>
</ul>
<h2 id="消息重复"><a href="#消息重复" class="headerlink" title="消息重复"></a>消息重复</h2><p><strong>RocketMQ</strong>并不能保证消息完全不重复，如果业务方需要此属性，需要业务方自己去重。</p>
<h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><p>关于事务消息，RocketMQ官方资料给出这样一张图，描述事务消息的流程图。<br><img src="/media/15263704255897.jpg" alt=""></p>
<ol>
<li>生产者向Broker发送<code>Prepared</code>消息后返回消息偏移；（<strong>TransactionProducer</strong>）</li>
<li>本地事务执行；</li>
<li>根据本地事务的执行结果提交回滚或者提交；（<strong>EndTransactionProcessor</strong>）</li>
<li>在<code>ReputMessageService</code>中，只会将非事务消息或者提交的事务消息位移加入<code>ConsumeQueue</code>中。</li>
<li>当生产者异常时，需要<code>Broker</code>发起回查。</li>
</ol>
<p>截止到目前为止，<code>RocketMQ</code>事务消息这块的实现并不完整，缺少<code>Broker</code>到<code>Producer</code>的会查逻辑。<br>在网上看到其在<strong><code>3.x</code></strong>版本实现了其逻辑，而在<code>4.0</code>中进行了移除。</p>
<h2 id="定时消息"><a href="#定时消息" class="headerlink" title="定时消息"></a>定时消息</h2><p><code>RocketMQ</code>只支持<strong>固定精度</strong>的定时消息，不能支持任意时间精度的消息。</p>
<pre><code>1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</code></pre><p>其实现比较简单。大致过程如下：</p>
<ol>
<li>在消息存储的时候会是否判断是延迟消息则更改消息的topic为<code>SCHEDULE_TOPIC_XXXX</code>，然后根据延迟级别更改queueId，然后存储到<code>CommitLog</code>中；</li>
<li><code>ScheduleMessageService</code>服务则从<code>SCHEDULE_TOPIC_XXXX</code>出捞出延迟数据，进行消费。如果到达指定时间则发送消息，如果没到则推迟到一定时间后再消费。</li>
</ol>
<p><strong>CommitLog.putMessage</strong>中处理事务消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE<span class="comment">//</span></span><br><span class="line">  || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) &#123;</span><br><span class="line">  <span class="comment">// Delay Delivery</span></span><br><span class="line">  <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</span><br><span class="line">          msg.setDelayTimeLevel(<span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更改 topic 和 queueId</span></span><br><span class="line">      topic = ScheduleMessageService.SCHEDULE_TOPIC;</span><br><span class="line">      queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</span><br><span class="line">      MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());</span><br><span class="line">      MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));</span><br><span class="line">      msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line">      msg.setTopic(topic);</span><br><span class="line">      msg.setQueueId(queueId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ScheduleMessageService</strong>的逻辑：对于每个延迟级别分别提交<code>DeliverDelayedMessageTimerTask</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 定时发送消息</span></span><br><span class="line">   <span class="keyword">for</span> (Map.Entry&lt;Integer, Long&gt; entry : <span class="keyword">this</span>.delayLevelTable.entrySet()) &#123;</span><br><span class="line">       Integer level = entry.getKey();</span><br><span class="line">       Long timeDelay = entry.getValue();</span><br><span class="line">       Long offset = <span class="keyword">this</span>.offsetTable.get(level);</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == offset) &#123;</span><br><span class="line">           offset = <span class="number">0L</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 提交延迟提交任务</span></span><br><span class="line">       <span class="keyword">if</span> (timeDelay != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">this</span>.timer.schedule(<span class="keyword">new</span> DeliverDelayedMessageTimerTask(level, offset), FIRST_DELAY_TIME);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 定时持久化发送进度</span></span><br><span class="line">   <span class="keyword">this</span>.timer.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           ScheduleMessageService.<span class="keyword">this</span>.persist();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;, <span class="number">10000</span>, <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushDelayOffsetInterval());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任务执行时，首先从<code>SCHEDULE_TOPIC_XXXX</code>的每个级别的延时消费队列中取出offset位移之后添加的消息位置信息；<strong>其后，</strong>计算消息是否到达预期时间，如果没到则提交延时任务到指定时间点，如果到了则取出消息并将消息转变成原有的消息进行发送。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeOnTimeup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ConsumeQueue cq = ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore.findConsumeQueue(SCHEDULE_TOPIC,  delayLevel2QueueId(delayLevel));</span><br><span class="line">  <span class="keyword">long</span> failScheduleOffset = offset;</span><br><span class="line">  <span class="keyword">if</span> (cq != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//从ConsumeQueue中获取延时消息位移列表</span></span><br><span class="line">      SelectMappedBufferResult bufferCQ = cq.getIndexBuffer(<span class="keyword">this</span>.offset);</span><br><span class="line">      <span class="keyword">if</span> (bufferCQ != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">long</span> nextOffset = offset;</span><br><span class="line">              <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">for</span> (; i &lt; bufferCQ.getSize(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;</span><br><span class="line">                  <span class="keyword">long</span> offsetPy = bufferCQ.getByteBuffer().getLong();</span><br><span class="line">                  <span class="keyword">int</span> sizePy = bufferCQ.getByteBuffer().getInt();</span><br><span class="line">                  <span class="keyword">long</span> tagsCode = bufferCQ.getByteBuffer().getLong();</span><br><span class="line">                  <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">                  <span class="comment">// 应该传输的时间点</span></span><br><span class="line">                  <span class="keyword">long</span> deliverTimestamp = <span class="keyword">this</span>.correctDeliverTimestamp(now, tagsCode);</span><br><span class="line">                  nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br><span class="line">                  <span class="keyword">long</span> countdown = deliverTimestamp - now;</span><br><span class="line">                  <span class="comment">// 到达发送时间点</span></span><br><span class="line">                  <span class="keyword">if</span> (countdown &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                      <span class="comment">//取出消息</span></span><br><span class="line">                      MessageExt msgExt = ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore.lookMessageByOffset(offsetPy, sizePy);</span><br><span class="line">                      <span class="keyword">if</span> (msgExt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                          <span class="comment">// 恢复到原始发送时的消息</span></span><br><span class="line">                          MessageExtBrokerInner msgInner = <span class="keyword">this</span>.messageTimeup(msgExt);</span><br><span class="line">                          <span class="comment">// 存储正常消息后续可以被消费</span></span><br><span class="line">                          PutMessageResult putMessageResult = ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore.putMessage(msgInner);</span><br><span class="line">                          <span class="keyword">if</span> (putMessageResult != <span class="keyword">null</span> &amp;&amp; putMessageResult.getPutMessageStatus() == PutMessageStatus.PUT_OK) &#123; <span class="comment">// 发送成功</span></span><br><span class="line">                              <span class="keyword">continue</span>;</span><br><span class="line">                          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                              <span class="comment">// 存储失败后提交下一次任务</span></span><br><span class="line">                              ScheduleMessageService.<span class="keyword">this</span>.timer.schedule(<span class="keyword">new</span> DeliverDelayedMessageTimerTask(<span class="keyword">this</span>.delayLevel, nextOffset), DELAY_FOR_A_PERIOD);</span><br><span class="line">                              ScheduleMessageService.<span class="keyword">this</span>.updateOffset(<span class="keyword">this</span>.delayLevel, nextOffset);</span><br><span class="line">                              <span class="keyword">return</span>;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="comment">//没到时间</span></span><br><span class="line">                      <span class="comment">//推迟到 指定发送时间进行发送</span></span><br><span class="line">                      ScheduleMessageService.<span class="keyword">this</span>.timer.schedule(<span class="keyword">new</span> DeliverDelayedMessageTimerTask(<span class="keyword">this</span>.delayLevel, nextOffset), countdown);</span><br><span class="line">                      <span class="comment">// 更新延迟消息进度</span></span><br><span class="line">                      ScheduleMessageService.<span class="keyword">this</span>.updateOffset(<span class="keyword">this</span>.delayLevel, nextOffset);</span><br><span class="line">                      <span class="keyword">return</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br><span class="line">              <span class="comment">// 调度下一次消费</span></span><br><span class="line">              ScheduleMessageService.<span class="keyword">this</span>.timer.schedule(<span class="keyword">new</span> DeliverDelayedMessageTimerTask(<span class="keyword">this</span>.delayLevel, nextOffset), DELAY_FOR_A_WHILE);</span><br><span class="line">              <span class="comment">// 更新进度</span></span><br><span class="line">              ScheduleMessageService.<span class="keyword">this</span>.updateOffset(<span class="keyword">this</span>.delayLevel, nextOffset);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              bufferCQ.release();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ScheduleMessageService.<span class="keyword">this</span>.timer.schedule(<span class="keyword">new</span> DeliverDelayedMessageTimerTask(<span class="keyword">this</span>.delayLevel, failScheduleOffset), DELAY_FOR_A_WHILE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://help.aliyun.com/document_detail/43348.html?spm=5176.doc43490.6.566.Zd5Bl7" target="_blank" rel="noopener">事务消息</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2018/03/22/mq/6.rocketmq-%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96&%E6%B6%88%E8%B4%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/22/mq/6.rocketmq-%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96&%E6%B6%88%E8%B4%B9/" itemprop="url">RocketMQ 消费</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-22T00:00:00+08:00">2018-03-22</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/rocketmq/" itemprop="url" rel="index"><span itemprop="name">rocketmq</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="6-消息拉取并消费"><a href="#6-消息拉取并消费" class="headerlink" title="6. 消息拉取并消费"></a>6. 消息拉取并消费</h1><p>本章我们将分别从<code>Consumer</code>和<code>Broker</code>两个地方进行介绍。</p>
<h2 id="Consumer-处理"><a href="#Consumer-处理" class="headerlink" title="Consumer 处理"></a>Consumer 处理</h2><p>在第四章<code>初始化与启动</code>中，介绍了<code>Consumer</code>的初始化启动过程，其中会启动一个<code>RebalanceService</code>服务。它的作用就是定时去做重负载。<br><strong>重负载的内容</strong>就是去Broker去查询当前所有的消费者然后根据消息分配策略计算出分配给自己的队列有哪些。最后跟本地进行比较，如果是<strong>新增的就发起消息的消费</strong>，<strong>如果是本地不再存在的则从本地删除</strong>，其他的则不变。<br>对于<code>Consumer</code>刚启动的时候，也会触发一次重负载。<br>重负载的逻辑在<code>RebalanceImpl.rebalanceByTopic</code>方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rebalanceByTopic</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="keyword">boolean</span> isOrder)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">switch</span> (messageModel) &#123;</span><br><span class="line">   <span class="keyword">case</span> CLUSTERING: &#123;</span><br><span class="line">       <span class="comment">// 获取topic下的所有queue</span></span><br><span class="line">       Set&lt;MessageQueue&gt; mqSet = <span class="keyword">this</span>.topicSubscribeInfoTable.get(topic);</span><br><span class="line">       <span class="comment">//获取本消费组下的所有消费者</span></span><br><span class="line">       List&lt;String&gt; cidAll = <span class="keyword">this</span>.mQClientFactory.findConsumerIdList(topic, consumerGroup);</span><br><span class="line">       <span class="keyword">if</span> (mqSet != <span class="keyword">null</span> &amp;&amp; cidAll != <span class="keyword">null</span>) &#123;</span><br><span class="line">           List&lt;MessageQueue&gt; mqAll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           mqAll.addAll(mqSet);</span><br><span class="line">           Collections.sort(mqAll);</span><br><span class="line">           Collections.sort(cidAll);</span><br><span class="line">           AllocateMessageQueueStrategy strategy = <span class="keyword">this</span>.allocateMessageQueueStrategy;</span><br><span class="line">           <span class="comment">// 根据 队列分配策略 分配消费队列</span></span><br><span class="line">           List&lt;MessageQueue&gt; allocateResult;</span><br><span class="line">           <span class="comment">// 根据指定分配策略分配出给本consumer的消费队列</span></span><br><span class="line">           allocateResult = strategy.allocate(<span class="keyword">this</span>.consumerGroup, <span class="keyword">this</span>.mQClientFactory.getClientId(), mqAll, cidAll);</span><br><span class="line">           Set&lt;MessageQueue&gt; allocateResultSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">           <span class="keyword">if</span> (allocateResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">               allocateResultSet.addAll(allocateResult);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 跟据最新的分配结果去更新consumer本地的消费队列</span></span><br><span class="line">           <span class="keyword">boolean</span> changed = <span class="keyword">this</span>.updateProcessQueueTableInRebalance(topic, allocateResultSet, isOrder);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">       <span class="keyword">case</span> <span class="comment">//...</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateProcessQueueTableInRebalance</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> Set&lt;MessageQueue&gt; mqSet, <span class="keyword">final</span> <span class="keyword">boolean</span> isOrder)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">   Iterator&lt;Entry&lt;MessageQueue, ProcessQueue&gt;&gt; it = <span class="keyword">this</span>.processQueueTable.entrySet().iterator();</span><br><span class="line">   <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">       <span class="comment">// 筛选出不在最新消费队列中的本地队列进行移除，另外对于拉取超时的也同样移除</span></span><br><span class="line">       Entry&lt;MessageQueue, ProcessQueue&gt; next = it.next();</span><br><span class="line">       MessageQueue mq = next.getKey();</span><br><span class="line">       ProcessQueue pq = next.getValue();</span><br><span class="line">       <span class="keyword">if</span> (mq.getTopic().equals(topic)) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!mqSet.contains(mq)) &#123;</span><br><span class="line">               pq.setDropped(<span class="keyword">true</span>);</span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.removeUnnecessaryMessageQueue(mq, pq)) &#123;</span><br><span class="line">                   it.remove();</span><br><span class="line">                   changed = <span class="keyword">true</span>;</span><br><span class="line">                   log.info(<span class="string">"doRebalance, &#123;&#125;, remove unnecessary mq, &#123;&#125;"</span>, consumerGroup, mq);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pq.isPullExpired()) &#123;</span><br><span class="line">               <span class="keyword">switch</span> (<span class="keyword">this</span>.consumeType()) &#123;</span><br><span class="line">                   <span class="keyword">case</span> CONSUME_ACTIVELY:</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">case</span> CONSUME_PASSIVELY:</span><br><span class="line">                       pq.setDropped(<span class="keyword">true</span>);</span><br><span class="line">                       <span class="keyword">if</span> (<span class="keyword">this</span>.removeUnnecessaryMessageQueue(mq, pq)) &#123;</span><br><span class="line">                           it.remove();</span><br><span class="line">                           changed = <span class="keyword">true</span>;</span><br><span class="line">                           log.error(<span class="string">"[BUG]doRebalance, &#123;&#125;, remove unnecessary mq, &#123;&#125;, because pull is pause, so try to fixed it"</span>,</span><br><span class="line">                               consumerGroup, mq);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">default</span>:</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 筛选出新加的</span></span><br><span class="line">   List&lt;PullRequest&gt; pullRequestList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span> (MessageQueue mq : mqSet) &#123;</span><br><span class="line">       <span class="keyword">if</span> (!<span class="keyword">this</span>.processQueueTable.containsKey(mq)) &#123;</span><br><span class="line">           <span class="comment">// 有序消费的时候，需要锁定记录</span></span><br><span class="line">           <span class="keyword">if</span> (isOrder &amp;&amp; !<span class="keyword">this</span>.lock(mq)) &#123;</span><br><span class="line">               log.warn(<span class="string">"doRebalance, &#123;&#125;, add a new mq failed, &#123;&#125;, because lock failed"</span>, consumerGroup, mq);</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">this</span>.removeDirtyOffset(mq);</span><br><span class="line">           ProcessQueue pq = <span class="keyword">new</span> ProcessQueue();</span><br><span class="line">           <span class="keyword">long</span> nextOffset = <span class="keyword">this</span>.computePullFromWhere(mq);</span><br><span class="line">           <span class="keyword">if</span> (nextOffset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">               ProcessQueue pre = <span class="keyword">this</span>.processQueueTable.putIfAbsent(mq, pq);</span><br><span class="line">               <span class="keyword">if</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   log.info(<span class="string">"doRebalance, &#123;&#125;, mq already exists, &#123;&#125;"</span>, consumerGroup, mq);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   log.info(<span class="string">"doRebalance, &#123;&#125;, add a new mq, &#123;&#125;"</span>, consumerGroup, mq);</span><br><span class="line">                   PullRequest pullRequest = <span class="keyword">new</span> PullRequest();</span><br><span class="line">                   pullRequest.setConsumerGroup(consumerGroup);</span><br><span class="line">                   pullRequest.setNextOffset(nextOffset);</span><br><span class="line">                   pullRequest.setMessageQueue(mq);</span><br><span class="line">                   pullRequest.setProcessQueue(pq);</span><br><span class="line">                   pullRequestList.add(pullRequest);</span><br><span class="line">                   changed = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 发起消息拉取请求</span></span><br><span class="line">   <span class="keyword">this</span>.dispatchPullRequest(pullRequestList);</span><br><span class="line">   <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特别需要说的是：对于有序消费，在重负载的时候会尝试锁住资源；如果锁资源失败则不进行消费。<br>对于新增的消费队列，consumer会构造拉取参数<code>PullRequest</code>调用<code>dispatchPullRequest</code>进行提交消费。可以看到，最终是将拉取请求丢进<code>PullMessageService</code>的消息拉取队列中<code>pullRequestQueue</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchPullRequest</span><span class="params">(List&lt;PullRequest&gt; pullRequestList)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (PullRequest pullRequest : pullRequestList) &#123;</span><br><span class="line">       <span class="keyword">this</span>.defaultMQPushConsumerImpl.executePullRequestImmediately(pullRequest);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executePullRequestImmediately</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.mQClientFactory.getPullMessageService().executePullRequestImmediately(pullRequest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executePullRequestImmediately</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.pullRequestQueue.put(pullRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PullMessageService</code>中有个后台线程会从<code>pullRequestQueue</code>不停取<code>PullRequest</code>开始拉取消息。<br>拉取消费过程大致如下：</p>
<ol>
<li>调用<code>pullAPIWrapper.pullKernelImpl</code>去拉取消息</li>
<li>对拉取回来的消息调用<code>PullCallback</code>进行消费</li>
</ol>
<p>拉取消息请求的是<strong>Broker</strong>的<code>PullMessageProcessor</code>，后面我们再来分析它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pullResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">     pullResult = DefaultMQPushConsumerImpl.<span class="keyword">this</span>.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult,</span><br><span class="line">         subscriptionData);</span><br><span class="line">     <span class="keyword">switch</span> (pullResult.getPullStatus()) &#123;</span><br><span class="line">         <span class="keyword">case</span> FOUND:</span><br><span class="line">             <span class="comment">// 设置下一次消费位移</span></span><br><span class="line">             pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br><span class="line">             <span class="comment">// ... 统计</span></span><br><span class="line">             <span class="keyword">if</span> (pullResult.getMsgFoundList() == <span class="keyword">null</span> || pullResult.getMsgFoundList().isEmpty()) &#123;</span><br><span class="line">                 DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 将无需的消息放到ProcessQueue中按offset排序</span></span><br><span class="line">                 <span class="keyword">boolean</span> dispathToConsume = processQueue.putMessage(pullResult.getMsgFoundList());</span><br><span class="line">                 <span class="comment">// 提交消费请求，对于顺序有要求的请求提交到 ConsumeMessageOrderlyService中，没有要求的提交到ConsumeMessageConcurrentlyService进行消费</span></span><br><span class="line">                 DefaultMQPushConsumerImpl.<span class="keyword">this</span>.consumeMessageService.submitConsumeRequest(<span class="comment">//</span></span><br><span class="line">                     pullResult.getMsgFoundList(), <span class="comment">//</span></span><br><span class="line">                     processQueue, <span class="comment">//</span></span><br><span class="line">                     pullRequest.getMessageQueue(), <span class="comment">//</span></span><br><span class="line">                     dispathToConsume);</span><br><span class="line">                 <span class="comment">// 将pullRequest再丢进PullMessageService的队列中继续拉取</span></span><br><span class="line">                 <span class="keyword">if</span> (DefaultMQPushConsumerImpl.<span class="keyword">this</span>.defaultMQPushConsumer.getPullInterval() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                     DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestLater(pullRequest,</span><br><span class="line">                         DefaultMQPushConsumerImpl.<span class="keyword">this</span>.defaultMQPushConsumer.getPullInterval());</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="comment">//...</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Broker-处理"><a href="#Broker-处理" class="headerlink" title="Broker 处理"></a>Broker 处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">processRequest</span><span class="params">(<span class="keyword">final</span> Channel channel, RemotingCommand request, <span class="keyword">boolean</span> brokerAllowSuspend)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">   RemotingCommand response = RemotingCommand.createResponseCommand(PullMessageResponseHeader<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   <span class="keyword">final</span> PullMessageResponseHeader responseHeader = (PullMessageResponseHeader) response.readCustomHeader();</span><br><span class="line">   <span class="keyword">final</span> PullMessageRequestHeader requestHeader =</span><br><span class="line">       (PullMessageRequestHeader) request.decodeCommandCustomHeader(PullMessageRequestHeader<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   response.setOpaque(request.getOpaque());</span><br><span class="line"></span><br><span class="line">   <span class="comment">//... 一顿校验</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">boolean</span> hasSuspendFlag = PullSysFlag.hasSuspendFlag(requestHeader.getSysFlag()); <span class="comment">// 是否挂起请求，当没有消息时</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">boolean</span> hasCommitOffsetFlag = PullSysFlag.hasCommitOffsetFlag(requestHeader.getSysFlag()); <span class="comment">// 是否提交消费进度</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">boolean</span> hasSubscriptionFlag = PullSysFlag.hasSubscriptionFlag(requestHeader.getSysFlag()); <span class="comment">// 是否过滤订阅表达式(subscription)</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">long</span> suspendTimeoutMillisLong = hasSuspendFlag ? requestHeader.getSuspendTimeoutMillis() : <span class="number">0</span>; <span class="comment">// 挂起请求超时时长</span></span><br><span class="line">   <span class="comment">//... 一顿校验</span></span><br><span class="line">   <span class="comment">// 拉取信息</span></span><br><span class="line">   <span class="keyword">final</span> GetMessageResult getMessageResult = <span class="keyword">this</span>.brokerController.getMessageStore().getMessage(requestHeader.getConsumerGroup(), requestHeader.getTopic(),</span><br><span class="line">           requestHeader.getQueueId(), requestHeader.getQueueOffset(), requestHeader.getMaxMsgNums(), subscriptionData);</span><br><span class="line">   <span class="keyword">if</span> (getMessageResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">       response.setRemark(getMessageResult.getStatus().name());</span><br><span class="line"></span><br><span class="line">       responseHeader.setNextBeginOffset(getMessageResult.getNextBeginOffset());</span><br><span class="line">       responseHeader.setMinOffset(getMessageResult.getMinOffset());</span><br><span class="line">       responseHeader.setMaxOffset(getMessageResult.getMaxOffset());</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 计算建议读取brokerId</span></span><br><span class="line">       <span class="keyword">if</span> (getMessageResult.isSuggestPullingFromSlave()) &#123;</span><br><span class="line">           responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly());</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">switch</span> (<span class="keyword">this</span>.brokerController.getMessageStoreConfig().getBrokerRole()) &#123;</span><br><span class="line">       <span class="keyword">case</span> ASYNC_MASTER:</span><br><span class="line">       <span class="keyword">case</span> SYNC_MASTER:</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> SLAVE:</span><br><span class="line">           <span class="keyword">if</span> (!<span class="keyword">this</span>.brokerController.getBrokerConfig().isSlaveReadEnable()) &#123; <span class="comment">// 从节点不允许读取，告诉consumer读取主节点。</span></span><br><span class="line">               response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</span><br><span class="line">               responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//当消费过慢的时候，让其从Slave拉取数据</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isSlaveReadEnable()) &#123;</span><br><span class="line">           <span class="comment">// consume too slow ,redirect to another machine</span></span><br><span class="line">           <span class="keyword">if</span> (getMessageResult.isSuggestPullingFromSlave()) &#123;</span><br><span class="line">               responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// consume ok</span></span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getBrokerId());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>拉取消息后，需要进行一次判断：</p>
<ol>
<li>当拉取到数据后，如果配置不通过堆传输的话，就通过zero-copy的方式直接写socket返回</li>
<li>如果没有拉取到数据，则将请求挂起，放到<code>PullRequestHoldService</code>中。当有新消息产生时，再返回。<strong>长轮询</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (response.getCode()) &#123;</span><br><span class="line"> <span class="keyword">case</span> ResponseCode.SUCCESS:</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isTransferMsgByHeap()) &#123; <span class="comment">// 内存中</span></span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">long</span> beginTimeMills = <span class="keyword">this</span>.brokerController.getMessageStore().now();</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">byte</span>[] r = <span class="keyword">this</span>.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId());</span><br><span class="line">         <span class="keyword">this</span>.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),</span><br><span class="line">             requestHeader.getTopic(), requestHeader.getQueueId(),</span><br><span class="line">             (<span class="keyword">int</span>) (<span class="keyword">this</span>.brokerController.getMessageStore().now() - beginTimeMills));</span><br><span class="line">         response.setBody(r);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 拉取到信息后，通过zero-copy的方式发送数据</span></span><br><span class="line">         FileRegion fileRegion = <span class="keyword">new</span> ManyMessageTransfer(response.encodeHeader(getMessageResult.getBufferTotalSize()), getMessageResult);</span><br><span class="line">         channel.writeAndFlush(fileRegion).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                 getMessageResult.release();</span><br><span class="line">                 <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                     LOG.error(<span class="string">"Fail to transfer messages from page cache to &#123;&#125;"</span>, channel.remoteAddress(), future.cause());</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">         response = <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> ResponseCode.PULL_NOT_FOUND:</span><br><span class="line">     <span class="keyword">if</span> (brokerAllowSuspend &amp;&amp; hasSuspendFlag) &#123;</span><br><span class="line">         <span class="comment">// 允许挂起时，将请求挂起在PullRequestHoldService中。待有新消息产生时返回</span></span><br><span class="line">         <span class="keyword">long</span> pollingTimeMills = suspendTimeoutMillisLong;</span><br><span class="line">         <span class="keyword">if</span> (!<span class="keyword">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</span><br><span class="line">             pollingTimeMills = <span class="keyword">this</span>.brokerController.getBrokerConfig().getShortPollingTimeMills();</span><br><span class="line">         &#125;</span><br><span class="line">         String topic = requestHeader.getTopic();</span><br><span class="line">         <span class="keyword">long</span> offset = requestHeader.getQueueOffset();</span><br><span class="line">         <span class="keyword">int</span> queueId = requestHeader.getQueueId();</span><br><span class="line">         PullRequest pullRequest = <span class="keyword">new</span> PullRequest(request, channel, pollingTimeMills,</span><br><span class="line">             <span class="keyword">this</span>.brokerController.getMessageStore().now(), offset, subscriptionData);</span><br><span class="line">         <span class="keyword">this</span>.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest);</span><br><span class="line">         response = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="keyword">case</span> <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最后，</strong>保存Topic下该Queue的消费进度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 保存 消费进度</span></span><br><span class="line"><span class="keyword">boolean</span> storeOffsetEnable = brokerAllowSuspend;</span><br><span class="line">storeOffsetEnable = storeOffsetEnable &amp;&amp; hasCommitOffsetFlag;</span><br><span class="line">storeOffsetEnable = storeOffsetEnable &amp;&amp; <span class="keyword">this</span>.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE;</span><br><span class="line"><span class="keyword">if</span> (storeOffsetEnable) &#123;</span><br><span class="line">  <span class="keyword">this</span>.brokerController.getConsumerOffsetManager().commitOffset(RemotingHelper.parseChannelRemoteAddr(channel),</span><br><span class="line">      requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId(), requestHeader.getCommitOffset());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2018/03/21/mq/5.rocketmq-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81&%E5%AD%98%E5%82%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/21/mq/5.rocketmq-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81&%E5%AD%98%E5%82%A8/" itemprop="url">RocketMQ 消息发送&存储</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-21T00:00:00+08:00">2018-03-21</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/rocketmq/" itemprop="url" rel="index"><span itemprop="name">rocketmq</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="5-消息发送并存储"><a href="#5-消息发送并存储" class="headerlink" title="5. 消息发送并存储"></a>5. 消息发送并存储</h1><p>发送分为<code>同步和异步</code>的方式，本章主要解析同步方式，异步方式与同步方式很相似。<br>发送的过程，<code>Producer</code>发送消息，<code>Broker</code>接收消息并存储。</p>
<h2 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h2><p>发送过程，最主要逻辑在<code>DefaultMQProducerImpl.sendDefaultImpl</code>中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendDefaultImpl</span><span class="params">(Message msg, <span class="keyword">final</span> CommunicationMode communicationMode, <span class="keyword">final</span> SendCallback sendCallback, <span class="keyword">final</span> <span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> ... </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">long</span> invokeID = random.nextLong();</span><br><span class="line">   <span class="keyword">long</span> beginTimestampFirst = System.currentTimeMillis();</span><br><span class="line">   <span class="keyword">long</span> beginTimestampPrev = beginTimestampFirst;</span><br><span class="line">   <span class="meta">@SuppressWarnings</span>(<span class="string">"UnusedAssignment"</span>)</span><br><span class="line">   <span class="keyword">long</span> endTimestamp = beginTimestampFirst;</span><br><span class="line">   <span class="comment">// 获取topic路由信息</span></span><br><span class="line">   TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</span><br><span class="line">   <span class="keyword">if</span> (topicPublishInfo != <span class="keyword">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</span><br><span class="line">       MessageQueue mq = <span class="keyword">null</span>;</span><br><span class="line">       SendResult sendResult = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">int</span> timesTotal = communicationMode == CommunicationMode.SYNC ? <span class="number">1</span> + <span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendFailed() : <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">       String[] brokersSent = <span class="keyword">new</span> String[timesTotal];</span><br><span class="line">       <span class="comment">// 最多重试timeTotal次</span></span><br><span class="line">       <span class="keyword">for</span> (; times &lt; timesTotal; times++) &#123;</span><br><span class="line">           String lastBrokerName = <span class="keyword">null</span> == mq ? <span class="keyword">null</span> : mq.getBrokerName();</span><br><span class="line">           <span class="comment">// 按一定策略 选择一个队列进行发送消息（目前是轮询法）</span></span><br><span class="line">           <span class="meta">@SuppressWarnings</span>(<span class="string">"SpellCheckingInspection"</span>)</span><br><span class="line">           MessageQueue tmpmq = <span class="keyword">this</span>.selectOneMessageQueue(topicPublishInfo, lastBrokerName);</span><br><span class="line">           <span class="keyword">if</span> (tmpmq != <span class="keyword">null</span>) &#123;</span><br><span class="line">               mq = tmpmq;</span><br><span class="line">               brokersSent[times] = mq.getBrokerName();</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   beginTimestampPrev = System.currentTimeMillis();</span><br><span class="line">                   <span class="comment">// 调用发送消息核心方法</span></span><br><span class="line">                   sendResult = <span class="keyword">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout);</span><br><span class="line">                   endTimestamp = System.currentTimeMillis();</span><br><span class="line">                   <span class="comment">// 更新Broker可用性信息</span></span><br><span class="line">                   <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">false</span>);</span><br><span class="line">                   <span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">                       <span class="keyword">case</span> ASYNC:</span><br><span class="line">                           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                       <span class="keyword">case</span> ONEWAY:</span><br><span class="line">                           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                       <span class="keyword">case</span> SYNC:</span><br><span class="line">                           <span class="comment">//重试</span></span><br><span class="line">                           <span class="keyword">if</span> (sendResult.getSendStatus() != SendStatus.SEND_OK) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) &#123;</span><br><span class="line">                                   <span class="keyword">continue</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">return</span> sendResult;</span><br><span class="line">                       <span class="keyword">default</span>:</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">catch</span> <span class="comment">//...</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (sendResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> sendResult;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出整个过程：首先获取路由信息，然后按一定策略选择一个队列进行发送消息，当失败时会重试，最多重试<code>timesTotal</code>次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendKernelImpl</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> MessageQueue mq, <span class="keyword">final</span> CommunicationMode communicationMode, <span class="keyword">final</span> SendCallback sendCallback, <span class="keyword">final</span> TopicPublishInfo topicPublishInfo, <span class="keyword">final</span> <span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">   <span class="comment">// 跟据队列对应broker地址</span></span><br><span class="line">   String brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> == brokerAddr) &#123;</span><br><span class="line">       tryToFindTopicPublishInfo(mq.getTopic());</span><br><span class="line">       brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line">   &#125;</span><br><span class="line">   SendMessageContext context = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (brokerAddr != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// 是否使用VIP通道，否认使用，之前在介绍broker的时候介绍过broker会起两个server，端口号-2 的server为fast server</span></span><br><span class="line">       brokerAddr = MixAll.brokerVIPChannel(<span class="keyword">this</span>.defaultMQProducer.isSendMessageWithVIPChannel(), brokerAddr);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 生成msg唯一ID 时间差 + counter</span></span><br><span class="line">           MessageClientIDSetter.setUniqID(msg);</span><br><span class="line">           <span class="keyword">int</span> sysFlag = <span class="number">0</span>;</span><br><span class="line">           <span class="comment">// 消息压缩</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.tryToCompressMessage(msg)) &#123;</span><br><span class="line">               sysFlag |= MessageSysFlag.COMPRESSED_FLAG;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 事务</span></span><br><span class="line">           <span class="keyword">final</span> String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">           <span class="keyword">if</span> (tranMsg != <span class="keyword">null</span> &amp;&amp; Boolean.parseBoolean(tranMsg)) &#123;</span><br><span class="line">               sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// ...发送前校验逻辑</span></span><br><span class="line">           <span class="comment">// 构建发送消息请求</span></span><br><span class="line">           SendMessageRequestHeader requestHeader = <span class="keyword">new</span> SendMessageRequestHeader();</span><br><span class="line">           requestHeader.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">           requestHeader.setTopic(msg.getTopic());</span><br><span class="line">           requestHeader.setDefaultTopic(<span class="keyword">this</span>.defaultMQProducer.getCreateTopicKey());</span><br><span class="line">           requestHeader.setDefaultTopicQueueNums(<span class="keyword">this</span>.defaultMQProducer.getDefaultTopicQueueNums());</span><br><span class="line">           requestHeader.setQueueId(mq.getQueueId());</span><br><span class="line">           requestHeader.setSysFlag(sysFlag);</span><br><span class="line">           requestHeader.setBornTimestamp(System.currentTimeMillis());</span><br><span class="line">           requestHeader.setFlag(msg.getFlag());</span><br><span class="line">           requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line">           requestHeader.setReconsumeTimes(<span class="number">0</span>);</span><br><span class="line">           requestHeader.setUnitMode(<span class="keyword">this</span>.isUnitMode());</span><br><span class="line">           <span class="comment">// 消息重发</span></span><br><span class="line">           <span class="keyword">if</span> (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">               String reconsumeTimes = MessageAccessor.getReconsumeTime(msg);</span><br><span class="line">               <span class="keyword">if</span> (reconsumeTimes != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));</span><br><span class="line">                   MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);</span><br><span class="line">               &#125;</span><br><span class="line">               String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg);</span><br><span class="line">               <span class="keyword">if</span> (maxReconsumeTimes != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));</span><br><span class="line">                   MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 发送消息</span></span><br><span class="line">           SendResult sendResult = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">               <span class="keyword">case</span> SYNC:</span><br><span class="line">                    <span class="comment">// 调用MQclient进行发送消息</span></span><br><span class="line">                   sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</span><br><span class="line">                       brokerAddr,</span><br><span class="line">                       mq.getBrokerName(),</span><br><span class="line">                       msg,</span><br><span class="line">                       requestHeader,</span><br><span class="line">                       timeout,</span><br><span class="line">                       communicationMode,</span><br><span class="line">                       context,</span><br><span class="line">                       <span class="keyword">this</span>);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="comment">//...</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 返回发送结果</span></span><br><span class="line">           <span class="keyword">return</span> sendResult;</span><br><span class="line">       &#125; <span class="keyword">catch</span> <span class="comment">//...</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h2><p><code>Broker</code>的fast Server接收到消息后，交给<code>SendMessageProcessor</code>进行处理。以下为其主要核心逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">sendMessage</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, <span class="keyword">final</span> RemotingCommand request, <span class="keyword">final</span> SendMessageContext sendMessageContext, <span class="keyword">final</span> SendMessageRequestHeader requestHeader)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">   <span class="comment">// 初始化响应</span></span><br><span class="line">   <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(SendMessageResponseHeader<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   <span class="keyword">final</span> SendMessageResponseHeader responseHeader = (SendMessageResponseHeader) response.readCustomHeader();</span><br><span class="line">   response.setOpaque(request.getOpaque());</span><br><span class="line">   response.addExtField(MessageConst.PROPERTY_MSG_REGION, <span class="keyword">this</span>.brokerController.getBrokerConfig().getRegionId());</span><br><span class="line">   response.addExtField(MessageConst.PROPERTY_TRACE_SWITCH, String.valueOf(<span class="keyword">this</span>.brokerController.getBrokerConfig().isTraceOn()));</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">byte</span>[] body = request.getBody();</span><br><span class="line">   <span class="comment">//.... 校验</span></span><br><span class="line">   <span class="comment">// 如果队列小于0，从可用队列随机选择</span></span><br><span class="line">   <span class="keyword">int</span> queueIdInt = requestHeader.getQueueId();</span><br><span class="line">   TopicConfig topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());</span><br><span class="line">   <span class="keyword">if</span> (queueIdInt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       queueIdInt = Math.abs(<span class="keyword">this</span>.random.nextInt() % <span class="number">99999999</span>) % topicConfig.getWriteQueueNums();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span> sysFlag = requestHeader.getSysFlag();</span><br><span class="line">   <span class="keyword">if</span> (TopicFilterType.MULTI_TAG == topicConfig.getTopicFilterType()) &#123;</span><br><span class="line">       sysFlag |= MessageSysFlag.MULTI_TAGS_FLAG;</span><br><span class="line">   &#125;</span><br><span class="line">   String newTopic = requestHeader.getTopic();</span><br><span class="line">   <span class="comment">//重试消息</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != newTopic &amp;&amp; newTopic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">       String groupName = newTopic.substring(MixAll.RETRY_GROUP_TOPIC_PREFIX.length());</span><br><span class="line">       SubscriptionGroupConfig subscriptionGroupConfig =</span><br><span class="line">           <span class="keyword">this</span>.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(groupName);</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == subscriptionGroupConfig) &#123;</span><br><span class="line">           response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);</span><br><span class="line">           response.setRemark(<span class="string">"subscription group not exist, "</span> + groupName + <span class="string">" "</span> + FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST));</span><br><span class="line">           <span class="keyword">return</span> response;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> maxReconsumeTimes = subscriptionGroupConfig.getRetryMaxTimes();</span><br><span class="line">       <span class="keyword">if</span> (request.getVersion() &gt;= MQVersion.Version.V3_4_9.ordinal()) &#123;</span><br><span class="line">           maxReconsumeTimes = requestHeader.getMaxReconsumeTimes();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//超过消费最大次数则放入死信队列中</span></span><br><span class="line">       <span class="keyword">int</span> reconsumeTimes = requestHeader.getReconsumeTimes() == <span class="keyword">null</span> ? <span class="number">0</span> : requestHeader.getReconsumeTimes();</span><br><span class="line">       <span class="keyword">if</span> (reconsumeTimes &gt;= maxReconsumeTimes) &#123;</span><br><span class="line">           newTopic = MixAll.getDLQTopic(groupName);</span><br><span class="line">           queueIdInt = Math.abs(<span class="keyword">this</span>.random.nextInt() % <span class="number">99999999</span>) % DLQ_NUMS_PER_GROUP;</span><br><span class="line">           topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(newTopic, DLQ_NUMS_PER_GROUP, PermName.PERM_WRITE, <span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 创建MessageExtBrokerInner</span></span><br><span class="line">   MessageExtBrokerInner msgInner = <span class="keyword">new</span> MessageExtBrokerInner();</span><br><span class="line">   msgInner.setTopic(newTopic);</span><br><span class="line">   msgInner.setBody(body);</span><br><span class="line">   msgInner.setFlag(requestHeader.getFlag());</span><br><span class="line">   MessageAccessor.setProperties(msgInner, MessageDecoder.string2messageProperties(requestHeader.getProperties()));</span><br><span class="line">   msgInner.setPropertiesString(requestHeader.getProperties());</span><br><span class="line">   msgInner.setTagsCode(MessageExtBrokerInner.tagsString2tagsCode(topicConfig.getTopicFilterType(), msgInner.getTags()));</span><br><span class="line">   msgInner.setQueueId(queueIdInt);</span><br><span class="line">   msgInner.setSysFlag(sysFlag);</span><br><span class="line">   msgInner.setBornTimestamp(requestHeader.getBornTimestamp());</span><br><span class="line">   msgInner.setBornHost(ctx.channel().remoteAddress());</span><br><span class="line">   msgInner.setStoreHost(<span class="keyword">this</span>.getStoreHost());</span><br><span class="line">   msgInner.setReconsumeTimes(requestHeader.getReconsumeTimes() == <span class="keyword">null</span> ? <span class="number">0</span> : requestHeader.getReconsumeTimes());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 校验是否不允许发送事务消息</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isRejectTransactionMessage()) &#123;</span><br><span class="line">       String traFlag = msgInner.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">       <span class="keyword">if</span> (traFlag != <span class="keyword">null</span>) &#123;</span><br><span class="line">           response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">           response.setRemark(</span><br><span class="line">               <span class="string">"the broker["</span> + <span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerIP1() + <span class="string">"] sending transaction message is forbidden"</span>);</span><br><span class="line">           <span class="keyword">return</span> response;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 调用MessageStore存储消息</span></span><br><span class="line">   PutMessageResult putMessageResult = <span class="keyword">this</span>.brokerController.getMessageStore().putMessage(msgInner);</span><br><span class="line">   <span class="comment">//... 统计与响应</span></span><br><span class="line">   <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当消息为重试消息且超过设定的最大消费次数时，将会被放入死信队列中。<br>经过一些校验后，调用<code>MessageStore.putMessage</code>（详见<code>第3章 store</code>）存储消息，最后进行broker接收消息的统计和响应。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2018/03/20/mq/4.rocketmq-%E5%88%9D%E5%A7%8B%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/20/mq/4.rocketmq-%E5%88%9D%E5%A7%8B%E5%8C%96/" itemprop="url">RocketMQ 初始化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-20T00:00:00+08:00">2018-03-20</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/rocketmq/" itemprop="url" rel="index"><span itemprop="name">rocketmq</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="4-初始化"><a href="#4-初始化" class="headerlink" title="4. 初始化"></a>4. 初始化</h1><p>[TOC]</p>
<p><code>NameServer</code>和<code>Broker</code>是<code>RocetMQ</code>中独立部署的集群。<br>下面我们将来分别介绍他们。</p>
<h2 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h2><p><code>NameServer</code>管理<code>Broker</code>集群的注册信息并提供心跳来检测他们是否可用，持有关于Broker集群和队列的全部路由信息。接下来详细了解其具体功能和实现。</p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p><code>NameServer</code>的启动类为<code>NamesrvController</code>，其包含成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后台线程，负责扫描失活的Broker，并销毁与其的链接</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(<span class="keyword">new</span> ThreadFactoryImpl(</span><br><span class="line">   <span class="string">"NSScheduledThread"</span>));</span><br><span class="line"><span class="comment">// 用于加载NameServer的配置参数，配置路径 $HOME/namesrv/kvConfig.json</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> KVConfigManager kvConfigManager;</span><br><span class="line"><span class="comment">// 路由信息管理</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RouteInfoManager routeInfoManager;</span><br><span class="line"><span class="comment">// 基于Netty实现远端服务，监听请求并转发到`DefaultRequestProcessor`，并根据请求码进行不同请求逻辑的处理</span></span><br><span class="line"><span class="keyword">private</span> RemotingServer remotingServer;</span><br><span class="line"><span class="comment">// Broker连接管理服务，用于监听Netty的Channel事件，当异常时从RouteInfoManager中删除相应Channel对应的路由信息</span></span><br><span class="line"><span class="keyword">private</span> BrokerHousekeepingService brokerHousekeepingService;</span><br><span class="line"><span class="keyword">private</span> ExecutorService remotingExecutor;</span><br><span class="line"><span class="keyword">private</span> Configuration configuration;</span><br></pre></td></tr></table></figure>
<p><code>NameServer</code>的启动过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> NamesrvController controller = <span class="keyword">new</span> NamesrvController(namesrvConfig, nettyServerConfig);</span><br><span class="line"><span class="comment">//初始化服务</span></span><br><span class="line"><span class="keyword">boolean</span> initResult = controller.initialize();</span><br><span class="line"><span class="keyword">if</span> (!initResult) &#123;</span><br><span class="line"> controller.shutdown();</span><br><span class="line"> System.exit(-<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//启动Socekt链接，对外提供服务</span></span><br><span class="line">controller.start();</span><br></pre></td></tr></table></figure>
<p>先初始化，再启动服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//加载本地配置</span></span><br><span class="line">   <span class="keyword">this</span>.kvConfigManager.load();</span><br><span class="line">   <span class="comment">//初始化Netty远端服务</span></span><br><span class="line">   <span class="keyword">this</span>.remotingServer = <span class="keyword">new</span> NettyRemotingServer(<span class="keyword">this</span>.nettyServerConfig, <span class="keyword">this</span>.brokerHousekeepingService);</span><br><span class="line">   <span class="comment">//远端请求处理线程池，当接收到请求会让remotingExecutor处理，避免占用过长Netty的workThread，降低Netty的并发处理能力。</span></span><br><span class="line">   <span class="keyword">this</span>.remotingExecutor =</span><br><span class="line">       Executors.newFixedThreadPool(nettyServerConfig.getServerWorkerThreads(), <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"RemotingExecutorThread_"</span>));</span><br><span class="line">   <span class="comment">// 向Netty服务注册默认处理器`xxx.namesrv.processor.DefaultRequestProcessor`</span></span><br><span class="line">   <span class="keyword">this</span>.registerProcessor();</span><br><span class="line">   <span class="comment">// 扫描不是活跃状态的Broker，将其剔除出路由信息中</span></span><br><span class="line">   <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           NamesrvController.<span class="keyword">this</span>.routeInfoManager.scanNotActiveBroker();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">   <span class="comment">// 定时向info日志中输出 配置信息</span></span><br><span class="line">   <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           NamesrvController.<span class="keyword">this</span>.kvConfigManager.printAllPeriodically();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;, <span class="number">1</span>, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="comment">// Netty远端服务开始监听端口，接收请求。</span></span><br><span class="line">   <span class="keyword">this</span>.remotingServer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="提供服务"><a href="#提供服务" class="headerlink" title="提供服务"></a>提供服务</h3><p><code>NameServer</code> 接收到请求后，会被转发到 <code>xxx.namesrv.processor.DefaultRequestProcessor</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">processRequest</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand request)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">   <span class="keyword">switch</span> (request.getCode()) &#123;</span><br><span class="line">       <span class="keyword">case</span> RequestCode.PUT_KV_CONFIG:</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.putKVConfig(ctx, request);</span><br><span class="line">       <span class="keyword">case</span> RequestCode.GET_KV_CONFIG:</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.getKVConfig(ctx, request);</span><br><span class="line">       <span class="keyword">case</span> RequestCode.DELETE_KV_CONFIG:</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.deleteKVConfig(ctx, request);</span><br><span class="line">       <span class="keyword">case</span> RequestCode.REGISTER_BROKER:</span><br><span class="line">           <span class="comment">// 注册Broker信息</span></span><br><span class="line">           Version brokerVersion = MQVersion.value2Version(request.getVersion());</span><br><span class="line">           <span class="keyword">if</span> (brokerVersion.ordinal() &gt;= MQVersion.Version.V3_0_11.ordinal()) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">this</span>.registerBrokerWithFilterServer(ctx, request);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">this</span>.registerBroker(ctx, request);</span><br><span class="line">           &#125;</span><br><span class="line">       <span class="keyword">case</span> RequestCode.UNREGISTER_BROKER:</span><br><span class="line">           <span class="comment">// 注销Broker</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.unregisterBroker(ctx, request);</span><br><span class="line">       <span class="keyword">case</span> RequestCode.GET_ROUTEINTO_BY_TOPIC:</span><br><span class="line">           <span class="comment">// 跟据topic查询路由信息</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.getRouteInfoByTopic(ctx, request);</span><br><span class="line">       <span class="keyword">case</span> RequestCode.GET_BROKER_CLUSTER_INFO:</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.getBrokerClusterInfo(ctx, request);</span><br><span class="line">       <span class="keyword">case</span> RequestCode.WIPE_WRITE_PERM_OF_BROKER:</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.wipeWritePermOfBroker(ctx, request);</span><br><span class="line">       <span class="keyword">case</span> RequestCode.GET_ALL_TOPIC_LIST_FROM_NAMESERVER:</span><br><span class="line">           <span class="keyword">return</span> getAllTopicListFromNameserver(ctx, request);</span><br><span class="line">       <span class="keyword">case</span> RequestCode.DELETE_TOPIC_IN_NAMESRV:</span><br><span class="line">           <span class="keyword">return</span> deleteTopicInNamesrv(ctx, request);</span><br><span class="line">       <span class="keyword">case</span> RequestCode.GET_KVLIST_BY_NAMESPACE:</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.getKVListByNamespace(ctx, request);</span><br><span class="line">       <span class="keyword">case</span> RequestCode.GET_TOPICS_BY_CLUSTER:</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.getTopicsByCluster(ctx, request);</span><br><span class="line">       <span class="keyword">case</span> RequestCode.GET_SYSTEM_TOPIC_LIST_FROM_NS:</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.getSystemTopicListFromNs(ctx, request);</span><br><span class="line">       <span class="keyword">case</span> RequestCode.GET_UNIT_TOPIC_LIST:</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.getUnitTopicList(ctx, request);</span><br><span class="line">       <span class="keyword">case</span> RequestCode.GET_HAS_UNIT_SUB_TOPIC_LIST:</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.getHasUnitSubTopicList(ctx, request);</span><br><span class="line">       <span class="keyword">case</span> RequestCode.GET_HAS_UNIT_SUB_UNUNIT_TOPIC_LIST:</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.getHasUnitSubUnUnitTopicList(ctx, request);</span><br><span class="line">       <span class="keyword">case</span> RequestCode.UPDATE_NAMESRV_CONFIG:</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.updateConfig(ctx, request);</span><br><span class="line">       <span class="keyword">case</span> RequestCode.GET_NAMESRV_CONFIG:</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.getConfig(ctx, request);</span><br><span class="line">       <span class="keyword">default</span>:</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于<code>NameServer</code>，我们最关注的即是路由信息管理 <code>RouteInfoManager</code>，以下为其内部维护的信息。然后围绕这些信息进行提供查询和更新：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// broker连接的过期时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> BROKER_CHANNEL_EXPIRED_TIME = <span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span>;</span><br><span class="line"><span class="comment">// topic 2 broker队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* topic */</span>, List&lt;QueueData&gt;&gt; topicQueueTable;</span><br><span class="line"><span class="comment">// broker名称 2 broker详细信息的集合，一个broker名称可以对应对个broker机器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerName */</span>, BrokerData&gt; brokerAddrTable;</span><br><span class="line"><span class="comment">// 集群名称 2 broker名称集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* clusterName */</span>, Set&lt;String<span class="comment">/* brokerName */</span>&gt;&gt; clusterAddrTable;</span><br><span class="line"><span class="comment">// broker地址 2 broker 连接</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, BrokerLiveInfo&gt; brokerLiveTable;</span><br><span class="line"><span class="comment">// broker 地址 2 filter server</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, List&lt;String&gt;<span class="comment">/* Filter Server */</span>&gt; filterServerTable;</span><br></pre></td></tr></table></figure>

<h2 id="Broker启动初始化"><a href="#Broker启动初始化" class="headerlink" title="Broker启动初始化"></a>Broker启动初始化</h2><p><code>Broker</code>是<code>RocketMQ</code>中用于接收并保存生产者消息，并向服务消费者提供数据消费服务。<br>Broker的启动类为<code>BrokerController</code>，首先来看下其主要成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费位移管理器，管理队列当前的消费位移</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConsumerOffsetManager consumerOffsetManager;</span><br><span class="line"><span class="comment">//链接本Broker的消费者管理</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConsumerManager consumerManager;</span><br><span class="line"><span class="comment">//链接本Broker的生产者管理</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ProducerManager producerManager;</span><br><span class="line"><span class="comment">// Netty的通道事件通知器，当连接断开或者异常时，从相应的管理器中移除连接</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClientHousekeepingService clientHousekeepingService;</span><br><span class="line"><span class="comment">// 向消费者提供服务的消息拉取处理器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PullMessageProcessor pullMessageProcessor;</span><br><span class="line"><span class="comment">// 当消费者未拉取到消息时，挂起拉取连接。当有消息时触发它们拉取消息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PullRequestHoldService pullRequestHoldService;</span><br><span class="line"><span class="comment">// 消息到达监听器（在store章节介绍过），当产生新消息时，会触发其，而它会进一步去告诉pullRequestHoldService里维护的挂起的拉取去消费消息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MessageArrivingListener messageArrivingListener;</span><br><span class="line"><span class="comment">// 用在adminProcessor上，用于跟与Broker连接的客户端进行通讯</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Broker2Client broker2Client;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SubscriptionGroupManager subscriptionGroupManager;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConsumerIdsChangeListener consumerIdsChangeListener;</span><br><span class="line"><span class="comment">//消息存储器</span></span><br><span class="line"><span class="keyword">private</span> MessageStore messageStore;</span><br><span class="line"><span class="comment">//topic 配置管理</span></span><br><span class="line"><span class="keyword">private</span> TopicConfigManager topicConfigManager;</span><br><span class="line"><span class="comment">// RPC请求客户端</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BrokerOuterAPI brokerOuterAPI;</span><br><span class="line"><span class="keyword">private</span> RemotingServer remotingServer;</span><br><span class="line"><span class="keyword">private</span> RemotingServer fastRemotingServer;</span><br></pre></td></tr></table></figure>
<h3 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h3><p>其启动过程先调用<code>initialize()</code>进行初始化，然后调用<code>start()</code>方法让<code>Server</code>监听端口开启服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">throws</span> ... </span>&#123;</span><br><span class="line">   <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line">   <span class="comment">//若是重启，加载之前的信息</span></span><br><span class="line">   result = result &amp;&amp; <span class="keyword">this</span>.topicConfigManager.load();</span><br><span class="line">   result = result &amp;&amp; <span class="keyword">this</span>.consumerOffsetManager.load();</span><br><span class="line">   result = result &amp;&amp; <span class="keyword">this</span>.subscriptionGroupManager.load();</span><br><span class="line">   <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="comment">//初始化信息存储器</span></span><br><span class="line">       <span class="keyword">this</span>.messageStore =</span><br><span class="line">               <span class="keyword">new</span> DefaultMessageStore(<span class="keyword">this</span>.messageStoreConfig, <span class="keyword">this</span>.brokerStatsManager, <span class="keyword">this</span>.messageArrivingListener,</span><br><span class="line">                       <span class="keyword">this</span>.brokerConfig);</span><br><span class="line">       <span class="keyword">this</span>.brokerStats = <span class="keyword">new</span> BrokerStats((DefaultMessageStore) <span class="keyword">this</span>.messageStore);</span><br><span class="line">       <span class="comment">//load plugin</span></span><br><span class="line">       MessageStorePluginContext context = <span class="keyword">new</span> MessageStorePluginContext(messageStoreConfig, brokerStatsManager, messageArrivingListener, brokerConfig);</span><br><span class="line">       <span class="keyword">this</span>.messageStore = MessageStoreFactory.build(context, <span class="keyword">this</span>.messageStore);</span><br><span class="line">   &#125;</span><br><span class="line">   result = result &amp;&amp; <span class="keyword">this</span>.messageStore.load();</span><br><span class="line">   <span class="keyword">if</span> (result) &#123;</span><br><span class="line">       <span class="comment">// 起两个 remoting Server，一个监听设置的端口，一个为设置的端口 -2</span></span><br><span class="line">       <span class="keyword">this</span>.remotingServer = <span class="keyword">new</span> NettyRemotingServer(<span class="keyword">this</span>.nettyServerConfig, <span class="keyword">this</span>.clientHousekeepingService);</span><br><span class="line">       NettyServerConfig fastConfig = (NettyServerConfig) <span class="keyword">this</span>.nettyServerConfig.clone();</span><br><span class="line">       fastConfig.setListenPort(nettyServerConfig.getListenPort() - <span class="number">2</span>);</span><br><span class="line">       <span class="keyword">this</span>.fastRemotingServer = <span class="keyword">new</span> NettyRemotingServer(fastConfig, <span class="keyword">this</span>.clientHousekeepingService);</span><br><span class="line">       <span class="comment">//向Server注册处理器</span></span><br><span class="line">       <span class="keyword">this</span>.registerProcessor();</span><br><span class="line">       <span class="comment">// 定时持久化消费进度</span></span><br><span class="line">       <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               BrokerController.<span class="keyword">this</span>.consumerOffsetManager.persist();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="keyword">this</span>.brokerConfig.getFlushConsumerOffsetInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.brokerConfig.getNamesrvAddr() != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">this</span>.brokerOuterAPI.updateNameServerAddressList(<span class="keyword">this</span>.brokerConfig.getNamesrvAddr());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 接收消息者发送来的消息</span></span><br><span class="line">   SendMessageProcessor sendProcessor = <span class="keyword">new</span> SendMessageProcessor(<span class="keyword">this</span>);</span><br><span class="line">   sendProcessor.registerSendMessageHook(sendMessageHookList);</span><br><span class="line">   sendProcessor.registerConsumeMessageHook(consumeMessageHookList);</span><br><span class="line">   <span class="keyword">this</span>.remotingServer.registerProcessor(RequestCode.SEND_MESSAGE, sendProcessor, <span class="keyword">this</span>.sendMessageExecutor);</span><br><span class="line">   <span class="keyword">this</span>.remotingServer.registerProcessor(RequestCode.SEND_MESSAGE_V2, sendProcessor, <span class="keyword">this</span>.sendMessageExecutor);</span><br><span class="line">   <span class="keyword">this</span>.remotingServer.registerProcessor(RequestCode.CONSUMER_SEND_MSG_BACK, sendProcessor, <span class="keyword">this</span>.sendMessageExecutor);</span><br><span class="line">   <span class="keyword">this</span>.fastRemotingServer.registerProcessor(RequestCode.SEND_MESSAGE, sendProcessor, <span class="keyword">this</span>.sendMessageExecutor);</span><br><span class="line">   <span class="keyword">this</span>.fastRemotingServer.registerProcessor(RequestCode.SEND_MESSAGE_V2, sendProcessor, <span class="keyword">this</span>.sendMessageExecutor);</span><br><span class="line">   <span class="keyword">this</span>.fastRemotingServer.registerProcessor(RequestCode.CONSUMER_SEND_MSG_BACK, sendProcessor, <span class="keyword">this</span>.sendMessageExecutor);</span><br><span class="line">   <span class="comment">// 向消费者提供消息拉取服务</span></span><br><span class="line">   <span class="keyword">this</span>.remotingServer.registerProcessor(RequestCode.PULL_MESSAGE, <span class="keyword">this</span>.pullMessageProcessor, <span class="keyword">this</span>.pullMessageExecutor);</span><br><span class="line">   <span class="keyword">this</span>.pullMessageProcessor.registerConsumeMessageHook(consumeMessageHookList);</span><br><span class="line">   <span class="comment">//QueryMessageProcessor</span></span><br><span class="line">   <span class="comment">//ClientManageProcessor</span></span><br><span class="line">   <span class="comment">//ConsumerManageProcessor</span></span><br><span class="line">   <span class="comment">//EndTransactionProcessor</span></span><br><span class="line">   <span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>可以看到 <code>Broker</code>向外提供服务众多服务。<br>初始化完成后开始启动服务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.messageStore != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">this</span>.messageStore.start();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.remotingServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">this</span>.remotingServer.start();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.fastRemotingServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">this</span>.fastRemotingServer.start();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.brokerOuterAPI != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">this</span>.brokerOuterAPI.start();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="comment">// 向NameServer注册其自身所拥有的信息，包括topic等信息</span></span><br><span class="line">   <span class="keyword">this</span>.registerBrokerAll(<span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">   <span class="comment">//开启30s定时注册</span></span><br><span class="line">   <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           BrokerController.<span class="keyword">this</span>.registerBrokerAll(<span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">30</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h2><p>生产者类<code>DefaultMQProducer</code>是消息发送的壳子，其内部真正用来发送消息的类是<code>DefaultMQProducerImpl</code>。对于事务消息，其发送者为<code>TransactionMQProducer</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> startFactory)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">   <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">       <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">           <span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line">           <span class="keyword">this</span>.checkConfig();</span><br><span class="line">           <span class="keyword">if</span> (!<span class="keyword">this</span>.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) &#123;</span><br><span class="line">               <span class="keyword">this</span>.defaultMQProducer.changeInstanceNameToPID();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 创建 MQ Client</span></span><br><span class="line">           <span class="keyword">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class="keyword">this</span>.defaultMQProducer, rpcHook);</span><br><span class="line">           <span class="comment">// 注册Producer</span></span><br><span class="line">           <span class="keyword">boolean</span> registerOK = mQClientFactory.registerProducer(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup(), <span class="keyword">this</span>);</span><br><span class="line">           <span class="comment">// ...</span></span><br><span class="line">           <span class="keyword">this</span>.topicPublishInfoTable.put(<span class="keyword">this</span>.defaultMQProducer.getCreateTopicKey(), <span class="keyword">new</span> TopicPublishInfo());</span><br><span class="line">           <span class="comment">// 启动MQ client</span></span><br><span class="line">           <span class="keyword">if</span> (startFactory) &#123;</span><br><span class="line">               mQClientFactory.start();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> RUNNING:</span><br><span class="line">       <span class="keyword">case</span> START_FAILED:</span><br><span class="line">       <span class="keyword">case</span> SHUTDOWN_ALREADY:</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The producer service state not OK, maybe started once, "</span><span class="comment">//</span></span><br><span class="line">               + <span class="keyword">this</span>.serviceState<span class="comment">//</span></span><br><span class="line">               + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span><br><span class="line">               <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">default</span>:</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 发送心跳到所有的Broker</span></span><br><span class="line">   <span class="keyword">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最重要的内容即是创建<strong>MQ client</strong>，深入其中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MQClientInstance</span><span class="params">(ClientConfig clientConfig, <span class="keyword">int</span> instanceIndex, String clientId, RPCHook rpcHook)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="comment">// Broker回调Client时的处理器</span></span><br><span class="line">   <span class="keyword">this</span>.clientRemotingProcessor = <span class="keyword">new</span> ClientRemotingProcessor(<span class="keyword">this</span>);</span><br><span class="line">   <span class="keyword">this</span>.mQClientAPIImpl = <span class="keyword">new</span> MQClientAPIImpl(<span class="keyword">this</span>.nettyClientConfig, <span class="keyword">this</span>.clientRemotingProcessor, rpcHook, clientConfig);</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.clientConfig.getNamesrvAddr() != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// 更新NameServer</span></span><br><span class="line">       <span class="keyword">this</span>.mQClientAPIImpl.updateNameServerAddressList(<span class="keyword">this</span>.clientConfig.getNamesrvAddr());</span><br><span class="line">       log.info(<span class="string">"user specified name server address: &#123;&#125;"</span>, <span class="keyword">this</span>.clientConfig.getNamesrvAddr());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MQClientAPIImpl</span><span class="params">(<span class="keyword">final</span> NettyClientConfig nettyClientConfig, <span class="keyword">final</span> ClientRemotingProcessor clientRemotingProcessor,</span></span></span><br><span class="line"><span class="function"><span class="params">        RPCHook rpcHook, <span class="keyword">final</span> ClientConfig clientConfig)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.clientConfig = clientConfig;</span><br><span class="line">   topAddressing = <span class="keyword">new</span> TopAddressing(MixAll.WS_ADDR, clientConfig.getUnitName());</span><br><span class="line">   <span class="keyword">this</span>.remotingClient = <span class="keyword">new</span> NettyRemotingClient(nettyClientConfig, <span class="keyword">null</span>);</span><br><span class="line">   <span class="keyword">this</span>.clientRemotingProcessor = clientRemotingProcessor;</span><br><span class="line">   <span class="keyword">this</span>.remotingClient.registerRPCHook(rpcHook);</span><br><span class="line">   <span class="comment">//注册服务</span></span><br><span class="line">   <span class="keyword">this</span>.remotingClient.registerProcessor(RequestCode.CHECK_TRANSACTION_STATE, <span class="keyword">this</span>.clientRemotingProcessor, <span class="keyword">null</span>);</span><br><span class="line">   <span class="keyword">this</span>.remotingClient.registerProcessor(RequestCode.NOTIFY_CONSUMER_IDS_CHANGED, <span class="keyword">this</span>.clientRemotingProcessor, <span class="keyword">null</span>);</span><br><span class="line">   <span class="keyword">this</span>.remotingClient.registerProcessor(RequestCode.RESET_CONSUMER_CLIENT_OFFSET, <span class="keyword">this</span>.clientRemotingProcessor, <span class="keyword">null</span>);</span><br><span class="line">   <span class="keyword">this</span>.remotingClient.registerProcessor(RequestCode.GET_CONSUMER_STATUS_FROM_CLIENT, <span class="keyword">this</span>.clientRemotingProcessor, <span class="keyword">null</span>);</span><br><span class="line">   <span class="keyword">this</span>.remotingClient.registerProcessor(RequestCode.GET_CONSUMER_RUNNING_INFO, <span class="keyword">this</span>.clientRemotingProcessor, <span class="keyword">null</span>);</span><br><span class="line">   <span class="keyword">this</span>.remotingClient.registerProcessor(RequestCode.CONSUME_MESSAGE_DIRECTLY, <span class="keyword">this</span>.clientRemotingProcessor, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例化完成员变量后，触发<code>start()</code>方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">       <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">           <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">               <span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.clientConfig.getNamesrvAddr()) &#123;</span><br><span class="line">                   <span class="comment">//拉取NameServer地址信息</span></span><br><span class="line">                   <span class="keyword">this</span>.mQClientAPIImpl.fetchNameServerAddr();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 开启连接，注意长连接即可以发送请求，同时也可以接收请求</span></span><br><span class="line">               <span class="keyword">this</span>.mQClientAPIImpl.start();</span><br><span class="line">               <span class="comment">// 开启各种任务</span></span><br><span class="line">               <span class="keyword">this</span>.startScheduledTask();</span><br><span class="line">               <span class="comment">// 开启拉取服务，只对consumer起作用</span></span><br><span class="line">               <span class="keyword">this</span>.pullMessageService.start();</span><br><span class="line">               <span class="comment">// 开启负载服务，只对consumer起作用</span></span><br><span class="line">               <span class="keyword">this</span>.rebalanceService.start();</span><br><span class="line">               <span class="keyword">this</span>.defaultMQProducer.getDefaultMQProducerImpl().start(<span class="keyword">false</span>);</span><br><span class="line">               <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> RUNNING:</span><br><span class="line">               <span class="comment">//...</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开启后台异步任务</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startScheduledTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.clientConfig.getNamesrvAddr()) &#123;</span><br><span class="line">       <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="comment">// 拉取 NameServer Addr</span></span><br><span class="line">               MQClientInstance.<span class="keyword">this</span>.mQClientAPIImpl.fetchNameServerAddr();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">//拉取 路由信息</span></span><br><span class="line">           MQClientInstance.<span class="keyword">this</span>.updateTopicRouteInfoFromNameServer();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;, <span class="number">10</span>, <span class="keyword">this</span>.clientConfig.getPollNameServerInteval(), TimeUnit.MILLISECONDS);</span><br><span class="line">   <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">//清楚下线的broker</span></span><br><span class="line">           MQClientInstance.<span class="keyword">this</span>.cleanOfflineBroker();</span><br><span class="line">           <span class="comment">//向所有broker发送心跳</span></span><br><span class="line">  MQClientInstance.<span class="keyword">this</span>.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;, <span class="number">1000</span>, <span class="keyword">this</span>.clientConfig.getHeartbeatBrokerInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line">   <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 定时持久化消费偏移信息</span></span><br><span class="line">           MQClientInstance.<span class="keyword">this</span>.persistAllConsumerOffset();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="keyword">this</span>.clientConfig.getPersistConsumerOffsetInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line">   <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           MQClientInstance.<span class="keyword">this</span>.adjustThreadPool();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过已上代码发现，<code>RocektMQ</code>在处理这块时比较粗糙，在<code>MQClientInstance</code>里，<code>Producer</code>和<code>Consumer</code>的逻辑揉在一起。</p>
<h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><p><code>Consumer</code>有两种模式，<code>MQPullConsumer</code>和<code>MQPushConsumer</code>。推拉模式，拉模式需要自己手动去拉取更新，而推的方式则支持添加监听器，自动拉取(长轮询拉取，Push)消息进行消费。<br><img src="/media/15263105740760.jpg" alt=""><br>由于<code>Pull</code>方式比较简单，因此后面我们主要分析<code>Push</code>的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMQPushConsumer</span><span class="params">(<span class="keyword">final</span> String consumerGroup, RPCHook rpcHook, AllocateMessageQueueStrategy allocateMessageQueueStrategy)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.consumerGroup = consumerGroup;</span><br><span class="line">   <span class="comment">// 消息队列分配策略，即一个topic下所有queue按某种策略分配给不同的consumer</span></span><br><span class="line">   <span class="keyword">this</span>.allocateMessageQueueStrategy = allocateMessageQueueStrategy;</span><br><span class="line">   <span class="comment">//消息发送实现</span></span><br><span class="line">   defaultMQPushConsumerImpl = <span class="keyword">new</span> DefaultMQPushConsumerImpl(<span class="keyword">this</span>, rpcHook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再初始化前先订阅某个<code>topic</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(topic, <span class="string">"*"</span>);</span><br></pre></td></tr></table></figure>
<p>然后，再注册消息监听器。当新消息到达时进行消费。</p>
<p><code>DefaultMQPushConsumer.start()</code>进行初始化并开始消费消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">   <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">       <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">           <span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line">           <span class="comment">// 检查配置</span></span><br><span class="line">           <span class="keyword">this</span>.checkConfig();</span><br><span class="line">           <span class="comment">// 复制订阅数据</span></span><br><span class="line">           <span class="keyword">this</span>.copySubscription();</span><br><span class="line">           <span class="comment">// 设置instanceName</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) &#123;</span><br><span class="line">               <span class="keyword">this</span>.defaultMQPushConsumer.changeInstanceNameToPID();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 获取并创建MQClient，与Producer初始化过程相同</span></span><br><span class="line">           <span class="keyword">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class="keyword">this</span>.defaultMQPushConsumer, <span class="keyword">this</span>.rpcHook);</span><br><span class="line">           <span class="comment">// 设置负载均衡器属性</span></span><br><span class="line">           <span class="keyword">this</span>.rebalanceImpl.setConsumerGroup(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">           <span class="keyword">this</span>.rebalanceImpl.setMessageModel(<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel());</span><br><span class="line">           <span class="keyword">this</span>.rebalanceImpl.setAllocateMessageQueueStrategy(<span class="keyword">this</span>.defaultMQPushConsumer.getAllocateMessageQueueStrategy());</span><br><span class="line">           <span class="keyword">this</span>.rebalanceImpl.setmQClientFactory(<span class="keyword">this</span>.mQClientFactory);</span><br><span class="line">           <span class="comment">// 封装消息拉取API</span></span><br><span class="line">           <span class="keyword">this</span>.pullAPIWrapper = <span class="keyword">new</span> PullAPIWrapper(</span><br><span class="line">               mQClientFactory,</span><br><span class="line">               <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());</span><br><span class="line">           <span class="keyword">this</span>.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList);</span><br><span class="line">           <span class="comment">// 获取消费偏移存储，集群消费时，其类型为RemoteFileOffsetStore（从Broker获取偏移）；广播消费时，其类型为LocalFileOffsetStore。</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getOffsetStore() != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">this</span>.offsetStore = <span class="keyword">this</span>.defaultMQPushConsumer.getOffsetStore();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">switch</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">                   <span class="keyword">case</span> BROADCASTING:</span><br><span class="line">                       <span class="keyword">this</span>.offsetStore = <span class="keyword">new</span> LocalFileOffsetStore(<span class="keyword">this</span>.mQClientFactory, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">case</span> CLUSTERING:</span><br><span class="line">                       <span class="keyword">this</span>.offsetStore = <span class="keyword">new</span> RemoteBrokerOffsetStore(<span class="keyword">this</span>.mQClientFactory, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">default</span>:</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">this</span>.offsetStore.load();</span><br><span class="line">           <span class="comment">// 设置消费消息服务，当要求是 顺序消费时，其类型为 ConsumeMessageOrderlyService；否则为 ConsumeMessageConcurrentlyService。</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerOrderly) &#123;</span><br><span class="line">               <span class="keyword">this</span>.consumeOrderly = <span class="keyword">true</span>;</span><br><span class="line">               <span class="keyword">this</span>.consumeMessageService = <span class="keyword">new</span> ConsumeMessageOrderlyService(<span class="keyword">this</span>, (MessageListenerOrderly) <span class="keyword">this</span>.getMessageListenerInner());</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerConcurrently) &#123;</span><br><span class="line">               <span class="keyword">this</span>.consumeOrderly = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">this</span>.consumeMessageService = <span class="keyword">new</span> ConsumeMessageConcurrentlyService(<span class="keyword">this</span>, (MessageListenerConcurrently) <span class="keyword">this</span>.getMessageListenerInner());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">this</span>.consumeMessageService.start();</span><br><span class="line">           <span class="keyword">boolean</span> registerOK = mQClientFactory.registerConsumer(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), <span class="keyword">this</span>);</span><br><span class="line">           mQClientFactory.start();</span><br><span class="line">           <span class="comment">// 设置服务状态</span></span><br><span class="line">           <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> <span class="comment">//...</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 更新路由信息</span></span><br><span class="line">   <span class="keyword">this</span>.updateTopicSubscribeInfoWhenSubscriptionChanged();</span><br><span class="line">   <span class="comment">// 向Broker发送心跳</span></span><br><span class="line">   <span class="keyword">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">   <span class="comment">// 首次重负载，即拉取决定需要消费哪些队列，并开始拉取消费</span></span><br><span class="line">   <span class="comment">// 此外，`RebalanceService`服务会起一个定时任务，每20S进行一次调整消费重负载。对于新增的需要构建`PullRequest`参数发起消息拉取请求，对于剔除的则需要从本地移除，并让本地consumer不再消费相应的队列。</span></span><br><span class="line">   <span class="keyword">this</span>.mQClientFactory.rebalanceImmediately();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此各组件启动初始化的过程就介绍完了。<br>有了前几章节的铺垫，接下来的章节重点带大家一开看 消息发送到接收再到消费的过程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2018/03/19/database/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/19/database/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" itemprop="url">分布式事务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-19T15:10:13+08:00">2018-03-19</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/database/" itemprop="url" rel="index"><span itemprop="name">database</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><p>[TOC]</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a><strong>事务</strong></h2><blockquote>
</blockquote>
<p><strong>Transactions</strong> provide an “<strong>all-or-nothing</strong>“ proposition, stating that each work-unit performed in a database <strong>must either complete</strong> in its entirety or <strong>have no effect</strong> whatsoever.</p>
<blockquote>
<p><strong>事务</strong>应该具有4个属性：<strong>原子性</strong>、<strong>一致性</strong>、<strong>隔离性</strong>、<strong>持久性</strong></p>
</blockquote>
<h2 id="分布式事务场景"><a href="#分布式事务场景" class="headerlink" title="分布式事务场景"></a><strong>分布式事务场景</strong></h2><h3 id="什么是分布式事务"><a href="#什么是分布式事务" class="headerlink" title="什么是分布式事务"></a><strong>什么是分布式事务</strong></h3><blockquote>
<p><strong><code>A distributed transaction</code></strong> is a database transaction in which two or more network hosts are involved. Usually, hosts provide transactional resources… <a href="https://en.wikipedia.org/wiki/Distributed_transaction" target="_blank" rel="noopener">Wiki Definition</a><br>分布式事务是指<strong>多个提供事务资源的网络节点</strong>参与的数据库事务<br><strong>跨越多个服务，操作多个数据库</strong>。保证对于多个资源服务器的数据的操作，<strong>要么全部成功，要么全部失败</strong>。本质上来说，是为了保证不同资源服务器的数据一致性。</p>
</blockquote>
<h3 id="典型场景："><a href="#典型场景：" class="headerlink" title="典型场景："></a><strong>典型场景：</strong></h3><ul>
<li><p><strong>单服务，夸库事务</strong></p>
<ul>
<li><p>不同业务库</p>
</li>
<li><p>分库分表</p>
<p><img src="/media/15216185369960.png" alt="set up-w400"></p>
</li>
</ul>
</li>
<li><p><strong>服务化（多业务服务）</strong><br><img src="/media/15216185969205.png" alt="set up-w420">   </p>
</li>
</ul>
<h2 id="分布式系统理论"><a href="#分布式系统理论" class="headerlink" title="分布式系统理论"></a><strong>分布式系统理论</strong></h2><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a><strong>CAP</strong></h3><p>在设计一个分布式系统的时候，会遇到<strong>三个特性</strong>，而一个分布式系统<strong>最多只能满足其中的2项</strong>：</p>
<ol>
<li><strong>一致性</strong>：等同于所有节点访问<strong>同一份最新的数据副本</strong>（<code>all nodes see the same data at the same time</code>）。即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致，不能存在中间状态。关于一致性：<ol>
<li><strong>强一致性：</strong>时刻保证数据都是一致的；</li>
<li><strong>最终一致性：</strong>允许存在中间状态，只要求经过一段时间后，数据最终一致；</li>
<li><strong>弱一致性：</strong>如果允许存在部分数据不一致。</li>
</ol>
</li>
<li><strong>可用性</strong>：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。</li>
<li><strong>分区容错性</strong>：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</li>
</ol>
<p><strong>分区容错性</strong>是分布式系统最基本的要求。因此需要把精力花在如何根据业务特点在C（一致性）和A（可用性）之间寻求平衡。</p>
<h3 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a><strong>BASE</strong></h3><p><code>BASE</code>理论是对<code>CAP</code>中一致性和可用性权衡的结果。核心思想是即使无法做到强一致性，但应用可以根据自身特点采用适当的方式达到最终一致性。</p>
<ol>
<li><strong>基本可用（Basically Available）</strong><br>指分布式系统在出现不可预知故障的时候，允许损失部分可用性。</li>
<li><strong>软状态（ Soft State）</strong><br>指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性。</li>
<li><strong>最终一致（ Eventual Consistency）</strong><br>强调的是所有的数据更新操作，在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</li>
</ol>
<p><code>BASE</code>通过<strong>牺牲强一致性</strong>来获得<strong>可用性</strong>。允许数据在一段时间内是不一致，但最终达到一致状态。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，<code>ACID</code>特性和<code>BASE</code>理论往往又会结合在一起。</p>
<h2 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a><strong>分布式事务解决方案</strong></h2><ul>
<li><strong>强调一致性</strong>的分布式解决方案：<code>XA|JTA 两阶段提交协议</code>，由于<strong>可用性较低，实际应用的并不多</strong>。</li>
<li>基于<strong>BASE理论</strong>，<strong>强调可用性</strong>的分布式解决方案：<code>TCC</code>、<code>TXC</code>、<code>最大努力通知</code>、<code>可靠消息</code>。</li>
</ul>
<p>从<strong>架构、运作原理、缺点、实现</strong>层面逐个解释他们的运行原理。</p>
<h3 id="强一致性方案"><a href="#强一致性方案" class="headerlink" title="强一致性方案"></a><strong>强一致性方案</strong></h3><h4 id="XA-JTA"><a href="#XA-JTA" class="headerlink" title="XA/JTA"></a><strong>XA/JTA</strong></h4><p><code>XA</code>，<code>JTA(Java Transaction API)</code>是<code>XA</code>的JAVA版本规范。</p>
<ul>
<li><p><strong>架构</strong><br> <img src="/media/15216787843469.png" alt="set up-w520"></p>
<blockquote>
<p><strong>应用程序(Application Program ，简称AP)</strong>：用于定义事务边界(即定义事务的开始和结束)，并且在事务边界内对资源进行操作<br><strong>资源管理器(Resource Manager，简称RM)</strong>：如数据库、文件系统等，并提供访问资源的方式。<br><strong>事务管理器(Transaction Manager ，简称TM)</strong>：负责分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚等。</p>
</blockquote>
</li>
</ul>
<p><code>两阶段提交协议（Two Phase Commit）</code>的升级版</p>
<ul>
<li><p><strong>运作流程</strong></p>
<ul>
<li>步骤1：<code>AP</code>向<code>TM</code>创建全局事务，<code>TM</code>向<code>AP</code>返回全局事务号。</li>
<li>步骤2：<code>AP</code>使用全局事务号，访问<code>RM</code>的资源（当RM为数据库时，资源访问就是SQL操作）。当RM第一次收到访问时，使用该全局事务号向TM注册，TM返回事务分支事务号。</li>
<li>步骤3：<code>AP</code>向<code>TM</code>发出全局事务提交请求，<code>TM</code>与参与事务的<code>RM</code>通信，进行提交处理，全部完成后，向<code>AP</code>返回结果。</li>
</ul>
</li>
<li><p><strong>改进：</strong></p>
<blockquote>
<p><strong>只读断言</strong>: 在<code>阶段1</code>中，<code>RM</code>可以断言“我这边不涉及数据增删改”来答复TM的prepare请求，从而让这个<code>RM</code>脱离当前的全局事务，从而免去了Phase 2。<br>这种优化发生在<strong>其他RM都完成prepare之前的话</strong>，使用了只读断言的<code>RM</code>早于<code>AP</code>其他动作（比如说这个RM返回那些只读数据给AP）前，就释放了相关数据的上下文（比如读锁之类的），这时候其他全局事务或者本地事务就有机会去改变这些数据，结果就是无法保障整个系统的可序列化特性——通俗点说那就会有脏读的风险。<br><strong>一阶段提交</strong>: 如果需要增删改的数据都在同一个RM上，TM可以使用一阶段提交——跳过两阶段提交中的<code>阶段1</code>，直接执行<code>阶段2</code>。</p>
</blockquote>
</li>
<li><p><strong>缺点</strong></p>
<ul>
<li><strong>同步阻塞</strong>：两阶段提交方案下全局事务的<code>ACID</code>特性，是依赖于RM的。</li>
<li><strong>单点故障</strong>：由于协调者的重要性，一旦协调者TM发生故障。参与者RM会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</li>
</ul>
</li>
<li><p><strong>实现</strong></p>
<ul>
<li><a href="https://www.atomikos.com/Main/WebHome" target="_blank" rel="noopener">atomikos</a>、<a href="https://wiki.sankuai.com/pages/viewpage.action?pageId=1296636627" target="_blank" rel="noopener">atomikos JTA/XA分布式事务</a></li>
<li><a href="https://github.com/liuyangming/ByteJTA" target="_blank" rel="noopener">ByteJTA</a>、<a href="https://wiki.sankuai.com/pages/viewpage.action?pageId=1341359266" target="_blank" rel="noopener">JTA规范</a></li>
<li><a href="https://wiki.sankuai.com/pages/viewpage.action?pageId=1341359247" target="_blank" rel="noopener">MySQL对XA事务的支持</a></li>
</ul>
</li>
</ul>
<h3 id="柔性事务方案-最终一致性"><a href="#柔性事务方案-最终一致性" class="headerlink" title="柔性事务方案(最终一致性)"></a><strong>柔性事务方案(最终一致性)</strong></h3><h4 id="TCC（Try-Confirm-Cancel）"><a href="#TCC（Try-Confirm-Cancel）" class="headerlink" title="TCC（Try-Confirm-Cancel）"></a><strong>TCC（<code>Try-Confirm-Cancel</code>）</strong></h4><p><strong>TCC</strong>方案是目前最火的一种柔性事务方案。通过对（<code>由业务系统提供的</code>）<strong>业务逻辑的调度</strong>来实现分布式事务。TCC事务机制需要业务系统提供三段业务逻辑：<code>初步操作Try</code>、<code>确认操作Confirm</code>、<code>取消操作Cancel</code>。<br><strong>TCC</strong>将[传统事务机制]的业务逻辑 = [TCC事务机制]的初步操作<code>（Try）</code> + [TCC事务机制]的确认逻辑<code>（Confirm）</code>，<strong>TCC</strong>机制将传统事务机制中的业务逻辑一分为二，拆分后保留的部分即为初步操作<code>（Try）</code>；而分离出的部分即为确认操作<code>（Confirm）</code>，被延迟到事务提交阶段执行。<br>TCC事务机制以初步操作（Try）为中心，确认操作（Confirm）和取消操作（Cancel）都是围绕初步操作（Try）而展开。因此，Try阶段中的操作，其保障性是最好的，即使失败，仍然有取消操作（Cancel）可以将其不良影响进行回撤。</p>
<p><img src="/media/15217760504316.jpg" alt="set up-w520"></p>
<ol>
<li><p><strong>初步操作（Try）</strong><br>TCC事务机制中的业务逻辑（Try），从执行阶段来看，与传统事务机制中业务逻辑相同。但从业务角度来看，是不一样的。TCC机制中的Try仅是一个初步操作，它和后续的次确认一起才能真正构成一个完整的业务逻辑。</p>
</li>
<li><p><strong>确认操作（Confirm）</strong><br>确认操作（Confirm）是对初步操作（Try）的一个补充。当TCC事务管理器认为全局事务可以正确提交时，就会逐个执行初步操作（Try）指定的确认操作（Confirm），将初步操作（Try）未完成的事项最终完成。</p>
</li>
<li><p><strong>取消操作（Cancel）</strong><br>取消操作（Cancel）是对初步操作（Try）的一个回撤。当TCC事务管理器认为全局事务不能正确提交时，就会逐个执行初步操作（Try）指定的取消操作（Cancel），将初步操作（Try）已完成的事项全部撤回。</p>
</li>
</ol>
<p><strong>TCC事务模型的优缺点：</strong></p>
<ul>
<li><strong>优点：</strong>XA两阶段提交资源层面的，而TCC实际上把资源层面二阶段提交上提到了业务层面来实现。有效了的避免了XA两阶段提交占用资源锁时间过长导致的性能低下问题。</li>
<li><strong>缺点：</strong>主业务服务和从业务服务都需要进行<strong>改造</strong>，从业务方改造成本更高。牺牲了应用灵活性，需要开发人员实现事务检查与回滚的细节，面临着花费大量精力保证应用正确性的问题。<br><img src="/media/15217770349370.jpg" alt="set up-w520"></li>
</ul>
<ul>
<li><strong>实现</strong><ul>
<li><a href="https://github.com/liuyangming/ByteTCC" target="_blank" rel="noopener"><strong>ByteTCC</strong></a></li>
<li><a href="https://github.com/changmingxie/tcc-transaction" target="_blank" rel="noopener"><strong>Tcc-transaction</strong></a></li>
<li><a href="https://www.atomikos.com/Main/WebHome" target="_blank" rel="noopener"><strong>Atomikos ExtremeTransactions</strong></a></li>
<li><a href="https://github.com/prontera/spring-cloud-rest-tcc" target="_blank" rel="noopener"><strong>spring-cloud-rest-tcc</strong></a></li>
<li><a href="http://www.cloud.alipay.com/docs/2/47343" target="_blank" rel="noopener">DTS</a></li>
</ul>
</li>
</ul>
<h4 id="TXC-GTS"><a href="#TXC-GTS" class="headerlink" title="TXC/GTS"></a><strong>TXC/GTS</strong></h4><p>  阿里提出了<strong>TXC|GTS</strong>，<strong>GTS</strong>方案认为XA性能低效的根本原因是采用了<strong>阻塞协议</strong>。在分布式事务提交的第一阶段<strong>等待最慢的一个事务分支完成</strong>，即使在不存在锁冲突的情况下，各事务分支的数据库连接依然会被挂起所占用的资源都不能够释放，以防止全局事务提交前释放资源所造成的数据不一致。对于业务流量极高的大规模互联网企业，难以接受<code>XA</code>两阶段提交协议所带来的巨大性能开销。<br>可以说<strong>TXC</strong>是一个通用的事务引擎：有三种模式：</p>
<p><img src="/media/15220497050384.png" alt="set up-w620"><br>处理流程与XA一致，也包括<code>全局事务注册</code>、<code>数据访问</code>与<code>全局事务提交</code>三个步骤。不同在于：</p>
<ul>
<li>第二步数据访问中，各事务分支完成数据操作的同时，会将全局事务信息（锁与日志信息）存储在当前数据库的表中。</li>
<li>第三步全局事务提交中，采用一阶段本地事务提交+二阶段异步清理的方式。首先对各数据库做本地事务的提交，并释放数据库连接等系统资源，然后，向TM发出全局事务提交请求，TM收到请求后，立即返回成功，TM后续实际工作是对各个数据库使用全局事务标识符进行全局事务信息的清理。</li>
</ul>
<p><strong>GTS</strong>与<strong>XA</strong>在全局事务的故障恢复处理与并发控制采用了不同的实现机制：</p>
<ul>
<li>XA两阶段协议是基于数据库内核的日志与锁信息实现全局事务的回滚与并发控制。由于GTS一阶段本地事务提交中，会直接提交本地事务并释放连接，此时数据库内核的日志与锁表对全局事务不再有效。在第二步中，GTS会将日志和锁信息存储在表中，当事务本地提交后，日志和锁信息被持久化保存，用于实现全局事务的并发控制与故障恢复。</li>
<li><strong>GTS</strong>的故障恢复只有UNDO操作没有REDO操作，日志表中存储了UNDO需要的信息，包括行记录标识、全局事务号、镜像查询语句、操作的前像与操作的后像。当发生故障时，对于已经本地提交的数据库，从UNDO表中找到修改的记录，记录的操作前像和操作后像，使用镜像查询语句从数据库中读取该记录的当前值。如果当前值与记录操作后像相同，则直接使用操作前像进行恢复，否则报警，进行人工处理。</li>
<li><strong>GTS</strong>的全局锁表中存储了记录的加锁信息。封锁的粒度是行（记录），锁的类型包括共享锁和互斥锁，对于同一个记录，加锁的规则是共享锁与共享锁不冲突，共享锁与互斥锁冲突、互斥锁与互斥锁冲突。对插入(INSERT)、修改(UPDATE)、删除(DELETE)、更新模式的锁定查询(SELECT… FOR UPDATE) 操作加互斥锁。对于共享模式的锁定查询 (SELECT…LOCK IN SHARE MODE) 操作加共享锁。若没有锁冲突，在GTS锁表中，增加一行记录，表示加锁成功。</li>
<li><strong>GTS</strong>的默认隔离级别为<strong>读未提交（脏数据）</strong>，使用<code>SELECT… FOR UPDATE</code>和<code>SELECT…LOCK IN SHARE MODE</code>，可使查询隔离级别提升至<strong>读已提交</strong>。</li>
</ul>
<h5 id="架构"><a href="#架构" class="headerlink" title="架构"></a><strong>架构</strong></h5><p><img src="/media/15220506747998.jpg" alt="set up-w520"><br>与<code>XA</code>架构相同，<code>GTS</code>架构由<code>应用</code>、<code>事务管理器</code>、<code>资源管理器</code>三个部分组成。资源管理器由<strong>事务分支处理模块</strong>、<strong>镜像查询构造模块</strong>、<strong>并发控制模块</strong>、<strong>恢复控制模块</strong>，以及存储在数据库中的<code>GTS</code>事务信息（<code>GTS锁表与GTS日志表</code>）等组成。</p>
<ul>
<li><strong>事务分支处理模块</strong>：是资源管理器的外部接口，并完成内部各模块的调用。</li>
<li><strong>镜像查询构造模块</strong>：从<code>Insert、Update、Delete</code>语句，生成该操作对应记录集的镜像查询语句。例如table_name表包含两个字段column1和column2，column1为主键，则镜像查询语句为select column1, column2 from table_name where column1=v1。</li>
<li><strong>并发控制模块</strong>：基于GTS事务锁表，维护读写并发控制。锁表定义如下：</li>
</ul>
<h5 id="主要流程序列图"><a href="#主要流程序列图" class="headerlink" title="主要流程序列图"></a><strong>主要流程序列图</strong></h5><p>分别描述了<code>insert/delete/update</code>操作、读已提交操作、提交操作和回滚操作等四个操作的序列图（一种可能的实现方式）。</p>
<p><strong>insert/delete/update操作流程序列图：</strong><br><img src="/media/15220508581014.jpg" alt="set up-w520"></p>
<p><strong>读已提交操作流程序列图</strong><br><img src="/media/15220508805612.jpg" alt="set up-w520"></p>
<p><strong>提交操作流程序列图</strong><br><img src="/media/15220509043584.jpg" alt="set up-w520"></p>
<p><strong>回滚操作流程序列图</strong><br><img src="/media/15220509214947.jpg" alt="set up-w520"></p>
<h5 id="GTS的优势与约束"><a href="#GTS的优势与约束" class="headerlink" title="GTS的优势与约束"></a><strong>GTS的优势与约束</strong></h5><p>与基于消息队列与TCC补偿模式的分布式事务相比，在性能满足的情况下，GTS更好的应用灵活性与数据一致性：</p>
<ul>
<li><strong>灵活性</strong>：数据库应用基本实现零修改，同时，基于XA模型，可方便的支持消息队列数据库等多种RM。</li>
<li><strong>数据一致性</strong>：GTS 的缺省事务隔离级别为读未提交，该模式下可以达到分布式事务的最大性能，但可能会读到脏数据。对于一致性要求高的应用，在性能允许的情况下，可以采用已提交读语句（for update、lock in share mode）将隔离级别提升至读已提交。</li>
</ul>
<p>根据<code>GTS</code>实现机制的特点，其应用场景上有以下约束：<strong>加锁操作记录数量不能太大</strong>，<strong>操作冲突不能太多</strong>，<strong>加锁时间不能太长</strong>。违法以上约束时，<code>GTS</code>内部会<strong>占用过多资源</strong>、<strong>锁冲突和回滚增加，导致性能的下降</strong>。电商、物流、金融、零售行业中的核心交易场景有着高并发，高性能，单次操作数据集小，事务响应时间敏感的特点，GTS类方案在此类场景中有着广泛和良好的应用前景。</p>
<h5 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a><strong>事务隔离级别</strong></h5><p>在隔离性上TXC默认事务隔离级别的是<strong>读未提交(read uncommited)</strong>，避免了XA实现在分布式事务的情况下长时间占用锁的情况。在允许脏读的业务场景中，能充分发挥性能上的优势。<br>也同时提供<strong>读已提交</strong>隔离级别。实现原理是在<code>select</code>语句上加<code>hint</code>，<strong>TXC</strong>会牺牲性能，先做检测，如果相关记录已属于中间状态，则会过一段时间重试以读取最终状态，或者这段时间过去之后返回失败。</p>
<ul>
<li><strong>实现</strong><ul>
<li><a href="https://yq.aliyun.com/articles/334238?spm=5176.10695662.1996646101.searchclickresult.b3fd74852ffic1" target="_blank" rel="noopener">GTS解密–GTS的原理、架构与特点</a></li>
</ul>
</li>
</ul>
<h4 id="最大努力通知"><a href="#最大努力通知" class="headerlink" title="最大努力通知"></a><strong>最大努力通知</strong></h4><p>最简单的一种柔性事务，适用于一些最终一致性时间敏感度低的业务，适合于通知类场景。<code>对业务最终一致性时间敏感性低、跨企业的业务活动</code></p>
<p><strong>特点：</strong></p>
<ul>
<li><code>不可靠消息</code>：<strong>允许消息丢失</strong>。业务活动主动方，在完成业务处理之后，向业务活动的被动方发送消息，直到通知N次后不再通知。</li>
<li><code>定期校对</code>：业务主动方根据<strong>定时策略</strong>，向业务被动方查询发送状态，恢复丢失的业务消息。</li>
</ul>
<p><strong>运行过程</strong></p>
<p><img src="/media/15216887995414.png" alt=""></p>
<blockquote>
<p><strong>短信发送流程如下：</strong></p>
<ol>
<li>业务方将短信发送请求提交给短信平台</li>
<li>短信平台接收到要发送的短信，记录到数据库中，并标记其状态为”已接收”</li>
<li>短信平台调用外部短信发送供应商的接口，发送短信。外部供应商的接口也是异步将短信发送到用户手机上，因此这个接口调用后，立即返回，进入第4步。</li>
<li>更新短信发送状态为”已发送”</li>
<li>短信发送供应商异步通知短信平台短信发送结果。而通知可能失败，因此最多只会通知N次。</li>
<li>短信平台接收到短信发送结果后，更新短信发送状态，可能是成功，也可能失败(如手机欠费)。到底是成功还是失败并不重要，重要的是我们知道了这调短信发送的最终结果</li>
<li>如果最多只通知N次，如果都失败了的话，那么短信平台将不知道短信到底有没有成功发送。因此短信发送供应商需要提供一个查询接口，以方便短信平台驱动的去查询，进行定期校对。</li>
</ol>
</blockquote>
<p><strong>条件：</strong></p>
<ul>
<li><strong>业务方提供被动方事务执行状态通知回调接口</strong></li>
<li><strong>业务被动方提供状态查询接口</strong></li>
</ul>
<p><strong>约束：</strong></p>
<ul>
<li>被动方的处理结果不影响主动方的处理结果</li>
</ul>
<p><strong>实现案例：</strong></p>
<ul>
<li><a href="https://github.com/shardingjdbc/sharding-jdbc" target="_blank" rel="noopener">sharding-jdbc</a></li>
</ul>
<h4 id="可靠消息"><a href="#可靠消息" class="headerlink" title="可靠消息"></a><strong>可靠消息</strong></h4><p><strong>（基于<code>可靠消息</code>的最终一致性，可以异步，但数据绝对不能丢，而且一定要记账成功）</strong><br>业务处理服务在业务事务提交前，向实时消息服务请求发送消息，实时消息服务只记录消息数据，而不真正发送。业务处理服务在业务事务提交后，向实时消息服务确认发送。只有在得到确认发送指令后，实时消息服务才真正发送。</p>
<p><strong>两种方案：</strong>一种是<code>基于MQ的事务消息</code> (<code>RocketMQ、ActiveMQ、RabbitMQ</code>)<br><img src="/media/15216916228936.png" alt=""></p>
<p><strong>第一阶段</strong>，MQ发送Prepared消息时，会拿到消息的地址；<strong>第二阶段</strong>执行本地事务；<strong>第三阶段</strong>通过第一阶段拿到的地址去访问消息，并修改消息的状态。</p>
<p>如果确认消息发送失败了怎么办？RocketMQ会定期扫描消息集群中的事务消息，如果发现了Prepared消息，它会向消息发送端(生产者)确认。RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。<br>如果消费失败怎么办？阿里提供给我们的解决方法是：人工解决。</p>
<p>另外一种实现，并不是所有的MQ都支持事务消息，如kafka。此时可以使用独立消息服务或者本地事务表。<br><img src="/media/15216916321466.png" alt=""></p>
<h2 id="对比与场景事务选择"><a href="#对比与场景事务选择" class="headerlink" title="对比与场景事务选择"></a><strong>对比与场景事务选择</strong></h2><h3 id="TCC两阶段提交-VS-XA两阶段提交"><a href="#TCC两阶段提交-VS-XA两阶段提交" class="headerlink" title="TCC两阶段提交 VS XA两阶段提交"></a><strong>TCC两阶段提交 VS XA两阶段提交</strong></h3><p><img src="/media/15217194477235.png" alt=""></p>
<ol>
<li>在阶段1：<br> 在XA中，各个RM准备提交各自的事务分支，事实上就是准备提交资源的更新操作(insert、delete、update等)；而在TCC中，是主业务活动请求(try)各个从业务服务预留资源。</li>
<li>在阶段2：<br> XA根据第一阶段每个RM是否都prepare成功，判断是要提交还是回滚。如果都prepare成功，那么就commit每个事务分支，反之则rollback每个事务分支。TCC中，如果在第一阶段所有业务资源都预留成功，那么confirm各个从业务服务，否则取消(cancel)所有从业务服务的资源预留请求。</li>
</ol>
<p><strong>TCC两阶段提交与XA两阶段提交的区别是：</strong></p>
<ul>
<li><strong>XA是资源层面的分布式事务，强一致性，在两阶段提交的整个过程中，一直会持有资源的锁:</strong><pre><code>XA事务中的两阶段提交内部过程是对开发者屏蔽的，回顾我们之前讲解JTA规范时，通过UserTransaction的commit方法来提交全局事务，这只是一次方法调用，其内部会委派给TransactionManager进行真正的两阶段提交，因此开发者从代码层面是感知不到这个过程的。而事务管理器在两阶段提交过程中，从prepare到commit/rollback过程中，资源实际上一直都是被加锁的。如果有其他人需要更新这两条记录，那么就必须等待锁释放。</code></pre></li>
<li><strong>TCC是业务层面的分布式事务，最终一致性，不会一直持有资源的锁:</strong><br>   TCC中的两阶段提交并没有对开发者完全屏蔽，也就是说从代码层面，开发者是可以感受到两阶段提交的存在。如上述航班预定案例：在第一阶段，航空公司需要提供try接口(机票资源预留)。在第二阶段，航空公司提需要提供<code>confirm/cancel</code>接口(确认购买机票/取消预留)。开发者明显的感知到了两阶段提交过程的存在。<code>try、confirm/cancel</code>在执行过程中，一般都会开启各自的本地事务，来保证方法内部业务逻辑的<code>ACID</code>特性。</li>
</ul>
<h3 id="TXC-VS-XA两阶段提交"><a href="#TXC-VS-XA两阶段提交" class="headerlink" title="TXC VS XA两阶段提交"></a><strong>TXC VS XA两阶段提交</strong></h3><p><img src="/media/15217121225679.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2018/03/19/mq/3.rocketmq-%E5%AD%98%E5%82%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/19/mq/3.rocketmq-%E5%AD%98%E5%82%A8/" itemprop="url">RocketMQ 存储</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-19T00:00:00+08:00">2018-03-19</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/rocketmq/" itemprop="url" rel="index"><span itemprop="name">rocketmq</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="3-store"><a href="#3-store" class="headerlink" title="3. store"></a>3. store</h1><p>[TOC]</p>
<p>存储是<code>RocketMQ</code>中至关重要的一部分。<br><code>DefaultMessageStore</code>是<code>RocketMQ</code>中用于存储消息的入口。一条消息存储过程大致如图所示：<br><img src="/media/15262276039412.jpg" alt=""><br>首先通过调用<code>CommitLog.putMessage</code>方法将消息追加到<code>MappedFile</code>文件中，然后再以异步的形式进行构建<code>ConsumeQueue</code>，如果用户设置了Key则同时进行构建<code>Index</code>。</p>
<p>我们将从<code>DefaultMessageStore</code>的初始化和其追加消息来分析其工作原理。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>首先进行成员变量的初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMessageStore</span><span class="params">(<span class="keyword">final</span> MessageStoreConfig messageStoreConfig, <span class="keyword">final</span> BrokerStatsManager brokerStatsManager,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> MessageArrivingListener messageArrivingListener, <span class="keyword">final</span> BrokerConfig brokerConfig)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   <span class="comment">//当有新消息来时触发监听器（后面再讲Consumer的长轮询的时候会讲到）</span></span><br><span class="line">   <span class="keyword">this</span>.messageArrivingListener = messageArrivingListener;</span><br><span class="line">   <span class="keyword">this</span>.brokerConfig = brokerConfig;</span><br><span class="line">   <span class="keyword">this</span>.messageStoreConfig = messageStoreConfig;</span><br><span class="line">   <span class="comment">//状态管理</span></span><br><span class="line">   <span class="keyword">this</span>.brokerStatsManager = brokerStatsManager;</span><br><span class="line">   <span class="comment">//MapppedFile文件空间申请服务</span></span><br><span class="line">   <span class="keyword">this</span>.allocateMappedFileService = <span class="keyword">new</span> AllocateMappedFileService(<span class="keyword">this</span>);</span><br><span class="line">   <span class="comment">//提交日志，用于存放消息的地方，最关键的部分</span></span><br><span class="line">   <span class="keyword">this</span>.commitLog = <span class="keyword">new</span> CommitLog(<span class="keyword">this</span>);</span><br><span class="line">   <span class="comment">//消费队列表，用于保存每个topic下，每个queue的消费进度</span></span><br><span class="line">   <span class="keyword">this</span>.consumeQueueTable = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">32</span>);</span><br><span class="line">   <span class="comment">//负责将消费队列表进行刷盘的服务</span></span><br><span class="line">   <span class="keyword">this</span>.flushConsumeQueueService = <span class="keyword">new</span> FlushConsumeQueueService();</span><br><span class="line">   <span class="comment">//负责定时清理旧消息文件的后台服务</span></span><br><span class="line">   <span class="keyword">this</span>.cleanCommitLogService = <span class="keyword">new</span> CleanCommitLogService();</span><br><span class="line">   <span class="comment">//负责定时清理旧消费队列文件的后台服务</span></span><br><span class="line">   <span class="keyword">this</span>.cleanConsumeQueueService = <span class="keyword">new</span> CleanConsumeQueueService();</span><br><span class="line">   <span class="comment">// 存储状态的服务</span></span><br><span class="line">   <span class="keyword">this</span>.storeStatsService = <span class="keyword">new</span> StoreStatsService();</span><br><span class="line">   <span class="comment">//索引服务</span></span><br><span class="line">   <span class="keyword">this</span>.indexService = <span class="keyword">new</span> IndexService(<span class="keyword">this</span>);</span><br><span class="line">   <span class="comment">// 主从同步服务</span></span><br><span class="line">   <span class="keyword">this</span>.haService = <span class="keyword">new</span> HAService(<span class="keyword">this</span>);</span><br><span class="line">   <span class="comment">//重放消息线程服务，用于从CommitLog中构建新增消息的ConsumeQueue并构建Index</span></span><br><span class="line">   <span class="keyword">this</span>.reputMessageService = <span class="keyword">new</span> ReputMessageService();</span><br><span class="line">   <span class="comment">//延时消息服务</span></span><br><span class="line">   <span class="keyword">this</span>.scheduleMessageService = <span class="keyword">new</span> ScheduleMessageService(<span class="keyword">this</span>);</span><br><span class="line">   <span class="comment">// 内存字节缓冲区</span></span><br><span class="line">   <span class="keyword">this</span>.transientStorePool = <span class="keyword">new</span> TransientStorePool(messageStoreConfig);</span><br><span class="line">   <span class="keyword">if</span> (messageStoreConfig.isTransientStorePoolEnable()) &#123;</span><br><span class="line">       <span class="keyword">this</span>.transientStorePool.init();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//开启文件分配后台线程</span></span><br><span class="line">   <span class="keyword">this</span>.allocateMappedFileService.start();</span><br><span class="line">   <span class="keyword">this</span>.indexService.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CommitLog</code>是消息存储中最重要的部分，因为其他损失了可以根据此部分来补齐。<code>CommitLog</code>内部也需要实例化成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CommitLog</span><span class="params">(<span class="keyword">final</span> DefaultMessageStore defaultMessageStore)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.mappedFileQueue = <span class="keyword">new</span> MappedFileQueue(defaultMessageStore.getMessageStoreConfig().getStorePathCommitLog(),</span><br><span class="line">       defaultMessageStore.getMessageStoreConfig().getMapedFileSizeCommitLog(), defaultMessageStore.getAllocateMappedFileService());</span><br><span class="line">   <span class="keyword">this</span>.defaultMessageStore = defaultMessageStore;</span><br><span class="line">   <span class="comment">// 当开始同步刷盘时，使用GroupCommitService，非同步时使用FlushRealTimeService。</span></span><br><span class="line">   <span class="keyword">if</span> (FlushDiskType.SYNC_FLUSH == defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) &#123;</span><br><span class="line">       <span class="keyword">this</span>.flushCommitLogService = <span class="keyword">new</span> GroupCommitService();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">this</span>.flushCommitLogService = <span class="keyword">new</span> FlushRealTimeService();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//当开启内存字节缓冲区时，使用此服务进行刷盘</span></span><br><span class="line">   <span class="keyword">this</span>.commitLogService = <span class="keyword">new</span> CommitRealTimeService();</span><br><span class="line">   <span class="comment">// 日志写入详细内容</span></span><br><span class="line">   <span class="keyword">this</span>.appendMessageCallback = <span class="keyword">new</span> DefaultAppendMessageCallback(defaultMessageStore.getMessageStoreConfig().getMaxMessageSize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>初始化完成员变量后，会执行一次<code>load()</code>方法。判断是否有历史文件，如果有则加载历史文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line">   <span class="comment">// 判断是否已经有文件存在，即判断是否是重启</span></span><br><span class="line">   <span class="keyword">boolean</span> lastExitOK = !<span class="keyword">this</span>.isTempFileExist();</span><br><span class="line">   log.info(<span class="string">"last shutdown &#123;&#125;"</span>, lastExitOK ? <span class="string">"normally"</span> : <span class="string">"abnormally"</span>);</span><br><span class="line">   <span class="comment">// 延时消息加载</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != scheduleMessageService) &#123;</span><br><span class="line">       result = result &amp;&amp; <span class="keyword">this</span>.scheduleMessageService.load();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// load Commit Log</span></span><br><span class="line">   result = result &amp;&amp; <span class="keyword">this</span>.commitLog.load();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// load Consume Queue</span></span><br><span class="line">   result = result &amp;&amp; <span class="keyword">this</span>.loadConsumeQueue(); <span class="comment">// TODO 待读</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="keyword">if</span> (result) &#123;</span><br><span class="line">       <span class="keyword">this</span>.storeCheckpoint =</span><br><span class="line">               <span class="keyword">new</span> StoreCheckpoint(StorePathConfigHelper.getStoreCheckpoint(<span class="keyword">this</span>.messageStoreConfig.getStorePathRootDir()));</span><br><span class="line">       <span class="comment">//加载Index文件</span></span><br><span class="line">       <span class="keyword">this</span>.indexService.load(lastExitOK);</span><br><span class="line">        <span class="comment">//重新计算FlushOffset、CommittedOffset</span></span><br><span class="line">       <span class="keyword">this</span>.recover(lastExitOK);</span><br><span class="line">       log.info(<span class="string">"load over, and the max phy offset = &#123;&#125;"</span>, <span class="keyword">this</span>.getMaxPhyOffset());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">       <span class="keyword">this</span>.allocateMappedFileService.shutdown();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化并加载完后，开启后台保障线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="comment">//开始消费队列表刷盘服务</span></span><br><span class="line">   <span class="keyword">this</span>.flushConsumeQueueService.start();</span><br><span class="line">   <span class="comment">// 开始后台消息日志刷盘服务（同步和异步）</span></span><br><span class="line">   <span class="keyword">this</span>.commitLog.start();</span><br><span class="line">   <span class="keyword">this</span>.storeStatsService.start();</span><br><span class="line">   <span class="comment">//开启 延时消息</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.scheduleMessageService != <span class="keyword">null</span> &amp;&amp; SLAVE != messageStoreConfig.getBrokerRole()) &#123;</span><br><span class="line">       <span class="keyword">this</span>.scheduleMessageService.start();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//开启消息重放服务，建立Index和ConsumeQueue</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageStoreConfig().isDuplicationEnable()) &#123;</span><br><span class="line">       <span class="keyword">this</span>.reputMessageService.setReputFromOffset(<span class="keyword">this</span>.commitLog.getConfirmOffset());</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">this</span>.reputMessageService.setReputFromOffset(<span class="keyword">this</span>.commitLog.getMaxOffset());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">this</span>.reputMessageService.start();</span><br><span class="line">   <span class="comment">//开启主从同步服务</span></span><br><span class="line">   <span class="keyword">this</span>.haService.start();</span><br><span class="line">   <span class="keyword">this</span>.createTempFile();</span><br><span class="line">   <span class="comment">//开启周期性清理旧文件服务</span></span><br><span class="line">   <span class="keyword">this</span>.addScheduleTask();</span><br><span class="line">   <span class="keyword">this</span>.shutdown = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再细看，<code>CommitLog</code>的<code>start</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//开启后台刷盘服务</span></span><br><span class="line">   <span class="keyword">this</span>.flushCommitLogService.start();</span><br><span class="line">   <span class="comment">// 只有开启内存字节缓冲区时，才会开始commitLogService</span></span><br><span class="line">   <span class="keyword">if</span> (defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) &#123;</span><br><span class="line">       <span class="keyword">this</span>.commitLogService.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化过程到此就结束了。</p>
<h2 id="消息存储"><a href="#消息存储" class="headerlink" title="消息存储"></a>消息存储</h2><p>消息存储入口在<code>DefaultMessageStore.putMessage</code>中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">putMessage</span><span class="params">(<span class="keyword">final</span> MessageExtBrokerInner msg)</span> </span>&#123;</span><br><span class="line">   msg.setStoreTimestamp(System.currentTimeMillis());</span><br><span class="line">   <span class="comment">// crc校验码，防止文件破损</span></span><br><span class="line">   msg.setBodyCRC(UtilAll.crc32(msg.getBody()));</span><br><span class="line">   AppendMessageResult result = <span class="keyword">null</span>;</span><br><span class="line">   StoreStatsService storeStatsService = <span class="keyword">this</span>.defaultMessageStore.getStoreStatsService();</span><br><span class="line">   String topic = msg.getTopic();</span><br><span class="line">   <span class="keyword">int</span> queueId = msg.getQueueId();</span><br><span class="line">   <span class="comment">// 定时消息处理</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());</span><br><span class="line">   <span class="keyword">if</span> (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE<span class="comment">//</span></span><br><span class="line">       || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) &#123;</span><br><span class="line">       <span class="comment">//延迟消息放到 SCHEDULE_TOPIC_XXXX topic的队列中</span></span><br><span class="line">       <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</span><br><span class="line">               msg.setDelayTimeLevel(<span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());</span><br><span class="line">           &#125;</span><br><span class="line">           topic = ScheduleMessageService.SCHEDULE_TOPIC;</span><br><span class="line">           <span class="comment">// 对于不同延时级别的消息放到不同的队列中 1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</span></span><br><span class="line">           queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</span><br><span class="line">           <span class="comment">// Backup real topic, queueId</span></span><br><span class="line">           MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());</span><br><span class="line">           MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));</span><br><span class="line">           msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line">           msg.setTopic(topic);</span><br><span class="line">           msg.setQueueId(queueId);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 获取写入映射文件</span></span><br><span class="line">   MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile();</span><br><span class="line">   <span class="comment">// 获取写入锁</span></span><br><span class="line">   lockForPutMessage(); <span class="comment">//spin...</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">long</span> beginLockTimestamp = <span class="keyword">this</span>.defaultMessageStore.getSystemClock().now();</span><br><span class="line">       <span class="keyword">this</span>.beginTimeInLock = beginLockTimestamp;</span><br><span class="line">       <span class="comment">// beginLockTimestamp 为了保证一个全局的有序性</span></span><br><span class="line">       msg.setStoreTimestamp(beginLockTimestamp);</span><br><span class="line">       <span class="comment">// 当不存在映射文件时，进行创建</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile || mappedFile.isFull()) &#123;</span><br><span class="line">           mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(<span class="number">0</span>); <span class="comment">// Mark: NewFile may be cause noise</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 存储消息，调用DefaultAppendMessageCallback将msg以RocketMQ要求的格式存入MappedFile 的Buffer(writeBuffer或者mappedByteBuffer)中</span></span><br><span class="line">       result = mappedFile.appendMessage(msg, <span class="keyword">this</span>.appendMessageCallback);</span><br><span class="line">       <span class="keyword">switch</span> (result.getStatus()) &#123;</span><br><span class="line">           <span class="keyword">case</span> PUT_OK:</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> END_OF_FILE: <span class="comment">// 当文件尾时，获取新的映射文件，并进行插入</span></span><br><span class="line">               <span class="comment">// Create a new file, re-write the message</span></span><br><span class="line">               mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(<span class="number">0</span>);</span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile) &#123;</span><br><span class="line">                   <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">                   log.error(<span class="string">"create maped file2 error, topic: "</span> + msg.getTopic() + <span class="string">" clientAddr: "</span> + msg.getBornHostString());</span><br><span class="line">                   beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, result);</span><br><span class="line">               &#125;</span><br><span class="line">               result = mappedFile.appendMessage(msg, <span class="keyword">this</span>.appendMessageCallback);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> ...;</span><br><span class="line">       &#125;</span><br><span class="line">       eclipseTimeInLock = <span class="keyword">this</span>.defaultMessageStore.getSystemClock().now() - beginLockTimestamp;</span><br><span class="line">       beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="comment">// 释放写入锁</span></span><br><span class="line">       releasePutMessageLock();</span><br><span class="line">   &#125;</span><br><span class="line">   PutMessageResult putMessageResult = <span class="keyword">new</span> PutMessageResult(PutMessageStatus.PUT_OK, result);</span><br><span class="line">   <span class="comment">// 进行同步||异步 flush||commit</span></span><br><span class="line">   GroupCommitRequest request = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (FlushDiskType.SYNC_FLUSH == <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) &#123;</span><br><span class="line">       <span class="comment">// 同步刷新，将buffer中的内容刷新到磁盘</span></span><br><span class="line">       <span class="keyword">final</span> GroupCommitService service = (GroupCommitService) <span class="keyword">this</span>.flushCommitLogService;</span><br><span class="line">       <span class="keyword">if</span> (msg.isWaitStoreMsgOK()) &#123;</span><br><span class="line">           request = <span class="keyword">new</span> GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());</span><br><span class="line">           service.putRequest(request);</span><br><span class="line">           <span class="comment">//同步等待刷新完成</span></span><br><span class="line">           <span class="keyword">boolean</span> flushOK = request.waitForFlush(<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());</span><br><span class="line">           <span class="keyword">if</span> (!flushOK) &#123;</span><br><span class="line">               log.error(<span class="string">"do groupcommit, wait for flush failed, topic: "</span> + msg.getTopic() + <span class="string">" tags: "</span> + msg.getTags()</span><br><span class="line">                   + <span class="string">" client address: "</span> + msg.getBornHostString());</span><br><span class="line">               putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_DISK_TIMEOUT);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           service.wakeup();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// 异步刷新</span></span><br><span class="line">       <span class="keyword">if</span> (!<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) &#123;</span><br><span class="line">           flushCommitLogService.wakeup(); <span class="comment">// important：唤醒commitLog线程，进行flush</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//这一步是因为用了缓存池，所以需要先将缓存池的内容写入fileChannel中，再刷到磁盘</span></span><br><span class="line">           commitLogService.wakeup();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果是同步Master，同步到从节点</span></span><br><span class="line">   <span class="keyword">if</span> (BrokerRole.SYNC_MASTER == <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getBrokerRole()) &#123;</span><br><span class="line">       HAService service = <span class="keyword">this</span>.defaultMessageStore.getHaService();</span><br><span class="line">       <span class="keyword">if</span> (msg.isWaitStoreMsgOK()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (service.isSlaveOK(result.getWroteOffset() + result.getWroteBytes())) &#123;</span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">null</span> == request) &#123;</span><br><span class="line">                   request = <span class="keyword">new</span> GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());</span><br><span class="line">               &#125;</span><br><span class="line">               service.putRequest(request);</span><br><span class="line">               <span class="comment">// 唤醒WriteSocketService</span></span><br><span class="line">               service.getWaitNotifyObject().wakeupAll();</span><br><span class="line">               <span class="keyword">boolean</span> flushOK = request.waitForFlush(<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());</span><br><span class="line">               <span class="keyword">if</span> (!flushOK) &#123;</span><br><span class="line">                   log.error(<span class="string">"do sync transfer other node, wait return, but failed, topic: "</span> + msg.getTopic() + <span class="string">" tags: "</span></span><br><span class="line">                       + msg.getTags() + <span class="string">" client address: "</span> + msg.getBornHostString());</span><br><span class="line">                   putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_SLAVE_TIMEOUT);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               putMessageResult.setPutMessageStatus(PutMessageStatus.SLAVE_NOT_AVAILABLE);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> putMessageResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mappedFile.appendMessage</code>操作只是将消息写入<code>buffer</code>中，而<code>FlushCommitLogService</code>负责将<code>buffer</code>内容刷到磁盘中。<br><code>FlushCommitLogService</code>有三种实现：<br><img src="/media/15262783557950.jpg" alt=""></p>
<ul>
<li><strong>GroupCommitService</strong>: 负责同步刷盘；</li>
<li><strong>CommitRealTimeService</strong>: 执行周期200ms，将字节缓存区的字节写到<code>mappedFile</code>对应的<code>FileChannel</code>中<code>(PageCache)</code>中(FileChannel.write(buffer))；</li>
<li><strong>FlushRealTimeService</strong>:执行周期500ms，将<code>PageCache</code>中的内容刷新到磁盘<ul>
<li><code>mappedByteBuffer.fore()</code>(没有字节缓存去时)</li>
<li><code>this.fileChannel.force(false)</code>（有字节缓存区时）</li>
</ul>
</li>
</ul>
<h3 id="消息回放"><a href="#消息回放" class="headerlink" title="消息回放"></a>消息回放</h3><p>写完日志后，再继续看如何构建<code>ConsumeQueue</code>和<code>IndexFile</code>:</p>
<p>构建<code>ConsumeQueue</code>和<code>IndexFile</code>是由<code>ReputMessageService</code>服务发起，从字面意思也可理解：<code>重放消息服务</code>，意思是重新从<code>CommitLog</code>中捞起消息消费。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">boolean</span> doNext = <span class="keyword">true</span>; <span class="keyword">this</span>.isCommitLogAvailable() &amp;&amp; doNext; ) &#123;</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().isDuplicationEnable()</span><br><span class="line">          &amp;&amp; <span class="keyword">this</span>.reputFromOffset &gt;= DefaultMessageStore.<span class="keyword">this</span>.getConfirmOffset()) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 获取上一次回放偏移reputFromOffset之后的日志内容</span></span><br><span class="line">      SelectMappedBufferResult result = DefaultMessageStore.<span class="keyword">this</span>.commitLog.getData(reputFromOffset);</span><br><span class="line">      <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">this</span>.reputFromOffset = result.getStartOffset();</span><br><span class="line">              <span class="comment">// 遍历MappedByteBuffer</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> readSize = <span class="number">0</span>; readSize &lt; result.getSize() &amp;&amp; doNext; ) &#123;</span><br><span class="line">                  <span class="comment">// 一条条取出消息，并提取日志信息，如偏移，日志大小，存储时间，tagCode 等</span></span><br><span class="line">                  DispatchRequest dispatchRequest = DefaultMessageStore.<span class="keyword">this</span>.commitLog.checkMessageAndReturnSize(result.getByteBuffer(), <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">                  <span class="keyword">int</span> size = dispatchRequest.getMsgSize(); <span class="comment">// 消息长度</span></span><br><span class="line">                  <span class="comment">// 根据请求的结果处理</span></span><br><span class="line">                  <span class="keyword">if</span> (dispatchRequest.isSuccess()) &#123; <span class="comment">// 读取成功</span></span><br><span class="line">                      <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                          <span class="comment">// 执行调用请求，将消息的偏移等信息追加到ConsumeQueue中，并建立索引</span></span><br><span class="line">                          DefaultMessageStore.<span class="keyword">this</span>.doDispatch(dispatchRequest);</span><br><span class="line">                          <span class="comment">// 通知有新消息</span></span><br><span class="line">                          <span class="keyword">if</span> (BrokerRole.SLAVE != DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getBrokerRole()</span><br><span class="line">                              &amp;&amp; DefaultMessageStore.<span class="keyword">this</span>.brokerConfig.isLongPollingEnable()) &#123;</span><br><span class="line">                              <span class="comment">//通知有心的消息到达</span></span><br><span class="line">                              DefaultMessageStore.<span class="keyword">this</span>.messageArrivingListener.arriving(dispatchRequest.getTopic(),</span><br><span class="line">                                  dispatchRequest.getQueueId(), dispatchRequest.getConsumeQueueOffset() + <span class="number">1</span>,</span><br><span class="line">                                  dispatchRequest.getTagsCode());</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="comment">// FIXED BUG By shijia</span></span><br><span class="line">                          <span class="keyword">this</span>.reputFromOffset += size;</span><br><span class="line">                          readSize += size;</span><br><span class="line">                          <span class="comment">// 统计</span></span><br><span class="line">                          <span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getBrokerRole() == BrokerRole.SLAVE) &#123;</span><br><span class="line">                              DefaultMessageStore.<span class="keyword">this</span>.storeStatsService</span><br><span class="line">                                  .getSinglePutMessageTopicTimesTotal(dispatchRequest.getTopic()).incrementAndGet();</span><br><span class="line">                              DefaultMessageStore.<span class="keyword">this</span>.storeStatsService</span><br><span class="line">                                  .getSinglePutMessageTopicSizeTotal(dispatchRequest.getTopic())</span><br><span class="line">                                  .addAndGet(dispatchRequest.getMsgSize());</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">0</span>) &#123; <span class="comment">// 读取到MappedFile文件尾</span></span><br><span class="line">                          <span class="keyword">this</span>.reputFromOffset = DefaultMessageStore.<span class="keyword">this</span>.commitLog.rollNextFile(<span class="keyword">this</span>.reputFromOffset);</span><br><span class="line">                          readSize = result.getSize();</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!dispatchRequest.isSuccess()) &#123; <span class="comment">// 读取失败</span></span><br><span class="line">                      <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123; <span class="comment">// 读取到Message却不是Message</span></span><br><span class="line">                          log.error(<span class="string">"[BUG]read total count not equals msg total size. reputFromOffset=&#123;&#125;"</span>, reputFromOffset);</span><br><span class="line">                          <span class="keyword">this</span>.reputFromOffset += size;</span><br><span class="line">                      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 读取到Blank却不是Blank</span></span><br><span class="line">                          doNext = <span class="keyword">false</span>;</span><br><span class="line">                          <span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.brokerConfig.getBrokerId() == MixAll.MASTER_ID) &#123;</span><br><span class="line">                              log.error(<span class="string">"[BUG]the master dispatch message to consume queue error, COMMITLOG OFFSET: &#123;&#125;"</span>,</span><br><span class="line">                                  <span class="keyword">this</span>.reputFromOffset);</span><br><span class="line"></span><br><span class="line">                              <span class="keyword">this</span>.reputFromOffset += result.getSize() - readSize;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              result.release();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          doNext = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取出<code>reputFromOffset</code>之后的日志，调用<code>doDispatch()</code>方法进行调度请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(DispatchRequest req)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//当消息为非事务或者事务中提交阶段时，构建ConsumeQueue</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(req.getSysFlag());</span><br><span class="line">   <span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line">       <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line">       <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:            DefaultMessageStore.<span class="keyword">this</span>.putMessagePositionInfo(req.getTopic(), req.getQueueId(), req.getCommitLogOffset(), req.getMsgSize(),</span><br><span class="line">               req.getTagsCode(), req.getStoreTimestamp(), req.getConsumeQueueOffset());</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line">       <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">   &#125;    </span><br><span class="line">   <span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().isMessageIndexEnable()) &#123;</span><br><span class="line">    <span class="comment">// 创建索引   DefaultMessageStore.this.indexService.buildIndex(req);</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将消息位置信息追加到ConsumeQueue中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putMessagePositionInfo</span><span class="params">(String topic, <span class="keyword">int</span> queueId, <span class="keyword">long</span> offset, <span class="keyword">int</span> size, <span class="keyword">long</span> tagsCode, <span class="keyword">long</span> storeTimestamp,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> logicOffset)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过topic和queueId查找ConsumeQueue，没找到时创建</span></span><br><span class="line">   ConsumeQueue cq = <span class="keyword">this</span>.findConsumeQueue(topic, queueId);</span><br><span class="line">   cq.putMessagePositionInfoWrapper(offset, size, tagsCode, storeTimestamp, logicOffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出一个topic下的每个queue为一个文件独立存储。这样读取的时候即为顺序读取。<br><img src="/media/15262824950550.jpg" alt=""></p>
<p>对于索引<code>IndexFile</code>，<code>RocketMQ</code>保存的结构如下：<br><img src="/media/15262826812253.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putKey</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="keyword">long</span> phyOffset, <span class="keyword">final</span> <span class="keyword">long</span> storeTimestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.indexHeader.getIndexCount() &lt; <span class="keyword">this</span>.indexNum) &#123;</span><br><span class="line">       <span class="comment">//生成key的hash值</span></span><br><span class="line">       <span class="keyword">int</span> keyHash = indexKeyHashMethod(key);</span><br><span class="line">       <span class="comment">//根据hash值获取其所对应的槽位slot</span></span><br><span class="line">       <span class="keyword">int</span> slotPos = keyHash % <span class="keyword">this</span>.hashSlotNum;</span><br><span class="line">       <span class="comment">//计算slot在磁盘上的物理位移</span></span><br><span class="line">       <span class="keyword">int</span> absSlotPos = IndexHeader.INDEX_HEADER_SIZE + slotPos * hashSlotSize;</span><br><span class="line">       FileLock fileLock = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//获取上一个插入的在同一个槽中的索引信息所在位置值</span></span><br><span class="line">       <span class="keyword">int</span> slotValue = <span class="keyword">this</span>.mappedByteBuffer.getInt(absSlotPos);</span><br><span class="line">       <span class="keyword">if</span> (slotValue &lt;= invalidIndex || slotValue &gt; <span class="keyword">this</span>.indexHeader.getIndexCount()) &#123;</span><br><span class="line">           slotValue = invalidIndex;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">long</span> timeDiff = storeTimestamp - <span class="keyword">this</span>.indexHeader.getBeginTimestamp();</span><br><span class="line">       timeDiff = timeDiff / <span class="number">1000</span>;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.indexHeader.getBeginTimestamp() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           timeDiff = <span class="number">0</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeDiff &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">           timeDiff = Integer.MAX_VALUE;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeDiff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           timeDiff = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 获得当前可写入值的位置</span></span><br><span class="line">       <span class="keyword">int</span> absIndexPos =</span><br><span class="line">               IndexHeader.INDEX_HEADER_SIZE + <span class="keyword">this</span>.hashSlotNum * hashSlotSize</span><br><span class="line">                       + <span class="keyword">this</span>.indexHeader.getIndexCount() * indexSize;</span><br><span class="line">       <span class="comment">//写入索引值</span></span><br><span class="line">       <span class="keyword">this</span>.mappedByteBuffer.putInt(absIndexPos, keyHash);</span><br><span class="line">       <span class="keyword">this</span>.mappedByteBuffer.putLong(absIndexPos + <span class="number">4</span>, phyOffset);</span><br><span class="line">       <span class="keyword">this</span>.mappedByteBuffer.putInt(absIndexPos + <span class="number">4</span> + <span class="number">8</span>, (<span class="keyword">int</span>) timeDiff);</span><br><span class="line">       <span class="keyword">this</span>.mappedByteBuffer.putInt(absIndexPos + <span class="number">4</span> + <span class="number">8</span> + <span class="number">4</span>, slotValue);</span><br><span class="line">       <span class="comment">// 将当前记录的索引号替换到之前在hash中的槽值</span></span><br><span class="line">       <span class="keyword">this</span>.mappedByteBuffer.putInt(absSlotPos, <span class="keyword">this</span>.indexHeader.getIndexCount());</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.indexHeader.getIndexCount() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">this</span>.indexHeader.setBeginPhyOffset(phyOffset);</span><br><span class="line">           <span class="keyword">this</span>.indexHeader.setBeginTimestamp(storeTimestamp);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">this</span>.indexHeader.incHashSlotCount();</span><br><span class="line">       <span class="keyword">this</span>.indexHeader.incIndexCount();</span><br><span class="line">       <span class="keyword">this</span>.indexHeader.setEndPhyOffset(phyOffset);</span><br><span class="line">       <span class="keyword">this</span>.indexHeader.setEndTimestamp(storeTimestamp);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="消息读取"><a href="#消息读取" class="headerlink" title="消息读取"></a>消息读取</h2><p><code>DefaultMessageStore</code>的<code>getMessage</code>用于读消息。<br>给定查询<code>offset</code>，首先去<code>ConsumeQueue</code>去查询出<code>offset</code>后所有的查询的Queue的消息对应的位移记录。然后通过这些位移信息去<code>CommitLog</code>中一条条将结果取出并返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> GetMessageResult <span class="title">getMessage</span><span class="params">(<span class="keyword">final</span> String group, <span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="keyword">int</span> queueId, <span class="keyword">final</span> <span class="keyword">long</span> offset, <span class="keyword">final</span> <span class="keyword">int</span> maxMsgNums,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> SubscriptionData subscriptionData)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> beginTime = <span class="keyword">this</span>.getSystemClock().now();</span><br><span class="line">   GetMessageStatus status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;</span><br><span class="line">   <span class="keyword">long</span> nextBeginOffset = offset;</span><br><span class="line">   <span class="keyword">long</span> minOffset = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">long</span> maxOffset = <span class="number">0</span>;</span><br><span class="line">   GetMessageResult getResult = <span class="keyword">new</span> GetMessageResult();</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">long</span> maxOffsetPy = <span class="keyword">this</span>.commitLog.getMaxOffset();</span><br><span class="line">   <span class="comment">// 根据Topic和queueId找到ConsumeQueue</span></span><br><span class="line">   ConsumeQueue consumeQueue = findConsumeQueue(topic, queueId);</span><br><span class="line">   minOffset = consumeQueue.getMinOffsetInQueue(); <span class="comment">// 消费队列 最小队列编号</span></span><br><span class="line">   maxOffset = consumeQueue.getMaxOffsetInQueue(); <span class="comment">// 消费队列 最大队列编号</span></span><br><span class="line">   <span class="comment">//跟据消费offSet找到该offSet后的所有消费队列buffer</span></span><br><span class="line">   SelectMappedBufferResult bufferConsumeQueue = consumeQueue.getIndexBuffer(offset);</span><br><span class="line">   <span class="keyword">if</span> (bufferConsumeQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           status = GetMessageStatus.NO_MATCHED_MESSAGE;</span><br><span class="line">           <span class="keyword">long</span> nextPhyFileStartOffset = Long.MIN_VALUE;</span><br><span class="line">           <span class="keyword">long</span> maxPhyOffsetPulling = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> maxFilterMessageCount = <span class="number">16000</span>;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">boolean</span> diskFallRecorded = <span class="keyword">this</span>.messageStoreConfig.isDiskFallRecorded();</span><br><span class="line">           <span class="keyword">for</span> (; i &lt; bufferConsumeQueue.getSize() &amp;&amp; i &lt; maxFilterMessageCount; i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;</span><br><span class="line">               <span class="comment">// 从消费队列中一条条取出消息位置信息 【物理offset、消息长度、消息tagsCode】</span></span><br><span class="line">               <span class="keyword">long</span> offsetPy = bufferConsumeQueue.getByteBuffer().getLong();</span><br><span class="line">               <span class="keyword">int</span> sizePy = bufferConsumeQueue.getByteBuffer().getInt();</span><br><span class="line">               <span class="keyword">long</span> tagsCode = bufferConsumeQueue.getByteBuffer().getLong();</span><br><span class="line">               maxPhyOffsetPulling = offsetPy;</span><br><span class="line">               <span class="keyword">if</span> (nextPhyFileStartOffset != Long.MIN_VALUE) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (offsetPy &lt; nextPhyFileStartOffset)</span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">boolean</span> isInDisk = checkInDiskByCommitOffset(offsetPy, maxOffsetPy);</span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.isTheBatchFull(sizePy, maxMsgNums, getResult.getBufferTotalSize(), getResult.getMessageCount(), isInDisk)) &#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//筛选出consumer需要的</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.messageFilter.isMessageMatched(subscriptionData, tagsCode)) &#123;</span><br><span class="line">                   <span class="comment">//从CommitLog中根据位移取出消息</span></span><br><span class="line">                   SelectMappedBufferResult selectResult = <span class="keyword">this</span>.commitLog.getMessage(offsetPy, sizePy);</span><br><span class="line">                   <span class="keyword">if</span> (selectResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="keyword">this</span>.storeStatsService.getGetMessageTransferedMsgCount().incrementAndGet();</span><br><span class="line">                       getResult.addMessage(selectResult);</span><br><span class="line">                       status = GetMessageStatus.FOUND;</span><br><span class="line">                       nextPhyFileStartOffset = Long.MIN_VALUE;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="keyword">if</span> (getResult.getBufferTotalSize() == <span class="number">0</span>) &#123;</span><br><span class="line">                           status = GetMessageStatus.MESSAGE_WAS_REMOVING;</span><br><span class="line">                       &#125;</span><br><span class="line">                       nextPhyFileStartOffset = <span class="keyword">this</span>.commitLog.rollNextFile(offsetPy);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="comment">//...</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (diskFallRecorded) &#123;</span><br><span class="line">               <span class="keyword">long</span> fallBehind = maxOffsetPy - maxPhyOffsetPulling;</span><br><span class="line">               brokerStatsManager.recordDiskFallBehindSize(group, topic, queueId, fallBehind);</span><br><span class="line">           &#125;</span><br><span class="line">           nextBeginOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br><span class="line">           <span class="keyword">long</span> diff = maxOffsetPy - maxPhyOffsetPulling;</span><br><span class="line">           <span class="keyword">long</span> memory = (<span class="keyword">long</span>) (StoreUtil.TOTAL_PHYSICAL_MEMORY_SIZE * (<span class="keyword">this</span>.messageStoreConfig.getAccessMessageInMemoryMaxRatio() / <span class="number">100.0</span>));</span><br><span class="line">           getResult.setSuggestPullingFromSlave(diff &gt; memory);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           bufferConsumeQueue.release();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 设置返回结果</span></span><br><span class="line">   getResult.setStatus(status);</span><br><span class="line">   getResult.setNextBeginOffset(nextBeginOffset);</span><br><span class="line">   getResult.setMaxOffset(maxOffset);</span><br><span class="line">   getResult.setMinOffset(minOffset);</span><br><span class="line">   <span class="keyword">return</span> getResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>下图中，</strong> 粉红色的线即代表消息读取的过程；绿线代码消息存储的过程。<br><img src="/media/15263460992712.jpg" alt=""></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/22231319" target="_blank" rel="noopener">RocketMQ源码阅读1</a>（借用图）</li>
<li><a href="https://zhuanlan.zhihu.com/p/22619643" target="_blank" rel="noopener">RocketMQ源码阅读2</a>（借用图）</li>
<li><a href="http://www.iocoder.cn/RocketMQ/message-store/" target="_blank" rel="noopener">RocketMQ 源码分析 —— Message 存储</a></li>
<li><a href="http://alibaba.github.io/RocketMQ-docs/document/design/RocketMQ_design.pdf" target="_blank" rel="noopener">RocketMQ 原理简介</a></li>
<li><a href="https://blog.csdn.net/yfkiss/article/details/6661266" target="_blank" rel="noopener">存储方式与介质对性能的影响</a></li>
<li><a href="https://www.linuxjournal.com/article/6345" target="_blank" rel="noopener">Zero Copy</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2018/03/18/mq/2.rocketmq-%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/18/mq/2.rocketmq-%E9%80%9A%E4%BF%A1/" itemprop="url">RocketMQ 通信</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-18T00:00:00+08:00">2018-03-18</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/rocketmq/" itemprop="url" rel="index"><span itemprop="name">rocketmq</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="2-remoting"><a href="#2-remoting" class="headerlink" title="2. remoting"></a>2. remoting</h1><p>[TOC]</p>
<p><code>RocketMQ</code>的通讯模块实现的比较简单，不像<code>Dubbo</code>那样给用户提供多种可选的方式，只有一种基于通讯框架<code>Netty</code>的实现方式。<br>其最主要的两个类是<code>NettyRemotingServer</code>、<code>NettyRemotingClient</code>。以下为其类图：<br><img src="/media/15261996364642.jpg" alt=""></p>
<p>首先我们来分析<code>Server</code>部分，再看<code>Client</code>部分。</p>
<h3 id="Server："><a href="#Server：" class="headerlink" title="Server："></a>Server：</h3><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h4><p>首先初始化<code>Server</code>，初始化Netty 的<code>Acceptor</code>EventLoopGroup和<code>Selector</code>EventLoopGroup，并设置限流阈值和通道事件监听器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NettyRemotingServer</span><span class="params">(<span class="keyword">final</span> NettyServerConfig nettyServerConfig, <span class="keyword">final</span> ChannelEventListener channelEventListener)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 限流，设置信号量，设置同一时间单向请求和异步请求最大的请求数。</span></span><br><span class="line">   <span class="keyword">super</span>(nettyServerConfig.getServerOnewaySemaphoreValue(), nettyServerConfig.getServerAsyncSemaphoreValue());</span><br><span class="line">   <span class="keyword">this</span>.serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">   <span class="keyword">this</span>.nettyServerConfig = nettyServerConfig;</span><br><span class="line">   <span class="comment">// 设置通道事件监听器</span></span><br><span class="line">   <span class="keyword">this</span>.channelEventListener = channelEventListener;</span><br><span class="line">   <span class="keyword">int</span> publicThreadNums = nettyServerConfig.getServerCallbackExecutorThreads();</span><br><span class="line">   <span class="keyword">if</span> (publicThreadNums &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">       publicThreadNums = <span class="number">4</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 通用的处理线程池实例化，当业务方没有设置processor的线程池时，使用共用的线程池publiceExecutor</span></span><br><span class="line">   <span class="keyword">this</span>.publicExecutor = Executors.newFixedThreadPool(publicThreadNums, <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">       <span class="keyword">private</span> AtomicInteger threadIndex = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"NettyServerPublicExecutor_"</span> + <span class="keyword">this</span>.threadIndex.incrementAndGet());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="comment">// 设置Netty Acceptor线程池大小</span></span><br><span class="line">   <span class="keyword">this</span>.eventLoopGroupBoss = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>, <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">       <span class="keyword">private</span> AtomicInteger threadIndex = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, String.format(<span class="string">"NettyBoss_%d"</span>, <span class="keyword">this</span>.threadIndex.incrementAndGet()));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">    <span class="comment">// 设置Netty Selector线程池大小，此处判断若是linux平台，使用Epoll线程池，否则使用</span></span><br><span class="line">   <span class="keyword">if</span> (RemotingUtil.isLinuxPlatform() <span class="comment">//</span></span><br><span class="line">       &amp;&amp; nettyServerConfig.isUseEpollNativeSelector()) &#123;</span><br><span class="line">       <span class="keyword">this</span>.eventLoopGroupSelector = <span class="keyword">new</span> EpollEventLoopGroup(nettyServerConfig.getServerSelectorThreads(), <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">           <span class="keyword">private</span> AtomicInteger threadIndex = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">           <span class="keyword">private</span> <span class="keyword">int</span> threadTotal = nettyServerConfig.getServerSelectorThreads();</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, String.format(<span class="string">"NettyServerEPOLLSelector_%d_%d"</span>, threadTotal, <span class="keyword">this</span>.threadIndex.incrementAndGet()));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">//否则使用一般的</span></span><br><span class="line">       <span class="keyword">this</span>.eventLoopGroupSelector = <span class="keyword">new</span> NioEventLoopGroup(nettyServerConfig.getServerSelectorThreads(), <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">           <span class="keyword">private</span> AtomicInteger threadIndex = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">           <span class="keyword">private</span> <span class="keyword">int</span> threadTotal = nettyServerConfig.getServerSelectorThreads();</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, String.format(<span class="string">"NettyServerNIOSelector_%d_%d"</span>, threadTotal, <span class="keyword">this</span>.threadIndex.incrementAndGet()));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-启动"><a href="#2-启动" class="headerlink" title="2. 启动"></a>2. 启动</h4><p>调用<code>start()</code>方法，启动<code>Server</code>。监听端口，开启服务，并开启后台线程，扫描超时的响应并作回调。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   ServerBootstrap childHandler =</span><br><span class="line">       <span class="keyword">this</span>.serverBootstrap.group(<span class="keyword">this</span>.eventLoopGroupBoss, <span class="keyword">this</span>.eventLoopGroupSelector).channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">           .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 1024)</span></span><br><span class="line"><span class="class">           .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_REUSEADDR</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">           .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>, <span class="title">false</span>)</span></span><br><span class="line"><span class="class">           .<span class="title">childOption</span>(<span class="title">ChannelOption</span>.<span class="title">TCP_NODELAY</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">           .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_SNDBUF</span>, <span class="title">nettyServerConfig</span>.<span class="title">getServerSocketSndBufSize</span>())</span></span><br><span class="line"><span class="class">           .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_RCVBUF</span>, <span class="title">nettyServerConfig</span>.<span class="title">getServerSocketRcvBufSize</span>())</span></span><br><span class="line"><span class="class">           .<span class="title">localAddress</span>(<span class="title">new</span> <span class="title">InetSocketAddress</span>(<span class="title">this</span>.<span class="title">nettyServerConfig</span>.<span class="title">getListenPort</span>()))</span></span><br><span class="line"><span class="class">           .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                   ch.pipeline().addLast(</span><br><span class="line">                       defaultEventExecutorGroup,</span><br><span class="line">                       <span class="keyword">new</span> NettyEncoder(),</span><br><span class="line">                       <span class="keyword">new</span> NettyDecoder(),</span><br><span class="line">                       <span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">0</span>, nettyServerConfig.getServerChannelMaxIdleTimeSeconds()),</span><br><span class="line">                       <span class="comment">// 触发Channel状态变化监听事件</span></span><br><span class="line">                       <span class="keyword">new</span> NettyConnetManageHandler(),</span><br><span class="line">                       <span class="comment">// 业务处理逻辑</span></span><br><span class="line">                       <span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (nettyServerConfig.isServerPooledByteBufAllocatorEnable()) &#123;</span><br><span class="line">       childHandler.childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 启动NettyServer，监听端口并接收请求</span></span><br><span class="line">       ChannelFuture sync = <span class="keyword">this</span>.serverBootstrap.bind().sync();</span><br><span class="line">       InetSocketAddress addr = (InetSocketAddress) sync.channel().localAddress();</span><br><span class="line">       <span class="keyword">this</span>.port = addr.getPort();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"this.serverBootstrap.bind().sync() InterruptedException"</span>, e1);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//启动netty事件处理器，当channel状态发生变化时，通知相应事件。这里即是通知`BrokerHousekeepingService`进行相应的处理。</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.channelEventListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">this</span>.nettyEventExecuter.start();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//扫描响应列表，当有response超时未返回时，则触发回调函数返回</span></span><br><span class="line">   <span class="keyword">this</span>.timer.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               NettyRemotingServer.<span class="keyword">this</span>.scanResponseTable();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               log.error(<span class="string">"scanResponseTable exception"</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;, <span class="number">1000</span> * <span class="number">3</span>, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，<code>NettyRemotingServer</code>提供了两个方法给使用方用于注册自己的业务处理器<code>NettyRequestProcessor</code>(每个需要提供服务的组件，实现这个接口并向RemotingServer中注册)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 注册处理器</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> requestCode 请求码</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> processor 请求处理器</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> executor 处理线程池</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerProcessor</span><span class="params">(<span class="keyword">int</span> requestCode, NettyRequestProcessor processor, ExecutorService executor)</span> </span>&#123;</span><br><span class="line">   ExecutorService executorThis = executor;</span><br><span class="line">   <span class="comment">//若没有设置，则使用共用的publicExecutor线程池</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> == executor) &#123;</span><br><span class="line">       executorThis = <span class="keyword">this</span>.publicExecutor;</span><br><span class="line">   &#125;</span><br><span class="line">   Pair&lt;NettyRequestProcessor, ExecutorService&gt; pair = <span class="keyword">new</span> Pair&lt;NettyRequestProcessor, ExecutorService&gt;(processor, executorThis);</span><br><span class="line">   <span class="keyword">this</span>.processorTable.put(requestCode, pair);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册默认处理器，及当没有其他处理器时，使用此处理器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerDefaultProcessor</span><span class="params">(NettyRequestProcessor processor, ExecutorService executor)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.defaultRequestProcessor = <span class="keyword">new</span> Pair&lt;NettyRequestProcessor, ExecutorService&gt;(processor, executor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-调用"><a href="#3-调用" class="headerlink" title="3. 调用"></a>3. 调用</h4><p>当请求到达后，<code>Netty</code>进行解码后最终交给<code>NettyServerHandler</code>进行处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RemotingCommand</span>&gt; </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       processMessageReceived(ctx, msg);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NettyServerHandler</code>调用<code>NettyRemotingAbstract.processRequestCommand</code>来进行处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessageReceived</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> RemotingCommand cmd = msg;</span><br><span class="line">   <span class="keyword">if</span> (cmd != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//根据cmd的类型进行不同的处理</span></span><br><span class="line">       <span class="keyword">switch</span> (cmd.getType()) &#123;</span><br><span class="line">           <span class="keyword">case</span> REQUEST_COMMAND:</span><br><span class="line">               processRequestCommand(ctx, cmd);</span><br><span class="line">               <span class="keyword">break</span>;         </span><br><span class="line">           <span class="keyword">case</span> RESPONSE_COMMAND:</span><br><span class="line">               processResponseCommand(ctx, cmd);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟进，<code>processRequestCommand</code>中会根据请求码去看是否注册了相应的<code>RequestProcessor</code>，若没有则使用默认<code>RequestProcessor</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequestCommand</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, <span class="keyword">final</span> RemotingCommand cmd)</span></span></span><br><span class="line"><span class="function">  <span class="comment">//根绝请求码去取请求处理器，如果没有则使用默认的处理器</span></span></span><br><span class="line"><span class="function">   <span class="keyword">final</span> Pair&lt;NettyRequestProcessor, ExecutorService&gt; matched </span>= <span class="keyword">this</span>.processorTable.get(cmd.getCode());</span><br><span class="line">   <span class="keyword">final</span> Pair&lt;NettyRequestProcessor, ExecutorService&gt; pair = <span class="keyword">null</span> == matched ? <span class="keyword">this</span>.defaultRequestProcessor : matched;</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> opaque = cmd.getOpaque();</span><br><span class="line">   Runnable run = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">final</span> RemotingCommand response = pair.getObject1().processRequest(ctx, cmd);</span><br><span class="line">          <span class="keyword">if</span> (!cmd.isOnewayRPC()) &#123;</span><br><span class="line">              <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  response.setOpaque(opaque);</span><br><span class="line">                  response.markResponseType();</span><br><span class="line">                  ctx.writeAndFlush(response);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 进行异步处理请求</span></span><br><span class="line">   <span class="keyword">final</span> RequestTask requestTask = <span class="keyword">new</span> RequestTask(run, ctx.channel(), cmd);</span><br><span class="line">   pair.getObject2().submit(requestTask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><h4 id="1-初始化与启动"><a href="#1-初始化与启动" class="headerlink" title="1. 初始化与启动"></a>1. 初始化与启动</h4><p>其初始化和启动过程与<code>Server</code>大致相似，且比<code>Server</code>做的事要少。其主要是初始化<code>io.netty.bootstrap.Boostrap</code>，设置参数，并启动事件处理线程和扫描响应线程等。</p>
<h4 id="3-调用-1"><a href="#3-调用-1" class="headerlink" title="3. 调用"></a>3. 调用</h4><p>其主要提供三个调用形式：</p>
<ol>
<li><strong>invokeSync</strong>：同步阻塞调用；</li>
<li><strong>invokeOneway</strong>：单向调用，不需要反馈结果；</li>
<li><strong>invokeAsync</strong>：异步调用，结果返回后触发回调逻辑。</li>
</ol>
<p>以<code>invokeSync</code>为例来讲解调用的过程，其他两种方式类似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">invokeSync</span><span class="params">(String addr, <span class="keyword">final</span> RemotingCommand request, <span class="keyword">long</span> timeoutMillis)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ... </span>&#123;</span><br><span class="line">   <span class="comment">//根据地址来获取通讯通道，如果没有则创建</span></span><br><span class="line">   <span class="keyword">final</span> Channel channel = <span class="keyword">this</span>.getAndCreateChannel(addr);</span><br><span class="line">   <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isActive()) &#123;</span><br><span class="line">       RemotingCommand response = <span class="keyword">this</span>.invokeSyncImpl(channel, request, timeoutMillis);</span><br><span class="line">       <span class="keyword">return</span> response;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">this</span>.closeChannel(addr, channel);</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RemotingConnectException(addr);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先获取<code>Channel</code>，然后通过<code>Channel</code>来发送请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  根据调用地址获取缓存的Channel，如果没有则创建Channel</span></span><br><span class="line"><span class="comment">     *  当 addr为空的时候创建到NameServer的Channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> addr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Channel <span class="title">getAndCreateChannel</span><span class="params">(<span class="keyword">final</span> String addr)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> == addr)</span><br><span class="line">       <span class="keyword">return</span> getAndCreateNameserverChannel();</span><br><span class="line">   ChannelWrapper cw = <span class="keyword">this</span>.channelTables.get(addr);</span><br><span class="line">   <span class="keyword">if</span> (cw != <span class="keyword">null</span> &amp;&amp; cw.isOK()) &#123;</span><br><span class="line">       <span class="keyword">return</span> cw.getChannel();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//创建Channel</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.createChannel(addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Channel <span class="title">createChannel</span><span class="params">(<span class="keyword">final</span> String addr)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">   ChannelWrapper cw = <span class="keyword">this</span>.channelTables.get(addr);</span><br><span class="line">   <span class="keyword">if</span> (cw != <span class="keyword">null</span> &amp;&amp; cw.isOK()) &#123;</span><br><span class="line">       <span class="keyword">return</span> cw.getChannel();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.lockChannelTables.tryLock(LOCK_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">boolean</span> createNewConnection = <span class="keyword">false</span>;</span><br><span class="line">           cw = <span class="keyword">this</span>.channelTables.get(addr);</span><br><span class="line">           <span class="keyword">if</span> (cw != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (cw.isOK()) &#123;</span><br><span class="line">                   <span class="keyword">return</span> cw.getChannel();</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!cw.getChannelFuture().isDone()) &#123;</span><br><span class="line">                   createNewConnection = <span class="keyword">false</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">this</span>.channelTables.remove(addr);</span><br><span class="line">                   createNewConnection = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               createNewConnection = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (createNewConnection) &#123;</span><br><span class="line">               <span class="comment">//发起连接</span></span><br><span class="line">               ChannelFuture channelFuture = <span class="keyword">this</span>.bootstrap.connect(RemotingHelper.string2SocketAddress(addr));</span><br><span class="line">               cw = <span class="keyword">new</span> ChannelWrapper(channelFuture);</span><br><span class="line">               <span class="keyword">this</span>.channelTables.put(addr, cw);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">this</span>.lockChannelTables.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (cw != <span class="keyword">null</span>) &#123;</span><br><span class="line">       ChannelFuture channelFuture = cw.getChannelFuture();</span><br><span class="line">        <span class="comment">//等待完成连接</span></span><br><span class="line">       <span class="keyword">if</span> (channelFuture.awaitUninterruptibly(<span class="keyword">this</span>.nettyClientConfig.getConnectTimeoutMillis())) &#123;</span><br><span class="line">           <span class="keyword">if</span> (cw.isOK()) &#123;</span><br><span class="line">               log.info(<span class="string">"createChannel: connect remote host[&#123;&#125;] success, &#123;&#125;"</span>, addr, channelFuture.toString());</span><br><span class="line">               <span class="keyword">return</span> cw.getChannel();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               log.warn(<span class="string">"createChannel: connect remote host["</span> + addr + <span class="string">"] failed, "</span> + channelFuture.toString(), channelFuture.cause());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           log.warn(<span class="string">"createChannel: connect remote host[&#123;&#125;] timeout &#123;&#125;ms, &#123;&#125;"</span>, addr, <span class="keyword">this</span>.nettyClientConfig.getConnectTimeoutMillis(),</span><br><span class="line">               channelFuture.toString());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取<code>Channel</code>后，发起请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">invokeSyncImpl</span><span class="params">(<span class="keyword">final</span> Channel channel, <span class="keyword">final</span> RemotingCommand request, <span class="keyword">final</span> <span class="keyword">long</span> timeoutMillis)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, RemotingSendRequestException, RemotingTimeoutException </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> opaque = request.getOpaque();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">final</span> ResponseFuture responseFuture = <span class="keyword">new</span> ResponseFuture(opaque, timeoutMillis, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">this</span>.responseTable.put(opaque, responseFuture);</span><br><span class="line">       <span class="keyword">final</span> SocketAddress addr = channel.remoteAddress();</span><br><span class="line">       <span class="comment">// 请求结束后，</span></span><br><span class="line">       channel.writeAndFlush(request).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture f)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (f.isSuccess()) &#123;</span><br><span class="line">                   responseFuture.setSendRequestOK(<span class="keyword">true</span>);</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   responseFuture.setSendRequestOK(<span class="keyword">false</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               responseTable.remove(opaque);</span><br><span class="line">               responseFuture.setCause(f.cause());</span><br><span class="line">               responseFuture.putResponse(<span class="keyword">null</span>);</span><br><span class="line">               PLOG.warn(<span class="string">"send a request command to channel &lt;"</span> + addr + <span class="string">"&gt; failed."</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       RemotingCommand responseCommand = responseFuture.waitResponse(timeoutMillis);</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == responseCommand) &#123;</span><br><span class="line">           <span class="keyword">if</span> (responseFuture.isSendRequestOK()) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTimeoutException(RemotingHelper.parseSocketAddressAddr(addr), timeoutMillis,</span><br><span class="line">                   responseFuture.getCause());</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RemotingSendRequestException(RemotingHelper.parseSocketAddressAddr(addr), responseFuture.getCause());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> responseCommand;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="keyword">this</span>.responseTable.remove(opaque);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看完后，肯定会很奇怪：这里<code>responseFuture</code>根本没有设置返回值啊，怎么返回的？<br>这是因为在<code>Netty</code>Client初始化的时候设置了<code>NettyClientHandler</code>，其最终会调用<code>NettyRemotingAbstract</code>的<code>processResponseCommand</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResponseCommand</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand cmd)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> opaque = cmd.getOpaque();</span><br><span class="line">   <span class="comment">//获取Future</span></span><br><span class="line">   <span class="keyword">final</span> ResponseFuture responseFuture = responseTable.get(opaque);</span><br><span class="line">   <span class="keyword">if</span> (responseFuture != <span class="keyword">null</span>) &#123;</span><br><span class="line">       responseFuture.setResponseCommand(cmd);</span><br><span class="line">       responseFuture.release();</span><br><span class="line">       responseTable.remove(opaque);</span><br><span class="line">       <span class="keyword">if</span> (responseFuture.getInvokeCallback() != <span class="keyword">null</span>) &#123;</span><br><span class="line">           executeInvokeCallback(responseFuture);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//设置返回值</span></span><br><span class="line">           responseFuture.putResponse(cmd);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，RocketMQ的通讯模块就分析结束了。可以感受到，其实现的比较粗糙。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2018/03/17/mq/1.rocketmq-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/17/mq/1.rocketmq-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/" itemprop="url">RocketMQ 整体架构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-17T00:00:00+08:00">2018-03-17</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/rocketmq/" itemprop="url" rel="index"><span itemprop="name">rocketmq</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-RocketMQ-整体架构"><a href="#1-RocketMQ-整体架构" class="headerlink" title="1. RocketMQ 整体架构"></a>1. RocketMQ 整体架构</h1><p>[TOC]</p>
<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><code>RocketMQ</code>主要由四部分组成，<code>NameServer</code>、<code>Broker</code>、<code>Producer</code>、<code>Consumer</code>。其中<code>NameServer</code>、<code>Broker</code>是独立部署集群，而<code>Producer</code>、<code>Consumer</code>一般是以SDK的形式提供给业务方，嵌在业务集群内。另外还有一个<code>FilterSrv</code>，可选择性使用，用于消费者自定义消息过滤。<br><img src="/media/15259116098234.jpg" alt=""></p>
<h3 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a><strong>NameServer</strong></h3><p>类似于服务治理框架里的注册中心。管理<code>Broker</code>集群的注册信息并提供心跳来检测他们是否可用，持有关于broker集群和队列的全部路由信息；</p>
<h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a><strong>Broker</strong></h3><p>负责消息的存储传递，客户端查询并保证高可用。此外，代理提供了灾难恢复、丰富的度量统计和警报机制。主要功能如下；<br><img src="/media/15260235205668.jpg" alt="set up-w600"></p>
<ol>
<li><code>Remoting Module</code>:服务入口，接收来自客户端的请求并转发;</li>
<li><code>Client Manager</code>:客户端管理，管理客户端（生产者/消费者）还有维护消费者主题订阅;</li>
<li><code>Store Service</code>:信息存储和查询的api服务;</li>
<li><code>HA Service</code>: 提供主从broker的数据同步;</li>
<li><code>Index Service</code>:为消息建立索引提供消息快速查询。</li>
</ol>
<h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a><strong>Producer</strong></h3><p>支持分布式部署，支持多种负载均衡策略发送消息到<code>Broker</code>集群。发送过程支持快速失败且低延迟。</p>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a><strong>Consumer</strong></h3><p>支持以推送(非真的拉取)、拉取模式消费消息，支持集群消费和消息广播。提供实时的消息订阅机制。</p>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><h3 id="模块说明"><a href="#模块说明" class="headerlink" title="模块说明"></a>模块说明</h3><p><img src="/media/15261981216358.jpg" alt=""></p>
<ul>
<li><strong>rocket.common 公共逻辑模块</strong>:包括一些基本类和Util类；</li>
<li><strong>rocket.remoting 远程通讯模块</strong>:主要起通讯作用，上层每个组件使用其来做服务通讯，暴露服务与服务请求，使用json序列化协议；</li>
<li><strong>rocket.store 数据存储</strong>:主要用在<strong>Broker</strong>，存储和读取消息数据。以及主从复制和索引；</li>
<li><strong>rocket.broker 数据中转服务</strong>:实现broker逻辑，接收<code>Producer</code>发送信息请求并存储，接收<code>Consumer</code>拉取信息请求并读取消息返回，并保存每个<code>Queue</code>的消费位移；</li>
<li><strong>rocket.namesrv 命名服务</strong>:维护服务路由信息，相当于注册中心。</li>
<li><strong>rocket.client 客户端</strong>:实现 <code>Producer</code>、<code>Consumer</code>逻辑。</li>
</ul>
<p>接下来的章节中，我们先讲基础模块(<code>remoting</code>、<code>store</code>)，再讲<code>namesrv</code>和<code>broker</code>。其后，通过生产消息和消费消息两个过程来讲解<code>namesrv</code>、<code>broker</code>、<code>producer</code>、<code>consumer</code>之间的协作。<br>最后再介绍下rocketMQ在 顺序消息、消息重复、事务消息上做的改进。</p>
<p>本文所讲解的<strong>RocketMQ</strong>的源码版本是 <code>4.1.0-incubating-SNAPSHOT</code>。</p>
<hr>
<p>本话题，将从以下方面来讲解<code>RocketMQ</code>。</p>
<ol>
<li>整体架构<ol>
<li>每部分的作用</li>
<li>每部分的用到了存储</li>
<li>通信方式</li>
</ol>
</li>
<li>启动过程<ol>
<li>Namesrv启动过程</li>
<li>Broker启动过程</li>
<li>Producer启动过程</li>
<li>Consumer启动过程</li>
</ol>
</li>
<li>消息拉取到消费的过程<ol>
<li>Producer发送消息的过程</li>
<li>Broker接收消息并存储消息的过程</li>
<li>Consumer拉取消息并消费的过程</li>
</ol>
</li>
<li>消息的顺序性如何保证</li>
<li>事务消息</li>
<li>定时消息</li>
</ol>
<h2 id="MQ对比"><a href="#MQ对比" class="headerlink" title="MQ对比"></a>MQ对比</h2><p><a href="https://blog.csdn.net/damacheng/article/details/42846549" target="_blank" rel="noopener">https://blog.csdn.net/damacheng/article/details/42846549</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avator.jpeg"
                alt="Zamperini" />
            
              <p class="site-author-name" itemprop="name">Zamperini</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/%7C%7C%20archive">
                
                    <span class="site-state-item-count">55</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/DorgenJones" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:dblpfilter@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/1938368215" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zamperini</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.0.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.3"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
