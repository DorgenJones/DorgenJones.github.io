<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://dorgenjones.github.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Zamperini">
<meta property="og:url" content="https://dorgenjones.github.io/page/2/index.html">
<meta property="og:site_name" content="Zamperini">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zamperini">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://dorgenjones.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Zamperini</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Zamperini</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">23</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">56</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2019/11/24/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/etcd/6.etcd-ttl&lease/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.png">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/24/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/etcd/6.etcd-ttl&lease/" class="post-title-link" itemprop="url">TTL&Lease实现</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-24 00:00:00" itemprop="dateCreated datePublished" datetime="2019-11-24T00:00:00+08:00">2019-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-13 19:11:13" itemprop="dateModified" datetime="2020-02-13T19:11:13+08:00">2020-02-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/etcd/" itemprop="url" rel="index">
                    <span itemprop="name">etcd</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="5-TTL-amp-Lease-实现"><a href="#5-TTL-amp-Lease-实现" class="headerlink" title="5. TTL &amp; Lease 实现"></a>5. TTL &amp; Lease 实现</h1><p><code>etcd</code>中用来实现<code>TTL</code>的机制叫<code>Lease</code>，<code>Lease</code>可以用来绑定多个key。<code>Lease</code>的主要用法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> etcdctl lease grant <span class="number">1900</span> <span class="comment">// 申请一个租约，返回租约ID</span></span><br><span class="line"> - lease <span class="number">326969472</span>b0c5d05 granted with TTL(<span class="number">1900</span>s)</span><br><span class="line"><span class="number">2.</span> etcdctl lease revoke <span class="number">326969472</span>b0c5d05 <span class="comment">// 取消租约</span></span><br><span class="line">- lease <span class="number">326969472</span>b0c5d05 revoked</span><br><span class="line"><span class="number">3.</span> etcdctl lease timetolive  <span class="number">326969472</span>b0c5d08 <span class="comment">// 查询剩余多长时间</span></span><br><span class="line">- lease <span class="number">326969472</span>b0c5d08 granted with TTL(<span class="number">190</span>s), remaining(<span class="number">182</span>s)</span><br><span class="line"><span class="number">4.</span> etcdctl lease keep-alive <span class="number">326969472</span>b0c5d05 <span class="comment">// 到期续约</span></span><br><span class="line">- lease <span class="number">326969472</span>b0c5d05 keepalived with TTL(<span class="number">1900</span>)</span><br><span class="line"><span class="number">5.</span> etcdctl lease keep-alive --once=<span class="literal">true</span> <span class="number">326969472</span>b0c5d0c <span class="comment">// 单次续约</span></span><br><span class="line">- lease <span class="number">326969472</span>b0c5d0c keepalived with TTL(<span class="number">200</span>)</span><br></pre></td></tr></table></figure>
<p>下面将解析其工作原理，首先将介绍其初始化过程，然后介绍创建、以及绑定<code>key</code>以及过期的操作。</p>
<h2 id="5-1-初始化"><a href="#5-1-初始化" class="headerlink" title="5.1 初始化"></a>5.1 初始化</h2><p><code>Lessor</code>是在创建<code>EtcdServer</code>是进行初始化的：<code>lease.NewLessor(...)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">minTTL := time.Duration((<span class="number">3</span>*cfg.ElectionTicks)/<span class="number">2</span>) * heartbeat <span class="comment">// 首先计算最小TTL单元，为选举跳数的1.5倍*心跳间隔时间</span></span><br><span class="line">srv.lessor = lease.NewLessor(log, srv.be, lease.LessorConfig&#123;MinLeaseTTL: <span class="keyword">int64</span>(math.Ceil(minTTL.Seconds())), CheckpointInterval: cfg.LeaseCheckpointInterval&#125;) <span class="comment">// 创建`Lessor`，传入最小租约TTL时间，和租约周期性检测时间间隔。租约的TTL时间最小不能小于最小租约时间（秒级别）</span></span><br><span class="line">|- <span class="keyword">if</span> checkpointInterval == <span class="number">0</span> &#123; <span class="comment">// 设置默认时间为5分钟</span></span><br><span class="line">		checkpointInterval = <span class="number">5</span> * time.Minute</span><br><span class="line">	&#125;</span><br><span class="line">|- l := &amp;lessor&#123;</span><br><span class="line">		leaseMap:            <span class="built_in">make</span>(<span class="keyword">map</span>[LeaseID]*Lease),</span><br><span class="line">		itemMap:             <span class="built_in">make</span>(<span class="keyword">map</span>[LeaseItem]LeaseID),</span><br><span class="line">		leaseHeap:           <span class="built_in">make</span>(LeaseQueue, <span class="number">0</span>), <span class="comment">// 根据租约到期时间排序的小根堆</span></span><br><span class="line">		leaseCheckpointHeap: <span class="built_in">make</span>(LeaseQueue, <span class="number">0</span>),</span><br><span class="line">		b:                   b,</span><br><span class="line">		minLeaseTTL:         cfg.MinLeaseTTL,</span><br><span class="line">		checkpointInterval:  checkpointInterval,</span><br><span class="line">		expiredC: <span class="built_in">make</span>(<span class="keyword">chan</span> []*Lease, <span class="number">16</span>),</span><br><span class="line">		stopC:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		doneC:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">	&#125;</span><br><span class="line">|- l.initAndRecover() <span class="comment">// 初始化并恢复</span></span><br><span class="line">    |- vs := tx.UnsafeRange(leaseBucketName...) <span class="comment">// 从`boltDB`中，查询`lease` bucket中所有数组</span></span><br><span class="line">    |- 对于每个记录，解码<span class="string">`lpb.Unmarshal(vs[i])`</span>，然后插进<span class="string">`le.leaseMap`</span>中</span><br><span class="line">        |- le.leaseMap[ID] = &amp;Lease&#123;</span><br><span class="line">			ID:  ID,</span><br><span class="line">			ttl: lpb.TTL,</span><br><span class="line">			itemSet: <span class="built_in">make</span>(<span class="keyword">map</span>[LeaseItem]<span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">			expiry:  forever,</span><br><span class="line">			revokec: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		&#125;</span><br><span class="line">	|- heap.Init(&amp;le.leaseHeap) <span class="comment">//初始化堆</span></span><br><span class="line">	|- heap.Init(&amp;le.leaseCheckpointHeap)</span><br><span class="line">|- <span class="keyword">go</span> l.runLoop() <span class="comment">// 运行500ms一次的任务，撤销过期的租约，周期性调度`Lease`检测。后续将详细分析其执行过程</span></span><br></pre></td></tr></table></figure>
<p>完成了<code>Lessor</code>的初始化后，随着进入<code>kvstore.restore</code>的初始化，会伴随着恢复<code>key</code>与<code>lease</code>的映射关系。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当从 bucket<span class="string">`key`</span>中获取所有key-val后，执行<span class="string">`restoreChunk`</span>方法</span><br><span class="line">restoreChunk</span><br><span class="line">|- 其会检测kv是否带<span class="string">`Lease`</span>，若有则加入到<span class="string">`keyToLease`</span><span class="keyword">map</span>中</span><br><span class="line">|- 对<span class="string">`keyToLease`</span><span class="keyword">map</span>中的每个entry</span><br><span class="line">    |- s.le.Attach(lid, []lease.LeaseItem&#123;&#123;Key: key&#125;&#125;)</span><br><span class="line">        |- 将<span class="string">`key`</span>绑定到<span class="string">`lease`</span>中，并建立<span class="string">`key`</span>到<span class="string">`lease`</span>的映射</span><br></pre></td></tr></table></figure>
<h2 id="5-2-Lease创建"><a href="#5-2-Lease创建" class="headerlink" title="5.2 Lease创建"></a>5.2 <code>Lease</code>创建</h2><p>创建<code>Lease</code>，最终会调用<code>EtcdServer.LeaseGrant</code>方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">EtcdServer.LeaseGrant</span><br><span class="line">|- r.ID = <span class="keyword">int64</span>(s.reqIDGen.Next() &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">63</span>) - <span class="number">1</span>)) <span class="comment">// 首先创建 leaseId</span></span><br><span class="line">|- s.raftRequestOnce 发起提议</span><br><span class="line">    |- 当集群确认提交此提议后，会进行应用。调用<span class="string">`lessor.Grant`</span></span><br><span class="line">        |- l := &amp;Lease&#123; <span class="comment">// 创建 Lease</span></span><br><span class="line">        		ID:      id,</span><br><span class="line">        		ttl:     ttl,</span><br><span class="line">        		itemSet: <span class="built_in">make</span>(<span class="keyword">map</span>[LeaseItem]<span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">        		revokec: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">        	&#125;</span><br><span class="line">        |- <span class="keyword">if</span> l.ttl &lt; le.minLeaseTTL &#123; <span class="comment">// 保证租约ttl不小于`minLeaseTTL`</span></span><br><span class="line">        		l.ttl = le.minLeaseTTL</span><br><span class="line">        	&#125;</span><br><span class="line">        |- l.refresh(<span class="number">0</span>) <span class="comment">// 设置 `Lease`的 `expiry`时间</span></span><br><span class="line">        |- le.leaseMap[id] = l <span class="comment">// 放入 `leaseId`与`lease`的映射</span></span><br><span class="line">        |- item := &amp;LeaseWithTime&#123;id: l.ID, time: l.expiry.UnixNano()&#125; <span class="comment">// 过期时间戳、leaseId item</span></span><br><span class="line">        |- heap.Push(&amp;le.leaseHeap, item) <span class="comment">// 存入堆中</span></span><br><span class="line">        |- l.persistTo(le.b) <span class="comment">// 将lease信息存储 boltDB中</span></span><br><span class="line">        |- le.scheduleCheckpointIfNeeded(l)</span><br><span class="line">            |- <span class="keyword">if</span> lease.RemainingTTL() &gt; <span class="keyword">int64</span>(le.checkpointInterval.Seconds()) &#123; <span class="comment">// 若`lease`的剩余时间比`检测点间隔`大时，则存进`le.leaseCheckpointHeap`中</span></span><br><span class="line">                |- heap.Push(&amp;le.leaseCheckpointHeap, &amp;LeaseWithTime&#123;</span><br><span class="line">        			id:   lease.ID,</span><br><span class="line">        			time: time.Now().Add(le.checkpointInterval).UnixNano(),</span><br><span class="line">        		&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="5-3-Lease绑定key"><a href="#5-3-Lease绑定key" class="headerlink" title="5.3 Lease绑定key"></a>5.3 <code>Lease</code>绑定<code>key</code></h2><p>在<code>put</code>操作时通过添加参数<code>--lease=326969472b0c5d08</code>即将<code>key</code>绑定到<code>lease</code>上。直接定位<code>storeTxnWrite.put</code>方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">oldLease = tw.s.le.GetLease(lease.LeaseItem&#123;Key: <span class="keyword">string</span>(key)&#125;) <span class="comment">// 获取key之前绑定的`lease`</span></span><br><span class="line"><span class="keyword">if</span> oldLease != lease.NoLease &#123;</span><br><span class="line">    err = tw.s.le.Detach(oldLease, []lease.LeaseItem&#123;&#123;Key: <span class="keyword">string</span>(key)&#125;&#125;) <span class="comment">// 剔除`key`与老`lease`的映射关系</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> leaseID != lease.NoLease &#123;</span><br><span class="line">    err = tw.s.le.Attach(leaseID, []lease.LeaseItem&#123;&#123;Key: <span class="keyword">string</span>(key)&#125;&#125;)</span><br><span class="line">    |- <span class="keyword">for</span> _, it := <span class="keyword">range</span> items &#123;</span><br><span class="line">    		l.itemSet[it] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    		le.itemMap[it] = id</span><br><span class="line">    	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-4-Lease过期"><a href="#5-4-Lease过期" class="headerlink" title="5.4 Lease过期"></a>5.4 <code>Lease</code>过期</h2><p>上文中介绍过在初始化<code>Lease</code>后，会启动<code>lessor.runLoop</code>任务：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="comment">// 注销过期的租约</span></span><br><span class="line">	le.revokeExpiredLeases()</span><br><span class="line">	<span class="comment">// 检测调度的租约</span></span><br><span class="line">	le.checkpointScheduledLeases()</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="comment">// 500ms 一次</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(<span class="number">500</span> * time.Millisecond):</span><br><span class="line">	<span class="keyword">case</span> &lt;-le.stopC:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">le.revokeExpiredLeases</span><br><span class="line">|- revokeLimit := leaseRevokeRate / <span class="number">2</span> <span class="comment">// 限流</span></span><br><span class="line">|- ls = le.findExpiredLeases(revokeLimit) <span class="comment">// 查询出过期的租约</span></span><br><span class="line">|- <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> le.expiredC &lt;- ls:</span><br><span class="line">   &#125;</span><br><span class="line">|- <span class="string">`EtcdServer`</span> 会监听<span class="string">`lessor.expiredC`</span>通道：</span><br><span class="line">|- 异步串行执行：<span class="string">`s.LeaseRevoke(ctx, &amp;pb.LeaseRevokeRequest&#123;ID: int64(lid)&#125;)`</span></span><br><span class="line">    |- 提交Revoke提议，最后进行应用：</span><br><span class="line">        |- lessor.Revoke</span><br><span class="line">            |- keys := l.Keys()</span><br><span class="line">            	sort.StringSlice(keys).Sort()</span><br><span class="line">            	<span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123; <span class="comment">// 删除key</span></span><br><span class="line">            		txn.DeleteRange([]<span class="keyword">byte</span>(key), <span class="literal">nil</span>)</span><br><span class="line">            	&#125;</span><br><span class="line">            |- <span class="built_in">delete</span>(le.leaseMap, l.ID)</span><br><span class="line">            |- le.b.BatchTx().UnsafeDelete(leaseBucketName, int64ToBytes(<span class="keyword">int64</span>(l.ID))) <span class="comment">// 从`lease`bucket中删除租约</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2019/11/23/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/etcd/5.etcd-%E4%BA%8B%E5%8A%A1%E8%AF%B7%E6%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.png">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/23/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/etcd/5.etcd-%E4%BA%8B%E5%8A%A1%E8%AF%B7%E6%B1%82/" class="post-title-link" itemprop="url">ETCD事务请求</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-23 00:00:00" itemprop="dateCreated datePublished" datetime="2019-11-23T00:00:00+08:00">2019-11-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-25 19:43:47" itemprop="dateModified" datetime="2020-02-25T19:43:47+08:00">2020-02-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/etcd/" itemprop="url" rel="index">
                    <span itemprop="name">etcd</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="4-事务请求"><a href="#4-事务请求" class="headerlink" title="4. 事务请求"></a>4. 事务请求</h1><p>[TOC]</p>
<p>本节我们将讲述 <code>etcd</code>集群的事务请求处理过程。首先我们将以<code>put</code>操作为例来讲解一般性事务请求过程。其次，我们将介绍 <code>etcd</code>特有的线性一致性读请求过程。</p>
<h2 id="put-请求"><a href="#put-请求" class="headerlink" title="put 请求"></a>put 请求</h2><p>通过 <code>etcdctl put ty dj</code> 命令，向本地监听<code>2380</code>端口的节点发送 写请求。<br>该请求为<code>GRPC</code>请求，会中转到<code>quotaKVServer</code>进行处理。</p>
<h3 id="Leader接收请求，并广播消息"><a href="#Leader接收请求，并广播消息" class="headerlink" title="Leader接收请求，并广播消息"></a><code>Leader</code>接收请求，并广播消息</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">quotaKVServer.Put</span><br><span class="line">|- s.qa.check(ctx,r) <span class="comment">//检查是否满足quota,即是否有足够的内存，如果没有则忽略请求，并发报警</span></span><br><span class="line">|- EtcdServer.Put <span class="comment">// 调用EtcdServer进行写</span></span><br><span class="line">    |- s.raftRequest(ctx, pb.InternalRaftRequest&#123;Put: r&#125;) <span class="comment">// EtcdServer将请求进行包装成 `InternalRaftRequest`</span></span><br><span class="line">      并调用<span class="string">`raftRequest`</span>进行请求，并等待获取结果</span><br><span class="line">        |- s.processInternalRaftRequestOnce<span class="comment">// 最终会调用此方法  </span></span><br><span class="line">            |- <span class="keyword">if</span> ci &gt; ai+maxGapBetweenApplyAndCommitIndex <span class="comment">//首先检查apply索引和 commit索引是否相差太大，若太大则忽略请求（自我保护机制）</span></span><br><span class="line">            |- 生成请求头，并生成请求ID <span class="string">`s.reqIDGen.Next()`</span></span><br><span class="line">            |- r.Marshal() <span class="comment">// 对请求进行编码</span></span><br><span class="line">            |- ch := s.w.Register(id) <span class="comment">// 注册请求响应回调</span></span><br><span class="line">            |- err = s.r.Propose(cctx, data) <span class="comment">// 向 raftNode 发起提议，申请写入数据</span></span><br><span class="line">            |- <span class="keyword">select</span> &#123; <span class="comment">// 等待结果，或超时</span></span><br><span class="line">            	   <span class="keyword">case</span> x := &lt;-ch:</span><br><span class="line">            		  <span class="keyword">return</span> x.(*applyResult), <span class="literal">nil</span></span><br><span class="line">            		  <span class="keyword">case</span> timeout</span><br><span class="line">            	&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就进入了主要的处理流程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node.Propose</span><br><span class="line">|- n.stepWait(ctx, pb.Message&#123;Type: pb.MsgProp, Entries: []pb.Entry&#123;&#123;Data: data&#125;&#125;&#125;) <span class="comment">// 将请求包装成 `MsgProp`消息</span></span><br><span class="line">    |- n.stepWithWaitOption</span><br><span class="line">        |- pm := msgWithResult&#123;m: m&#125; <span class="comment">// 将消息再一次封装</span></span><br><span class="line">        |- 将消息传递给 通道<span class="string">`n.propc`</span></span><br></pre></td></tr></table></figure>
<p>可以看出 将请求两层封装之后传递给通道<code>n.propc</code>。<br>在<code>node</code>的循环中，其会监听<code>proc</code>通道，当有消息到来时：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">node.start | <span class="number">360</span>+L</span><br><span class="line">|- m.From = r.id <span class="comment">// 将自己的id设置到消息的Form字段里</span></span><br><span class="line">|- err := r.Step(m) <span class="comment">// 再交给raft处理</span></span><br><span class="line">    |- r.step(r, m) <span class="comment">//此处就会根据节点的角色不同进行不同处理，若本节点是Follower则会转交给Leader节点进行处理，然后再进行如上的流程。这里假设本节点是主节点 即 stepLeader方法</span></span><br><span class="line">        |- r.appendEntry(m.Entries...) <span class="comment">// 将该记录追加到`raftLog`中</span></span><br><span class="line">            |- r.increaseUncommittedSize(es) <span class="comment">// 校验是否超过上界</span></span><br><span class="line">            |- r.raftLog.<span class="built_in">append</span>(es...) <span class="comment">// 追加到日志中记录下来（unstable中）</span></span><br><span class="line">            |- r.getProgress(r.id).maybeUpdate(li) <span class="comment">//更新本节点的复制进度</span></span><br><span class="line">            |- r.maybeCommit() <span class="comment">//对于单节点，尝试更新一次 raftLog中的 commit索引。//大多数节点都到达的索引</span></span><br><span class="line">        |- r.bcastAppend()  <span class="comment">// 广播消息</span></span><br><span class="line">            |- 对于每个其他成员节点，都执行 <span class="string">`r.sendAppend(id)`</span></span><br><span class="line">                |- pr := r.getProgress(to) <span class="comment">//获取节点的复制进程</span></span><br><span class="line">                |- term, errt := r.raftLog.term(pr.Next - <span class="number">1</span>) <span class="comment">// p.Next为该节点下次复制的索引号</span></span><br><span class="line">                |- ents, erre := r.raftLog.entries(pr.Next, r.maxMsgSize) <span class="comment">// 获取需要复制给对方节点的记录</span></span><br><span class="line">                |- 叫这些信息都封装成<span class="string">`MsgApp`</span>消息，进行发送</span><br><span class="line">                    |- r.send(m)</span><br><span class="line">                        |- r.msgs = <span class="built_in">append</span>(r.msgs, m) <span class="comment">// 将消息追加到了r.msgs中</span></span><br></pre></td></tr></table></figure>
<p>当本节点将需要发送给每个成员节点的消息都放到<code>r.msgs</code>后，<code>node.run</code>会进入下一轮循环。此时：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">node.run</span><br><span class="line">|- rd = newReady(r, prevSoftSt, prevHardSt) <span class="comment">// 准备好发送的消息结构体 Ready</span></span><br><span class="line">    |- rd := Ready&#123;</span><br><span class="line">    		Entries:          r.raftLog.unstableEntries(),</span><br><span class="line">    		CommittedEntries: r.raftLog.nextEnts(),</span><br><span class="line">    		Messages:         r.msgs, <span class="comment">// 消息在此进行包装</span></span><br><span class="line">    	&#125;</span><br><span class="line">|- readyc = n.readyc    	</span><br><span class="line">|- <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> readyc &lt;- rd: <span class="comment">// 此处即将消息传递到 n.readyc通道中</span></span><br><span class="line">     <span class="comment">//完成传递后，会进行一些状态的更新</span></span><br><span class="line">     <span class="keyword">if</span> index := rd.appliedCursor(); index != <span class="number">0</span> &#123;</span><br><span class="line">			applyingToI = index <span class="comment">// 提交消息的最大索引号</span></span><br><span class="line">		&#125;</span><br><span class="line">     advancec = n.advancec <span class="comment">// 赋值后，待本次消息发送完成后，进入下次循环。（等待 `raftNode`的通知）</span></span><br><span class="line">     <span class="keyword">case</span> &lt;-advancec:</span><br><span class="line">        <span class="comment">// 得到通知后，即知道之前的已提交的消息都已经发送出去了可以应用了</span></span><br><span class="line">			<span class="keyword">if</span> applyingToI != <span class="number">0</span> &#123;</span><br><span class="line">				r.raftLog.appliedTo(applyingToI)</span><br><span class="line">				applyingToI = <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送到<code>n.readyc</code>通道中的消息，会被<code>raftNode</code>捕获：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> rd := &lt;-r.Ready():</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">			<span class="keyword">if</span> islead &#123; <span class="comment">// 发送消息给相应节点</span></span><br><span class="line">		      r.transport.Send(r.processMessages(rd.Messages))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">			r.Advance() <span class="comment">// 这里是通知 node.advancec 可以处理下一个循坏</span></span><br><span class="line">    <span class="comment">// ...   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是<code>Leader</code>角色接收到<code>Put</code>请求后的处理逻辑，其中会向 <code>Follower</code>发送<code>MsgApp</code>消息。</p>
<h3 id="Follower接收到Leader的广播，进行处理回复"><a href="#Follower接收到Leader的广播，进行处理回复" class="headerlink" title="Follower接收到Leader的广播，进行处理回复"></a><code>Follower</code>接收到<code>Leader</code>的广播，进行处理回复</h3><p>当<code>Follower</code>收到消息后，会执行<code>EtcdServer.Process</code>方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EtcdServer.Process</span><br><span class="line">|- node.Step</span><br><span class="line">    |- node.step</span><br><span class="line">        |- n.recvc &lt;- m <span class="comment">// 最终传递给node.recvc通道</span></span><br><span class="line">            |- raft.Step <span class="comment">// node监听node.recvc，接收到消息后调用 raft执行逻辑</span></span><br><span class="line">            |- stepFollower</span><br><span class="line">                |- r.handleAppendEntries(m) <span class="comment">//处理追加记录</span></span><br><span class="line">                    |- r.raftLog.maybeAppend(m.Index, m.LogTerm, m.Commit, m.Entries...) <span class="comment">// 尝试追加消息</span></span><br><span class="line">                        |- l.matchTerm(index, logTerm) <span class="comment">// 校验 term 和index信息是否跟本节点一致</span></span><br><span class="line">                        |- l.findConflict(ents) <span class="comment">//找出冲突的索引号</span></span><br><span class="line">                        |- l.<span class="built_in">append</span>(ents[ci-offset:]...) <span class="comment">// 追加记录到raftLog中(unstable中)</span></span><br><span class="line">                        |- l.commitTo(min(committed, lastnewi)) <span class="comment">// 更新 commitId</span></span><br><span class="line">                    |- r.send(pb.Message&#123;To: m.From, Type: pb.MsgAppResp, Index: mlastIndex&#125;) <span class="comment">// 向 Leader反馈 信息`MsgAppResp`和索引号</span></span><br><span class="line">                        |- r.msgs = <span class="built_in">append</span>(r.msgs, m) <span class="comment">// 将消息追加到了r.msgs中</span></span><br></pre></td></tr></table></figure>
<p>发送的消息最终被 <code>raftNode</code>接收:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> rd := &lt;-r.Ready():</span><br><span class="line">        notifyc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">			ap := apply&#123;</span><br><span class="line">				entries:  rd.CommittedEntries, <span class="comment">// raft中已经提交的消息，</span></span><br><span class="line">				snapshot: rd.Snapshot,</span><br><span class="line">				notifyc:  notifyc,</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			updateCommittedIndex(&amp;ap, rh) <span class="comment">// 更新 EtcdServer的CommitId</span></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> r.applyc &lt;- ap: <span class="comment">// 将应用信息传递到 raftNode.applyc通道中，其被EtcdServer所监听。后续详解</span></span><br><span class="line">			&#125;</span><br><span class="line">			r.storage.Save(rd.HardState, rd.Entries) <span class="comment">// 实际调用WAL的Save方法，将记录写入到文件中 // ... wal</span></span><br><span class="line">			r.raftStorage.Append(rd.Entries) <span class="comment">// 将消息追加到 MemoryStorage中  </span></span><br><span class="line">		   <span class="keyword">if</span> !islead &#123;</span><br><span class="line">		      notifyc &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		      r.transport.Send(msgs)</span><br><span class="line">		   &#125;</span><br><span class="line">			r.Advance() <span class="comment">// 这里是通知 node.advancec 可以处理下一个循坏</span></span><br><span class="line">    <span class="comment">// ...   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看<code>EtcdServer</code>接收到<code>apply</code>消息后的处理：<br>再来看 <code>EtcdServer</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">EtcdServer/<span class="number">1020</span>L+-</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> ap := &lt;-s.r.apply():</span><br><span class="line">		f := <span class="function"><span class="keyword">func</span><span class="params">(context.Context)</span></span> &#123; s.applyAll(&amp;ep, &amp;ap) &#125;</span><br><span class="line">		sched.Schedule(f) <span class="comment">// 顺序调用`s.appAll`方法</span></span><br><span class="line">		s.applySnapshot(ep, apply)</span><br><span class="line">	   s.applyEntries(ep, apply) <span class="comment">//这里是应用服务最重要的地方</span></span><br><span class="line">	   |- 首先筛选出需要应用到此<span class="string">`EtcdServer`</span>的记录</span><br><span class="line">	   |- s.apply(ents, &amp;ep.confState)<span class="comment">//然后将这些记录应用到 `EtcdServer`中</span></span><br><span class="line">	       |- 对于正常的记录（<span class="string">`EntryNormal`</span>类型）</span><br><span class="line">	           |- <span class="keyword">case</span> raftpb.EntryNormal:</span><br><span class="line">            		s.applyEntryNormal(&amp;e)</span><br><span class="line">            		  |- s.consistIndex.setConsistentIndex(e.Index)<span class="comment">// 设置一致性索引号</span></span><br><span class="line">            		  |- 解码消息 Unmarshal</span><br><span class="line">            		  |- ar = s.applyV3.Apply(&amp;raftReq) <span class="comment">// 应用到应用数据存储中</span></span><br><span class="line">            		  |- s.w.Trigger(id, ar) <span class="comment">// 回调，通知该记录对应的请求</span></span><br><span class="line">           		    s.setAppliedIndex(e.Index)</span><br><span class="line">           			s.setTerm(e.Term)</span><br><span class="line"></span><br><span class="line">    |- &lt;-apply.notifyc <span class="comment">// 接到raftNode的通知已经完成发送等操作</span></span><br><span class="line">    |- s.triggerSnapshot(ep) <span class="comment">// 检查是否有 SnapshotCount操作，如果有则进行快照</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结起来，<code>Follower</code>节点接收到<code>Leader</code>节点的<code>MsgApp</code>应用到其节点中，然后向反馈<code>Leader</code> <code>MsgAppResp</code>消息，并带上自己的最大记录号。</p>
<h3 id="Leader收到Follower的回复进行处理"><a href="#Leader收到Follower的回复进行处理" class="headerlink" title="Leader收到Follower的回复进行处理"></a><code>Leader</code>收到<code>Follower</code>的回复进行处理</h3><p><code>Leader</code>收到<code>MsgAppResp</code>消息后，经过层层传递到<code>stepLeader</code>方法中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|- pr := r.getProgress(m.From) <span class="comment">// 获取该节点的进度</span></span><br><span class="line">|- <span class="keyword">switch</span> m.Type &#123;</span><br><span class="line">	<span class="keyword">case</span> pb.MsgAppResp:</span><br><span class="line">	   pr.RecentActive = <span class="literal">true</span> <span class="comment">//设置该节点状态</span></span><br><span class="line">	   |- pr.maybeUpdate(m.Index) <span class="comment">//更新该节点在 主节点中的进度信息（已经复制到什么位置了）</span></span><br><span class="line">	   |- 根据该节点的状态进行相应操作</span><br><span class="line">	   |- <span class="keyword">if</span> r.maybeCommit() &#123; <span class="comment">// 判断是否可以提交</span></span><br><span class="line">			r.bcastAppend()  <span class="comment">// 若可以提交，则广播消息</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们先来看判断是否可以提交的逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">raft.maybeCommit</span><br><span class="line">mis := r.matchBuf[:<span class="built_in">len</span>(r.prs)]</span><br><span class="line">idx := <span class="number">0</span></span><br><span class="line"><span class="comment">// 首先将每个成员节点确认的同步消息索引号放入数组中</span></span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> r.prs &#123;</span><br><span class="line">	mis[idx] = p.Match</span><br><span class="line">	idx++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按索引号排序</span></span><br><span class="line">sort.Sort(mis)</span><br><span class="line"><span class="comment">// 获取 len(mis)-r.quorum()位的索引位置</span></span><br><span class="line">mci := mis[<span class="built_in">len</span>(mis)-r.quorum()]</span><br><span class="line"><span class="keyword">return</span> r.raftLog.maybeCommit(mci, r.Term) <span class="comment">//判断是否比raftLog中的CommitId大，若是则表示有数据可以提交</span></span><br><span class="line">    |- <span class="keyword">if</span> maxIndex &gt; l.committed &amp;&amp; l.zeroTermOnErrCompacted(l.term(maxIndex)) == term &#123;</span><br><span class="line">		l.commitTo(maxIndex) <span class="comment">// 更新commitId</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>r.bcastAppend()</code>的处理过程之前以及介绍过，其会构造一遍<code>Ready</code>数据结构，带上<code>CommitedEntries</code>提交的数据、其他节点未同步的<code>Entries</code>，传递给<code>raftNode</code>。<code>raftNode</code>接收到此消息后，会执行与上面分析的<code>Follower</code>的逻辑类似。</p>
<h2 id="线性一致性读"><a href="#线性一致性读" class="headerlink" title="线性一致性读"></a>线性一致性读</h2><p>线性一致性读和一般的读不通的时候，会在进行真正的读请求之前，先与其他节点进行一个check，查看当前集群主是否发生了变化。通过<code>etcdctl get ty</code>命令，向监听本地<code>2380</code>端口的节点发送<code>GRPC</code>请求，会被中转到<code>quotaKVServer</code>上。<br><code>get</code>请求在<code>etcdctl</code>中会被转换成<code>Range</code>请求。<code>quotaKVServer</code>最终会调用<code>EtcdServer.Range</code>方法。</p>
<h3 id="Leader节点收到请求后，广播心跳消息"><a href="#Leader节点收到请求后，广播心跳消息" class="headerlink" title="Leader节点收到请求后，广播心跳消息"></a><code>Leader</code>节点收到请求后，广播心跳消息</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">quotaKVServer</span><br><span class="line">|- kvServer.Range</span><br><span class="line">    |- EtcdServer.Range</span><br><span class="line">        |- <span class="keyword">if</span> !r.Serializable &#123; <span class="comment">//是否线性一致性</span></span><br><span class="line">    		err = s.linearizableReadNotify(ctx)</span><br><span class="line">    		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    		&#125;</span><br><span class="line">    		resp, err = s.applyV3Base.Range(<span class="literal">nil</span>, r)</span><br><span class="line">    	&#125;</span><br></pre></td></tr></table></figure>
<p>线性一致性读的主要逻辑体现在 <code>s.linearizableReadNotify</code>中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s.linearizableReadNotify  <span class="comment">// 线性读通知</span></span><br><span class="line">|- nc := s.readNotifier <span class="comment">// 用于通知读协程可以进行读操作</span></span><br><span class="line">|- <span class="keyword">select</span> &#123;</span><br><span class="line">	   <span class="keyword">case</span> s.readwaitc &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;: <span class="comment">//通知读等待通道</span></span><br><span class="line">	&#125;</span><br><span class="line">|- <span class="keyword">select</span> &#123;</span><br><span class="line">	   <span class="keyword">case</span> &lt;-nc.c: <span class="comment">// 等待读状态通知</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>EtcdServer</code>在启动的时候会启动<code>linearizableReadLoop</code>线性一致性读循环。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">linearizableReadLoop</span><br><span class="line">|- ctxToSend := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">8</span>)</span><br><span class="line">|- id1 := s.reqIDGen.Next()</span><br><span class="line">|- binary.BigEndian.PutUint64(ctxToSend, id1)</span><br><span class="line">|- <span class="keyword">for</span> ;; &#123;</span><br><span class="line">     <span class="keyword">select</span> &#123;</span><br><span class="line">    	<span class="keyword">case</span> &lt;-s.readwaitc: <span class="comment">// 当接收到线性一致性读请求后，循环就可以往下走</span></span><br><span class="line">    	&#125;</span><br><span class="line">    	nextnr := newNotifier() <span class="comment">// 创建新的读通知器，给下一个读请求使用</span></span><br><span class="line">    	nr := s.readNotifier</span><br><span class="line">		s.readNotifier = nextnr</span><br><span class="line">		err := s.r.ReadIndex(cctx, ctxToSend) <span class="comment">// 调用`node.ReadeIndex`发起读索引请求</span></span><br><span class="line">	   <span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> rs = &lt;-s.r.readStateC:</span><br><span class="line">			done = bytes.Equal(rs.RequestCtx, ctxToSend)</span><br><span class="line">		<span class="keyword">case</span> &lt;-leaderChangedNotifier:</span><br><span class="line">			nr.notify(ErrLeaderChanged)</span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(s.Cfg.ReqTimeout()):</span><br><span class="line">			nr.notify(ErrTimeout)</span><br><span class="line">			timeout = <span class="literal">true</span></span><br><span class="line">			slowReadIndex.Inc()</span><br><span class="line">		<span class="keyword">case</span> &lt;-s.stopping:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">|- nr.notify(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">node.ReadIndex</span><br><span class="line">|- n.step(ctx, pb.Message&#123;Type: pb.MsgReadIndex, Entries: []pb.Entry&#123;&#123;Data: rctx&#125;&#125;&#125;) <span class="comment">//</span></span><br><span class="line">    |- raft.Step</span><br><span class="line">        |- raft.stepLeader</span><br><span class="line">            |- <span class="keyword">if</span> r.raftLog.zeroTermOnErrCompacted(r.raftLog.term(r.raftLog.committed)) != r.Term &#123; <span class="comment">// 当本任期没有提交任何消息时，拒绝读</span></span><br><span class="line">    				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    			&#125;</span><br><span class="line">    			<span class="keyword">switch</span> r.readOnly.option &#123;</span><br><span class="line">    			<span class="keyword">case</span> <span class="string">`ReadOnlySafe`</span>:</span><br><span class="line">    				r.readOnly.addRequest(r.raftLog.committed, m) <span class="comment">// 将只读请求添加到`readyOnly`结构里。</span></span><br><span class="line">    				r.bcastHeartbeatWithCtx(m.Entries[<span class="number">0</span>].Data)<span class="comment">// 带上请求的ID，向所有成员节点发送心跳。</span></span><br><span class="line">    			<span class="keyword">case</span> <span class="string">`ReadOnlyLeaseBased`</span>:</span><br><span class="line">    				ri := r.raftLog.committed</span><br><span class="line">    				<span class="keyword">if</span> m.From == None || m.From == r.id &#123; <span class="comment">// from local member</span></span><br><span class="line">    					r.readStates = <span class="built_in">append</span>(r.readStates, ReadState&#123;Index: r.raftLog.committed, RequestCtx: m.Entries[<span class="number">0</span>].Data&#125;)</span><br><span class="line">    				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    					r.send(pb.Message&#123;To: m.From, Type: pb.MsgReadIndexResp, Index: ri, Entries: m.Entries&#125;)</span><br><span class="line">    				&#125;</span><br><span class="line">    			&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Follower接收到Leader的心跳请求，并返回"><a href="#Follower接收到Leader的心跳请求，并返回" class="headerlink" title="Follower接收到Leader的心跳请求，并返回"></a><code>Follower</code>接收到<code>Leader</code>的心跳请求，并返回</h3><p><code>Follower</code>接收到<code>Leader</code>的心跳请求，最终会调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r.raftLog.commitTo(m.Commit)</span><br><span class="line">r.send(pb.Message&#123;To: m.From, Type: pb.MsgHeartbeatResp, Context: m.Context&#125;) <span class="comment">// 发送心跳回复</span></span><br></pre></td></tr></table></figure>
<h3 id="Leader接收Follower回复，通知客户端请求继续"><a href="#Leader接收Follower回复，通知客户端请求继续" class="headerlink" title="Leader接收Follower回复，通知客户端请求继续"></a><code>Leader</code>接收<code>Follower</code>回复，通知客户端请求继续</h3><p><code>Leader</code>节点接收到<code>Follower</code>的回复后，最终会调用如下逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">pr.RecentActive = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> pr.Match &lt; r.raftLog.lastIndex() &#123; <span class="comment">// 当Follower节点有数据没复制时，进行发送</span></span><br><span class="line">	r.sendAppend(m.From)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 操作readyOnly接收Ack，并返回有多少节点已经确认</span></span><br><span class="line">ackCount := r.readOnly.recvAck(m)</span><br><span class="line"><span class="keyword">if</span> ackCount &lt; r.quorum() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回有哪些请求可以继续往下走</span></span><br><span class="line">rss := r.readOnly.advance(m)</span><br><span class="line"><span class="keyword">for</span> _, rs := <span class="keyword">range</span> rss &#123;</span><br><span class="line">	req := rs.req</span><br><span class="line">	<span class="keyword">if</span> req.From == None || req.From == r.id &#123;</span><br><span class="line">	   <span class="comment">// 将可以读的请求信息放到 r.readStates中，等后面提交到 ReadyC结构体，向上提交进行处理。</span></span><br><span class="line">		r.readStates = <span class="built_in">append</span>(r.readStates, ReadState&#123;Index: rs.index, RequestCtx: req.Entries[<span class="number">0</span>].Data&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ro *readOnly)</span> <span class="title">recvAck</span><span class="params">(m pb.Message)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	rs, ok := ro.pendingReadIndex[<span class="keyword">string</span>(m.Context)]  <span class="comment">// m.Context 为请求ID</span></span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	rs.acks[m.From] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(rs.acks) + <span class="number">1</span> <span class="comment">// 返回已经有多少Follower进行了应答</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回容许读的请求ID列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ro *readOnly)</span> <span class="title">advance</span><span class="params">(m pb.Message)</span> []*<span class="title">readIndexStatus</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		i     <span class="keyword">int</span></span><br><span class="line">		found <span class="keyword">bool</span></span><br><span class="line">	)</span><br><span class="line">	ctx := <span class="keyword">string</span>(m.Context)</span><br><span class="line">	rss := []*readIndexStatus&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, okctx := <span class="keyword">range</span> ro.readIndexQueue &#123;</span><br><span class="line">		i++</span><br><span class="line">		rs, ok := ro.pendingReadIndex[okctx]</span><br><span class="line">		rss = <span class="built_in">append</span>(rss, rs)</span><br><span class="line">		<span class="comment">// 找到匹配的读，以及可以触发读的请求队列。</span></span><br><span class="line">		<span class="keyword">if</span> okctx == ctx &#123;</span><br><span class="line">			found = <span class="literal">true</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> found &#123;</span><br><span class="line">		ro.readIndexQueue = ro.readIndexQueue[i:]<span class="comment">// 剔除之前的读请求</span></span><br><span class="line">		<span class="keyword">for</span> _, rs := <span class="keyword">range</span> rss &#123;</span><br><span class="line">			<span class="built_in">delete</span>(ro.pendingReadIndex, <span class="keyword">string</span>(rs.req.Entries[<span class="number">0</span>].Data))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> rss</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>raftNode</code>结构体接收到<code>Ready</code>消息时，会检查是否有<code>ReadStates</code>，然后对其进行处理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(rd.ReadStates) != <span class="number">0</span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> r.readStateC &lt;- rd.ReadStates[<span class="built_in">len</span>(rd.ReadStates)<span class="number">-1</span>]:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再回到<code>linearizableReadLoop</code>中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> rs = &lt;-s.r.readStateC:</span><br><span class="line">	<span class="keyword">case</span> &lt;-leaderChangedNotifier:</span><br><span class="line">		nr.notify(ErrLeaderChanged)</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(s.Cfg.ReqTimeout()):</span><br><span class="line">		nr.notify(ErrTimeout)</span><br><span class="line">	<span class="keyword">case</span> &lt;-s.stopping:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">nr.notify(<span class="literal">nil</span>) <span class="comment">// 通知客户端可以进行查询请求</span></span><br></pre></td></tr></table></figure>
<p>到此就完成线性一致性读的全过程。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2019/11/22/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/etcd/4.etcd-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.png">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/22/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/etcd/4.etcd-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" class="post-title-link" itemprop="url">ETCD网络通信</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-22 00:00:00" itemprop="dateCreated datePublished" datetime="2019-11-22T00:00:00+08:00">2019-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-13 19:56:38" itemprop="dateModified" datetime="2020-02-13T19:56:38+08:00">2020-02-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/etcd/" itemprop="url" rel="index">
                    <span itemprop="name">etcd</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2-网络通信"><a href="#2-网络通信" class="headerlink" title="2. 网络通信"></a>2. 网络通信</h1><p>在上一节，我们介绍了<code>etcd</code>集群的启动过程。在其中也简单介绍了会初始化与其他成员节点通信的连接，以及启动为其他成员节点提供服务的<code>GRPC</code>服务和<code>Http</code>服务以及启动服务客户端的服务。本章我们将详细介绍通信相关的实现。</p>
<h2 id="2-1-成员节点间通信（peer）"><a href="#2-1-成员节点间通信（peer）" class="headerlink" title="2.1 成员节点间通信（peer）"></a>2.1 成员节点间通信（peer）</h2><p>前一章节介绍了peer服务端启动过程。下面，我们来讲解下调用端是如何初始化以及如何调用的。<br>与成员节点间通信传输的初始化之前介绍过，是调用<code>Transport.AddPeer</code>方法。<br>前面我们介绍了<code>Transport</code>的作用：向成员节点发送raft消息，并从成员节点获取raft消息。下面将详细描述其作用。<br>首先来看其初始化和启动过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">tr := &amp;rafthttp.Transport&#123;</span><br><span class="line">	DialTimeout: cfg.peerDialTimeout(),</span><br><span class="line">	ID:          id,</span><br><span class="line">	URLs:        cfg.PeerURLs,</span><br><span class="line">	ClusterID:   cl.ID(),</span><br><span class="line">	Raft:        srv, <span class="comment">// EtcdServer</span></span><br><span class="line">	Snapshotter: ss,</span><br><span class="line">	ServerStats: sstats,</span><br><span class="line">	LeaderStats: lstats,</span><br><span class="line">	ErrorC:      srv.errorc,</span><br><span class="line">&#125;</span><br><span class="line">tr.Start()</span><br><span class="line">|- t.streamRt = newStreamRoundTripper(t.TLSInfo, t.DialTimeout) <span class="comment">// 其作用前面介绍过：可以执行事务性HTTP请求，给定请求获取结果</span></span><br><span class="line">|- t.pipelineRt = NewRoundTripper(t.TLSInfo, t.DialTimeout) <span class="comment">//</span></span><br><span class="line">|- t.remotes = <span class="built_in">make</span>(<span class="keyword">map</span>[types.ID]*remote) <span class="comment">// 初始化复制节点映射</span></span><br><span class="line">|- t.peers = <span class="built_in">make</span>(<span class="keyword">map</span>[types.ID]Peer) <span class="comment">// 初始化成员节点映射</span></span><br><span class="line">|- t.pipelineProber = probing.NewProber(t.pipelineRt) <span class="comment">// Prober的作用是探测，探测链路监控状态</span></span><br><span class="line">|- t.streamProber = probing.NewProber(t.streamRt)</span><br></pre></td></tr></table></figure>
<p>接下来，继续了解<code>AddPeer</code>实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Transport/AddPeer</span><br><span class="line">|- startPeer</span><br><span class="line">    |- picker := newURLPicker(urls) <span class="comment">// 其用于选取通信通道（负载均衡作用）</span></span><br><span class="line">    |- pipeline := &amp;pipeline&#123;...&#125; <span class="comment">// 创建pipeline，多通道发送消息。</span></span><br><span class="line">    |- pipeline.start() <span class="comment">// 开启多个异步任务，监听 msgC通道，进行数据发送</span></span><br><span class="line">    |- p := &amp;peer&#123;...&#125; <span class="comment">// 创建peer结构体，初始化其属性，如recev、propc通道、消息发送器 msgAppV2Writer、writer（StreamWriter）</span></span><br><span class="line">    |- <span class="keyword">go</span> <span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> mm := &lt;-p.recvc:  <span class="comment">//监听 recev通道发来的消息，并将其丢给 EtcdServer.`Process`方法处理</span></span><br><span class="line">				<span class="keyword">if</span> err := r.Process(ctx, mm)</span><br><span class="line">			&#125;</span><br><span class="line">    |- <span class="keyword">go</span> <span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> mm := &lt;-p.propc: <span class="comment">// 监听 propc 通道发来的消息，将其丢给...</span></span><br><span class="line">				<span class="keyword">if</span> err := r.Process(ctx, mm);</span><br><span class="line">		  &#125;</span><br><span class="line">    |-  初始化 <span class="string">`p.msgAppV2Reader`</span>、<span class="string">`p.msgAppReader`</span> 用于读取消息</span><br><span class="line">    |- p.msgAppV2Reader.start() <span class="comment">// 开启监听消息读取</span></span><br><span class="line">    |- p.msgAppReader.start()    </span><br><span class="line">|- addPeerToProber(t.Logger, t.pipelineProber, id.String(), us, RoundTripperNameSnapshot, rttSec) <span class="comment">// 将该节点添加到探测器中，进行定期探测状态</span></span><br><span class="line">|-	addPeerToProber(t.Logger, t.streamProber, id.String(), us, RoundTripperNameRaftMessage, rttSec)</span><br></pre></td></tr></table></figure>
<p>从上面的流程可以看出 <code>peer</code>使用stream模式通信方式。读写分别用不同的协程去监听处理。其中<code>streamWriter</code>负责消息发送，<code>streamReader</code>负责消息接收。见下面详情：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">w := &amp;streamWriter&#123;</span><br><span class="line">	peerID:  id,</span><br><span class="line">	status: status,</span><br><span class="line">	fs:     fs,</span><br><span class="line">	r:      r,</span><br><span class="line">	msgc:   <span class="built_in">make</span>(<span class="keyword">chan</span> raftpb.Message, streamBufSize),</span><br><span class="line">	connc:  <span class="built_in">make</span>(<span class="keyword">chan</span> *outgoingConn),</span><br><span class="line">	stopc:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">	done:   <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">&#125;</span><br><span class="line">w.run:</span><br><span class="line">|- <span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-heartbeatc:</span><br><span class="line">	<span class="comment">//发送心跳消息</span></span><br><span class="line">	<span class="keyword">case</span> m := &lt;-msgc:</span><br><span class="line">	<span class="comment">// 接收到需要发送的消息，进行编码并使用conn进行发送</span></span><br><span class="line">    <span class="keyword">case</span> conn := &lt;-cw.connc:</span><br><span class="line">    <span class="comment">// 监听附加上来的连接通道，进行初始化 编码器、Flusher等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>streamWriter</code>里比较关键的一点是，这里的<code>conn</code>从哪来？往<code>cw.connc</code>传递<code>conn</code>的只有<code>peer.attachOutgoingConn</code>方法。<br>而在上面初始化并启动<code>peer</code>的时候是没有发现调用这个方法的 ？？？哪是哪里进行执行的呢？通过 追踪<code>peer.attachOutgoingConn</code>的调用方，最终发现，其在<code>rafthhtp/http.go/ServeHTTP() L483</code>处调用。而这个方法会在客户端建立连接<strong>进行http服务调用</strong>的时候执行。所以，在这里调用 <code>peer.attachOutgoingConn</code> 的作用是复用<code>连接</code>。当我们分析完读处理过程后，再来整体看 <code>etcd</code>节点是怎么建立通信链路的。</p>
<p><code>StreamReader</code>的处理比<code>StreamWriter</code>的处理要简单一些。初始化完其属性后，调用<code>start</code>方法启动监听读请求过程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StreamReader/start</span><br><span class="line">|- run</span><br><span class="line">    |- rc, err := cr.dial(t) <span class="comment">// 进行拨号，建立起与peer之间的连接</span></span><br><span class="line">    |- err = cr.decodeLoop(rc, t) <span class="comment">// 获取返回结果，进行解码</span></span><br><span class="line">        |- <span class="keyword">for</span>&#123; m, err := dec.decode() <span class="comment">//循环解码</span></span><br><span class="line">        |- 如果 m 是<span class="string">`MsgProp`</span>类型，则将消息传递到 propc通道，否则到 recv通道</span><br></pre></td></tr></table></figure>
<p>这样每个peer之间的链路就建立了。回过头来，可以看出每对<code>peer</code>之间至少会有两条<code>connection</code>。且他们之间交互交错使用。</p>
<p>单<code>peer</code>往对方发送的消息，是通过 <strong>对方跟自己建立的连接</strong> 来发送的。</p>
<p>最后，我们通过单次请求响应过程，来介绍节点间的通信过程。</p>
<p>当要想集群其他成员节点发送消息时，最终会调用<code>peer.send</code>方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">peer.send</span><br><span class="line">|- writec, name := p.pick(m) <span class="comment">// 首先peer会根据m的类型来选择一个发送通道</span></span><br><span class="line">    |- isMsgSnap(m) <span class="keyword">return</span> p.pipeline.msgc, pipelineMsg <span class="comment">// 如果是快照消息，则通过pipeline.msgc来发送消息</span></span><br><span class="line">    |- isMsgApp(m) <span class="keyword">return</span> p.msgAppV2Writer.writec(),streamAppV2 <span class="comment">// 如果是MsgApp消息</span></span><br><span class="line">    |- 如果 p.writer.writec() 可用，<span class="keyword">return</span> p.writer.writec()</span><br><span class="line">    |- 备用 p.pipeline.msgc, pipelineMsg</span><br><span class="line">|- writec &lt;- m: <span class="comment">// 即发送数据到 写通道中，`StreamWriter` 中会监听此通道。</span></span><br><span class="line"></span><br><span class="line">StreamWriter.run</span><br><span class="line">|- <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> m := &lt;-msgc:</span><br><span class="line">     |- enc.encode(&amp;m)</span><br><span class="line">        |- binary.Write(enc.w, binary.BigEndian, <span class="keyword">uint64</span>(m.Size())) <span class="comment">// 对于 messageEncoder，首先发送字节长度</span></span><br><span class="line">        |- enc.w.Write(pbutil.MustMarshal(m)) <span class="comment">//再发送字节内容</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目标节点的 <strong>StreamReader</strong>（<code>p.msgAppReader</code>）接收到消息后，通过解析后传递到 <code>EtcdServer</code>(Process)，即完成单次通信；对于请求的响应，则通过对方的<code>peer</code>来发送给本节点，本节点的<code>StreamReader</code>来接受响应消息。</p>
<h2 id="2-2-客户端通信"><a href="#2-2-客户端通信" class="headerlink" title="2.2 客户端通信"></a>2.2 客户端通信</h2><p>对于客户端通信，因为是<code>GRPC</code>或者<code>HTTP</code>简单的请求响应方式，因此这里就不再介绍了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2019/11/21/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/etcd/3.etcd-%E5%AD%98%E5%82%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.png">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/21/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/etcd/3.etcd-%E5%AD%98%E5%82%A8/" class="post-title-link" itemprop="url">ETCD数据存储</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-21 00:00:00" itemprop="dateCreated datePublished" datetime="2019-11-21T00:00:00+08:00">2019-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-13 19:56:32" itemprop="dateModified" datetime="2020-02-13T19:56:32+08:00">2020-02-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/etcd/" itemprop="url" rel="index">
                    <span itemprop="name">etcd</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="3-数据存储"><a href="#3-数据存储" class="headerlink" title="3. 数据存储"></a>3. 数据存储</h1><p><code>Etcd</code>的存储部分，可以分两部分来讲解。一部分是其应用层的数据存储方式，另一部分是<code>raft</code>相关数据的存储。<code>Etcd</code>应用层的数据存储从<code>v3</code>版本开始就延用<code>boltDB</code>，其也是<code>CoreOS</code>的产品<a href="https://github.com/etcd-io/bbolt" target="_blank" rel="noopener">boltDB</a>。PS:本文主要聚焦于v3版本，对于v2版本不作解读。</p>
<p>下面将分别介绍这两部分内容：</p>
<h2 id="3-1-raft数据存储"><a href="#3-1-raft数据存储" class="headerlink" title="3.1 raft数据存储"></a>3.1 raft数据存储</h2><p>首先我们来介绍下<code>raft</code>相关的数据存储：<br><code>raft</code>中有两个比较重要的组件：</p>
<ul>
<li><code>raftLog</code>：用来保存状态机相关信息的，包括当前任期、索引号、不稳定记录项等；</li>
<li><code>WAL</code>：预写日志器，用于以顺序形式写入操作记录，以便故障时数据恢复；</li>
<li><code>Snapshot</code>：数据快照，一般用于启动时快速恢复数据。</li>
</ul>
<p>首先来看<code>raftLog</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> raftLog <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 包含所有稳定的记录 MemeoryStorge</span></span><br><span class="line">	storage Storage</span><br><span class="line"> <span class="comment">// 包含所有不稳定的记录</span></span><br><span class="line">	unstable unstable</span><br><span class="line"> <span class="comment">// 提交记录索引</span></span><br><span class="line">	committed <span class="keyword">uint64</span></span><br><span class="line"><span class="comment">// 应用记录索引</span></span><br><span class="line">	applied <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> MemoryStorage <span class="keyword">struct</span> &#123;</span><br><span class="line">	hardState pb.HardState</span><br><span class="line">	<span class="comment">// 快照信息（保存 v2版存储中的保存的数据快照、任期、索引、ConfState[集群节点信息]）。快照生成一般有个条件：距上次提交的次数大于`SnapshotCount`（默认10000）</span></span><br><span class="line">	snapshot  pb.Snapshot</span><br><span class="line">	ents []pb.Entry</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从名字也可以看出其用途</span></span><br><span class="line"><span class="keyword">type</span> unstable <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 快照信息，这里只会在节点加入集群，主节点向其发送`MsgSnap`消息的时候才会有</span></span><br><span class="line">	snapshot *pb.Snapshot</span><br><span class="line">	entries []pb.Entry</span><br><span class="line">	offset  <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图描述了数据从客户端请求到落地各个阶段与以前存储结构的关系：<br><img src="/media/15516348174091.jpg" alt=""></p>
<p>其中，8’、9、11 是涉及 <strong>I/O</strong> 的操作，其他均为内存操作。<br>对<code>WAL</code>的操作在每次写事务操作中都会存在，因此其是制约<code>etcd</code>写性能的一个重要因素。接下来，将重点介绍<code>WAL</code>的工作原理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WAL <span class="keyword">struct</span> &#123;</span><br><span class="line">	dir <span class="keyword">string</span>       <span class="comment">// WAL文件所在目录</span></span><br><span class="line">	dirFile *os.File <span class="comment">// 目录文件句柄</span></span><br><span class="line">	metadata []<span class="keyword">byte</span>  <span class="comment">// 元数据，记录在每个wal文件头</span></span><br><span class="line">	state    raftpb.HardState <span class="comment">// 硬状态（任期、索引号），记录在每个文件头</span></span><br><span class="line">	start     walpb.Snapshot <span class="comment">// snapshot to start reading</span></span><br><span class="line">	decoder   *decoder       <span class="comment">// 解码器</span></span><br><span class="line">	enti    <span class="keyword">uint64</span>   <span class="comment">// 保存到WAL的最大索引号</span></span><br><span class="line">	encoder *encoder <span class="comment">// 编码器</span></span><br><span class="line">	locks []*fileutil.LockedFile <span class="comment">// 文件锁</span></span><br><span class="line">	fp    *filePipeline    <span class="comment">// 文件创建工具，预先创建文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，来看其创建过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">wal.Create</span><br><span class="line">|- tmpdirpath := filepath.Clean(dirpath) + <span class="string">".tmp"</span></span><br><span class="line">|- os.RemoveAll(tmpdirpath)</span><br><span class="line">|-	fileutil.CreateDirAll(tmpdirpath)</span><br><span class="line">|- p := filepath.Join(tmpdirpath, walName(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">|- f, err := fileutil.LockFile(p, os.O_WRONLY|os.O_CREATE, fileutil.PrivateFileMode)</span><br><span class="line">|- f.Seek(<span class="number">0</span>, io.SeekEnd)</span><br><span class="line">|- fileutil.Preallocate(f.File, SegmentSizeBytes, <span class="literal">true</span>)  <span class="comment">// 预分配空间</span></span><br><span class="line">|- w := &amp;WAL&#123;</span><br><span class="line">    	lg:       lg,</span><br><span class="line">    	dir:      dirpath,</span><br><span class="line">    	metadata: metadata,</span><br><span class="line">    &#125;</span><br><span class="line">|- w.encoder, err = newFileEncoder(f.File, <span class="number">0</span>)	<span class="comment">// 编码器，编码器编码的同时会将结果写到文件中</span></span><br><span class="line">|- w.locks = <span class="built_in">append</span>(w.locks, f)</span><br><span class="line">|-	w.saveCrc(<span class="number">0</span>) w.encoder.encode(&amp;walpb.Record&#123;Type: metadataType, Data: metadata&#125;)<span class="comment">// 写文件头</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">|- w.SaveSnapshot(walpb.Snapshot&#123;&#125;)</span><br><span class="line">|- w.renameWAL(tmpdirpath)  <span class="comment">// 更改零时文件名称为waldir，创建FilePipeline（用于预先创建文件）</span></span><br><span class="line">|-pdir, perr := fileutil.OpenDir(filepath.Dir(w.dir))</span><br><span class="line">|- fileutil.Fsync(pdir)</span><br></pre></td></tr></table></figure>
<p>创建<code>WAL</code>时，会初始化编码器以及<code>FilePipeline</code>。下面再以其<code>Save</code>方法来介绍保存记录的过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">WAL.Save</span><br><span class="line">|- mustSync := raft.MustSync(st, w.state, <span class="built_in">len</span>(ents)) <span class="comment">// 判断是否需要文件同步，写入磁盘</span></span><br><span class="line">|- <span class="keyword">for</span> each ents: saveEntry</span><br><span class="line">    |- b := pbutil.MustMarshal(e) rec := &amp;walpb.Record&#123;Type: entryType, Data: b&#125;</span><br><span class="line">    |- w.encoder.encode(rec) <span class="comment">// 编码后写入文件</span></span><br><span class="line">|- w.saveState(&amp;st) <span class="comment">// 保存状态</span></span><br><span class="line">|- curOff, err := w.tail().Seek(<span class="number">0</span>, io.SeekCurrent)</span><br><span class="line">|- <span class="keyword">if</span> curOff &lt; SegmentSizeBytes &amp; mustSync w.sync() 如果文件还没大于SegmentSizeBytes，且需要同步，则进行文件同步</span><br><span class="line">|- 如果大于，则进行切割文件 <span class="string">`w.cut`</span></span><br><span class="line">    |- fpath := filepath.Join(w.dir, walName(w.seq()+<span class="number">1</span>, w.enti+<span class="number">1</span>))</span><br><span class="line">    |- newTail, err := w.fp.Open() <span class="comment">// 通过filePipeline获取一个新的零时文件</span></span><br><span class="line">    |- 进行初始化 w.encoder, err = newFileEncoder(w.tail().File, prevCrc) ...</span><br><span class="line">    |- os.Rename(newTail.Name(), fpath) <span class="comment">// 重命名</span></span><br><span class="line">    |- w.sync()</span><br></pre></td></tr></table></figure>
<p>随着记录的增加，<code>wal</code>文件会越来越多，入股不做处理的话会导致磁盘被占满。那么<code>etcd</code>是怎么做的呢？<br>其实是由两步构成的：</p>
<ol>
<li>当<code>etcd</code>每次进行执行快照的实时，会进行<code>wal.ReleaseLockTo(snap.Metadata.Index)</code>释放文件锁的操作。（释放快照对应索引号之前的所有WAL文件句柄）</li>
<li>之前在<code>EtcdServer</code>启动章节介绍过，其启动后会启动一个定时任务<code>purgeFile</code>。其会针对<code>snap.db</code>、<code>snap</code>、<code>wal</code>文件做30秒一次的<code>fileutil.PurgeFile</code>任务：<ol>
<li>任务带有参数 <code>MaxWalFiles</code>，获取指定<code>wal.dir</code>下所有文件，然后按文件名排序，从小到大进行遍历：尝试锁文件。如果成功，则进行删除，否则的话说明依然被<code>etcd</code>锁占用。</li>
</ol>
</li>
</ol>
<h2 id="3-2-应用数据存储"><a href="#3-2-应用数据存储" class="headerlink" title="3.2 应用数据存储"></a>3.2 应用数据存储</h2><p>在解析<code>etcd</code>应用层数据存储结构前，先来介绍下<code>etcd</code>的数据存储形式。<code>etcd</code>对数据的存储并不是直接存储<code>key-value</code>对，而是引入了一种带版本号<code>revision</code>的存储方式：以数据的<code>revison</code>为<code>key</code>，键值对为值。<br><code>revision</code>由两部分组成：<code>main-revision</code>.<code>sub-revision</code>。<code>main-revision</code>为事务ID，<code>sub-revision</code>为事务中一次操作ID。</p>
<p>举例来说：<br>系统刚启动后，在一个事务中执行<code>put ty dj \n put dj ty</code>两个操作，实际存储的是</p>
<ol>
<li>{1,0} key=ty val=dj</li>
<li>{1,1} key=dj val=ty</li>
</ol>
<p>紧接着执行第二次操作：<code>put ty dj90 \n put dj ty92</code>，那么存储中会追加如下信息：</p>
<ol>
<li>{2,0} key=ty val=dj90</li>
<li>{2,1} key=dj val=ty92</li>
</ol>
<p>而为了支持这种存储形式快速查询，<code>etcd</code>建立了<code>treeIndex</code>结构，用于建立<code>key</code>与<code>revision</code>间的关系。随之，通过<code>key</code>查询<code>val</code>的过程如下：<br><img src="/media/15516311446785.jpg" alt=""></p>
<p><strong>treeIndex</strong>是一个<code>b-ree</code>，其存储这<code>keyIndex</code>信息。<code>KeyIndex</code>的结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">key         []<span class="keyword">byte</span></span><br><span class="line">modified    revision <span class="comment">// 最后一次更改版本信息</span></span><br><span class="line">generations []generation <span class="comment">// 代：每一代记录着键值对从创建到删除的过程</span></span><br><span class="line">|- ver     <span class="keyword">int64</span> <span class="comment">// 存放了多少次修改</span></span><br><span class="line">	created revision <span class="comment">// 创建此generation的第一个版本</span></span><br><span class="line">	revs    []revision</span><br></pre></td></tr></table></figure>
<p><code>keyIndex</code>中，需要特别说明的是<code>generation</code>数据内部，保存的<code>revs</code>，如果最后一项为<code>tombstone</code>，则表示在这个代中被删除了。被<code>tombstone</code>的<code>generation</code>是可以被删除的。针对此，<code>keyIndex</code>有个专门的函数<code>compact</code>，<code>compact(n)</code>可以将主版本小于n的数据。</p>
<p>将完了其存储结构和存储格式，下面将从启动和执行一次操作两个流程来讲解其的工作原理。对<code>boltDB</code>不了解的读者建议先去了解下 <a href="https://github.com/etcd-io/bbolt" target="_blank" rel="noopener"><code>boltDB</code></a>、<a href="https://segmentfault.com/a/1190000010098668" target="_blank" rel="noopener"><code>boltDB学习</code></a>。</p>
<h3 id="3-2-1-启动过程"><a href="#3-2-1-启动过程" class="headerlink" title="3.2.1 启动过程"></a>3.2.1 启动过程</h3><p><code>etcd</code>应用层存储创建过程如下：<br>首先创建<code>backend</code>，其是对<code>boltDB</code>的封装，加入一些批量提交逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bepath := cfg.backendPath()</span><br><span class="line">beExist := fileutil.Exist(bepath)</span><br><span class="line">be := openBackend(cfg) <span class="comment">// 创建</span></span><br><span class="line">|- newBackend</span><br><span class="line">    |- bolt.Open(bcfg.Path, <span class="number">0600</span>, bopts)</span><br><span class="line">    |- b := &amp;backend&#123;</span><br><span class="line">		db: db,</span><br><span class="line">		batchInterval: bcfg.BatchInterval,</span><br><span class="line">		batchLimit:    bcfg.BatchLimit ...</span><br><span class="line">		&#125;</span><br><span class="line">	 |- b.run() <span class="comment">// 定时任务，批量周期进行提交</span></span><br><span class="line">	   |- t := time.NewTimer(b.batchInterval)</span><br><span class="line">	   |- <span class="keyword">select</span> &#123;</span><br><span class="line">    		<span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">    			b.batchTx.CommitAndStop()</span><br><span class="line">    			<span class="keyword">return</span></span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">if</span> b.batchTx.safePending() != <span class="number">0</span> &#123;</span><br><span class="line">    			b.batchTx.Commit()</span><br><span class="line">    		&#125;</span><br></pre></td></tr></table></figure>
<p>有了<code>backend</code>后，会再基于此作一层封装：<code>mvcc.New(srv.getLogger(), srv.be, srv.lessor, &amp;srv.consistIndex)</code>，其内部包含<code>watcher</code>处理机制：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mvcc.New</span><br><span class="line">|- s := &amp;watchableStore&#123;</span><br><span class="line">    store:    NewStore(lg, b, le, ig),</span><br><span class="line">    victimc:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>),</span><br><span class="line">    unsynced: newWatcherGroup(),</span><br><span class="line">    synced:   newWatcherGroup(),</span><br><span class="line">    &#125;</span><br><span class="line">|- s.store.ReadView = &amp;readView&#123;s&#125;</span><br><span class="line">	s.store.WriteView = &amp;writeView&#123;s&#125;</span><br><span class="line">	<span class="keyword">if</span> s.le != <span class="literal">nil</span> &#123;</span><br><span class="line">		s.le.SetRangeDeleter(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">lease</span>.<span class="title">TxnDelete</span></span> &#123; <span class="keyword">return</span> s.Write() &#125;)</span><br><span class="line">	&#125;    </span><br><span class="line">|- <span class="keyword">go</span> s.syncWatchersLoop() <span class="comment">// 用于watch机制的异步任务</span></span><br><span class="line">|- <span class="keyword">go</span> s.syncVictimsLoop()</span><br></pre></td></tr></table></figure>
<p>这里我们比较关注的是<code>NewStore</code>逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">mvcc.NewStore</span><br><span class="line">|- s := &amp;store&#123;</span><br><span class="line">		b:       b,</span><br><span class="line">		kvindex: newTreeIndex(lg), <span class="comment">// 创建 treeIndex</span></span><br><span class="line">		le: le,</span><br><span class="line">		currentRev:     <span class="number">1</span>, <span class="comment">// 最近一次事务的版次</span></span><br><span class="line">		compactMainRev: <span class="number">-1</span>,<span class="comment">//最近一次事务的主版次</span></span><br><span class="line">		bytesBuf8: <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">8</span>),</span><br><span class="line">		fifoSched: schedule.NewFIFOScheduler(),</span><br><span class="line">		stopc: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">	&#125;</span><br><span class="line">|- s.ReadView = &amp;readView&#123;s&#125;</span><br><span class="line">	s.WriteView = &amp;writeView&#123;s&#125;</span><br><span class="line">	<span class="keyword">if</span> s.le != <span class="literal">nil</span> &#123;</span><br><span class="line">		s.le.SetRangeDeleter(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">lease</span>.<span class="title">TxnDelete</span></span> &#123; <span class="keyword">return</span> s.Write() &#125;)</span><br><span class="line">	&#125;</span><br><span class="line">|- tx.UnsafeCreateBucket(keyBucketName) <span class="comment">// 创建bucket-"key"用来存储kv数据，</span></span><br><span class="line">|- tx.UnsafeCreateBucket(metaBucketName) <span class="comment">//创建Bucket-”meta“用来存储元数据</span></span><br><span class="line">|- s.restore() <span class="comment">// 恢复存储</span></span><br><span class="line"><span class="comment">// TreeIndex 是b树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTreeIndex</span><span class="params">(lg *zap.Logger)</span> <span class="title">index</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;treeIndex&#123;</span><br><span class="line">		tree: btree.New(<span class="number">32</span>),</span><br><span class="line">		lg:   lg,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">s.restore</span><br><span class="line">|- rkvc, revc := restoreIntoIndex(s.lg, s.kvindex)<span class="comment">// 构建tree-index方法，返回两个通道，用于向内传入数据</span></span><br><span class="line">|- <span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 分页提取key-val</span></span><br><span class="line">		keys, vals := tx.UnsafeRange(keyBucketName, min, max, <span class="keyword">int64</span>(restoreChunkKeys))</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(keys) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将key-val进行解码，然后传递给`rkvc`通道，在restoreIntoIndex中监听`rkvc`通道，进行构建`treeIndex`</span></span><br><span class="line">		restoreChunk(s.lg, rkvc, keys, vals, keyToLease)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(keys) &lt; restoreChunkKeys &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		newMin := bytesToRev(keys[<span class="built_in">len</span>(keys)<span class="number">-1</span>][:revBytesLen])</span><br><span class="line">		newMin.sub++</span><br><span class="line">		revToBytes(newMin, min)</span><br><span class="line">	&#125;</span><br><span class="line">|- ...</span><br></pre></td></tr></table></figure>
<p>由此就完成了<code>treeIndex</code>和<code>boltDB</code>的初始化。<br>最后，<code>etcd</code>又对<code>mvcc.watchableStore</code>进行了一次封装<code>srv.newApplierV3Backend()</code>，其用于衔接存储和<code>raft</code>消息请求。</p>
<h3 id="3-2-2-请求应用到存储"><a href="#3-2-2-请求应用到存储" class="headerlink" title="3.2.2 请求应用到存储"></a>3.2.2 请求应用到存储</h3><p><code>put ty dj</code>请求通过<code>raft</code>协议提交决策后，最终会调用到<code>applierV3backend.put</code>方法进行应用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">applierV3backend.put</span><br><span class="line">|- txn = a.s.KV().Write()</span><br><span class="line">|- txn.Put(p.Key, val, leaseID)</span><br><span class="line">    |- storeTxnWrite.put</span><br><span class="line">        |- rev := tw.beginRev + <span class="number">1</span></span><br><span class="line">        	c := rev</span><br><span class="line">        	|- _, created, ver, err := tw.s.kvindex.Get(key, rev) <span class="comment">// 如果key存在则获取</span></span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        		c = created.main</span><br><span class="line">        		oldLease = tw.s.le.GetLease(lease.LeaseItem&#123;Key: <span class="keyword">string</span>(key)&#125;)</span><br><span class="line">        	&#125;</span><br><span class="line">        	|- ibytes := newRevBytes()</span><br><span class="line">            |- idxRev := revision&#123;main: rev, sub: <span class="keyword">int64</span>(<span class="built_in">len</span>(tw.changes))&#125;</span><br><span class="line">            |- revToBytes(idxRev, ibytes)</span><br><span class="line">            |- ver = ver + <span class="number">1</span></span><br><span class="line">            |- kv := mvccpb.KeyValue&#123;</span><br><span class="line">            		Key:            key,</span><br><span class="line">            		Value:          value,</span><br><span class="line">            		CreateRevision: c,</span><br><span class="line">            		ModRevision:    rev,</span><br><span class="line">            		Version:        ver,</span><br><span class="line">            		Lease:          <span class="keyword">int64</span>(leaseID),</span><br><span class="line">            	&#125;</span><br><span class="line">            |- d, err := kv.Marshal()</span><br><span class="line">            |- 	tw.tx.UnsafeSeqPut(keyBucketName, ibytes, d) <span class="comment">// 存储到boltDB中，key为`revision`</span></span><br><span class="line">            |- tw.s.kvindex.Put(key, idxRev) <span class="comment">// 将key到 revision的映射存储到treeIndex中</span></span><br></pre></td></tr></table></figure>
<p>到此就完成了存储模块的讲解。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2019/11/20/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/etcd/2.etcd-%E5%88%9D%E5%A7%8B%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.png">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/20/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/etcd/2.etcd-%E5%88%9D%E5%A7%8B%E5%8C%96/" class="post-title-link" itemprop="url">ETCD初始化</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-20 00:00:00" itemprop="dateCreated datePublished" datetime="2019-11-20T00:00:00+08:00">2019-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-25 12:24:51" itemprop="dateModified" datetime="2020-02-25T12:24:51+08:00">2020-02-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/etcd/" itemprop="url" rel="index">
                    <span itemprop="name">etcd</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-Etcd初始化流程解析"><a href="#1-Etcd初始化流程解析" class="headerlink" title="1. Etcd初始化流程解析"></a>1. Etcd初始化流程解析</h1><p><code>Etcd</code>的启动类为 父目录的<code>main.go</code>文件。其启动过程调用如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main.<span class="keyword">go</span></span><br><span class="line">|- etcdmain/main.<span class="keyword">go</span>(暂且忽略<span class="string">`gateway`</span>和<span class="string">`proxy`</span>模式启动)</span><br><span class="line">    |- checkSupportArch <span class="comment">// 检查是否是支持的处理器架构</span></span><br><span class="line">    |- startEtcdOrProxyV2 <span class="comment">// 解析参数并根据参数决定启动etcd节点还是按Proxy模式启动（这里按etcd节点形式启动）</span></span><br><span class="line">        |- 生成默认参数<span class="string">`newConfig()`</span>解析参数 <span class="string">`cfg.parse(os.Args[1:])`</span>解析命令行启动参数</span><br><span class="line">        |- startEtcd(&amp;cfg.ec)<span class="comment">// 启动过程最核心的地方</span></span><br></pre></td></tr></table></figure>
<p><code>startEtcd</code>中执行<code>etcd</code>启动的主要过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">embed.startEtcd(inCfg *Config)</span><br><span class="line">|- inCfg.Validate() <span class="comment">//校验配置，检查url是否是以ip地址开头的，否则报错终止流程</span></span><br><span class="line">|- configurePeerListeners(cfg) <span class="comment">// 根据配置初始化peerListener结构体（为`peer`服务的服务器配置）</span></span><br><span class="line">|- configureClientListeners(cfg) <span class="comment">// 根据配置初始化clientListener结构体，（为`client`服务的服务器配置）</span></span><br><span class="line">|- 通过判断是否有 <span class="string">`wal`</span>文件来判断是否已经有其他节点信息</span><br><span class="line">    |- cfg.PeerURLsMapAndToken(<span class="string">"etcd"</span>)方法，其用于解析出其他节点的信息。</span><br><span class="line">    |- etcd集群模式有三种启动方式，其具体实现即实现在其内部。（<span class="string">`后续我们将详细分析`</span>）</span><br><span class="line">|- etcdserver.NewServer(srvcfg) <span class="comment">// 执行etcdServer初始化</span></span><br><span class="line">|- e.Server.Start() <span class="comment">// 启动 etcdServer</span></span><br><span class="line">|- e.servePeers() <span class="comment">// 启动 监听etcd节点间请求的GRPC服务</span></span><br><span class="line">|- e.serveClients() <span class="comment">// 启动监听客户端请求的GRPC服务</span></span><br><span class="line">|- e.serveMetrics() <span class="comment">// 启动Metrics Http服务，供外部查询Metrics信息</span></span><br></pre></td></tr></table></figure>
<p>通过 <strong>cfg.PeerURLsMapAndToken(“etcd”)</strong> 逻辑，了解到<code>etcd</code>有三种方式来获取集群中其他节点信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> cfg.Durl != <span class="string">""</span>:<span class="comment">// etcd自发现模式：配置 “discovery”参数设置。这里没有真正获取集群所有节点。比较trick的作用，等后面来处理。</span></span><br><span class="line">	<span class="keyword">case</span> cfg.DNSCluster != <span class="string">""</span>:<span class="comment">// 通过DNS自发现模式，配置”discovery-srv“</span></span><br><span class="line">  <span class="keyword">default</span>:<span class="comment">// 默认的静态配置方式，通过参数 "initial-cluster"进行设置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>准备好创建<code>etcd</code>节点后开始初始化节点信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">etcdserver/NewServer(srvcfg)</span><br><span class="line">|- fileutil.TouchDirAll(cfg.DataDir) <span class="comment">//检查是否可以获取目录权限：DataDir:"集群名.etcd"</span></span><br><span class="line">|- fileutil.TouchDirAll(cfg.SnapDir()) <span class="comment">// 检查是佛偶可以获取快照目录权限 ”集群名.etcd/member/snap“</span></span><br><span class="line">|- snap.New(cfg.Logger, cfg.SnapDir()) <span class="comment">//创建快照管理器</span></span><br><span class="line">|- be := openBackend(cfg) <span class="comment">// 创建数据库后端，其底层使用boltDB存储数据，然后在其之上进行了一次封装：包括批量提交事务。（关于存储的内容，我们后面讲单独讲解）</span></span><br><span class="line">|- rafthttp.NewRoundTripper(cfg.PeerTLSInfo, cfg.peerDialTimeout()) <span class="comment">// 创建一个RoundTripper，其作用是封装一个具有执行一次http事务，为一个http request获取response的对象</span></span><br></pre></td></tr></table></figure>
<p>初始化快照管理器和数据库后端后，就会根据一系列条件来决定怎样启动节点：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> !haveWAL &amp;&amp; !cfg.NewCluster:<span class="comment">// 非新集群且也没有WAL文件</span></span><br><span class="line">	<span class="comment">// 首先进行一些校验工作：比如判断本地集群成员列表是否与远程其他节点的成本列表配置是否相同</span></span><br><span class="line">	<span class="comment">// 判断集群每个节点的版本是否兼容</span></span><br><span class="line">	id, n, s, w = startNode(cfg, cl, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">case</span> !haveWAL &amp;&amp; cfg.NewCluster: <span class="comment">// 新集群，且没有WAL文件</span></span><br><span class="line">	<span class="comment">// 此处就是接着 PeerURLsMapAndToken的处理，如果配置`Discovery`参数，etcd则进行自发现流程 `v2discovery.JoinCluster`</span></span><br><span class="line">	id, n, s, w = startNode(cfg, cl, cl.MemberIDs())</span><br><span class="line">	<span class="keyword">case</span> haveWAL:                  <span class="comment">// 非新集群，且有WAL文件</span></span><br><span class="line">	<span class="comment">// 首先读取快照文件</span></span><br><span class="line">	<span class="comment">// 从快照文件中恢复数据库后端</span></span><br><span class="line">	snapshot, err = ss.Load()</span><br><span class="line">	<span class="comment">// 调用restartNode方法重启节点</span></span><br><span class="line">	id, cl, n, s, w = restartNode(cfg, snapshot)</span><br><span class="line">	<span class="comment">// 其再从wal内进一步恢复内容</span></span><br><span class="line">	<span class="keyword">default</span>:   <span class="comment">//异常情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建完<code>raft.Node</code>并绑定相应<strong>raft</strong>后，继续初始化:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">|- stats.NewServerStats <span class="comment">// 初始化统计计数</span></span><br><span class="line">|- stats.NewLeaderStats</span><br><span class="line">|- heartbeat := time.Duration(cfg.TickMs) * time.Millisecond <span class="comment">// 初始化心跳参数</span></span><br><span class="line">|- 创建 <span class="string">`EtcdServer`</span>：同时创建 <span class="string">`RaftNode`</span>、初始化ID生成器</span><br><span class="line">    |- newRaftNode  </span><br><span class="line">|- lease.NewLessor <span class="comment">//创建或恢复租约管理器</span></span><br><span class="line">|- srv.kv = mvcc.New(srv.getLogger(), srv.be, srv.lessor, &amp;srv.consistIndex) <span class="comment">// 创建KV存储器，其封装了backend、TreeIndex、Lessor，另外其内部也运行着 Watch 机制。（后续独立章节详细解析）</span></span><br><span class="line">|- srv.applyV3Base = srv.newApplierV3Backend() <span class="comment">// 创建 ApplierV3 接口实现，其用于处理v3 raft消息，为应用层的操作。</span></span><br><span class="line">|- restoreAlarms <span class="comment">// 恢复报警，如要是节点存储的报警：如空间不足、崩溃时替换`applyV3`做配置限制或拒绝请求</span></span><br><span class="line">|- tr := &amp;rafthttp.Transport&#123;...&#125; <span class="comment">// 创建Transporter，其用于向其他节点发送raft消息，并从其他节点获取raft消息。</span></span><br><span class="line">|- 每个remotes执行：tr.AddRemote(m.ID, m.PeerURLs) <span class="comment">// 初始化与每个Learner的通信</span></span><br><span class="line">|- 每个Members执行：tr.AddPeer(m.ID, m.PeerURLs) <span class="comment">// 初始化与每个Member节点的通信</span></span><br></pre></td></tr></table></figure>
<p>下面来看<code>raftNode</code>的详细创建过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">newRaftNode(</span><br><span class="line">	raftNodeConfig&#123;</span><br><span class="line">		Node:        n,</span><br><span class="line">		heartbeat:   heartbeat,</span><br><span class="line">		raftStorage: s,</span><br><span class="line">		storage:     NewStorage(w, ss),</span><br><span class="line">	&#125;,</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newRaftNode</span><span class="params">(cfg raftNodeConfig)</span> *<span class="title">raftNode</span></span> &#123;</span><br><span class="line">	r := &amp;raftNode&#123;</span><br><span class="line">		lg:             cfg.lg,</span><br><span class="line">		tickMu:         <span class="built_in">new</span>(sync.Mutex),</span><br><span class="line">		raftNodeConfig: cfg,</span><br><span class="line">		td:         contention.NewTimeoutDetector(<span class="number">2</span> * cfg.heartbeat),</span><br><span class="line">		readStateC: <span class="built_in">make</span>(<span class="keyword">chan</span> raft.ReadState, <span class="number">1</span>),</span><br><span class="line">		msgSnapC:   <span class="built_in">make</span>(<span class="keyword">chan</span> raftpb.Message, maxInFlightMsgSnap),</span><br><span class="line">		applyc:     <span class="built_in">make</span>(<span class="keyword">chan</span> apply),</span><br><span class="line">		stopped:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		done:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 开始心跳 Ticker</span></span><br><span class="line">	r.ticker = time.NewTicker(r.heartbeat)</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出<code>raftNode</code>和<code>raft.node</code>之间的关系。通过<code>raftNode</code>可以直接访问<code>raft.node</code>的所有公有方法。</p>
<p>回到 <code>startNode</code> 方法，我们以新集群且没有<code>WAL</code>文件的场景来了解下<code>startNode</code>的处理过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">etcdserver/raft.<span class="keyword">go</span>/startNode</span><br><span class="line">|- wal.Create() <span class="comment">// 创建 WAL文件</span></span><br><span class="line">|- raft.NewMemoryStorage()  <span class="comment">// 创建raft的数据存储器，这里为内存储存</span></span><br><span class="line">|- n = raft/node.<span class="keyword">go</span>/StartNode(c, peers) <span class="comment">// 开始节点</span></span><br><span class="line">    |- r := newRaft(c) <span class="comment">// 为当前节点创建raft对象</span></span><br><span class="line">    |- r.becomeFollower(<span class="number">1</span>, None) <span class="comment">//初始化当前节点成为 follower角色</span></span><br><span class="line">    |- 对每个节点，追加一条<span class="string">`ConfChangeAddNode`</span>配置更改记录到 raftLog中</span><br><span class="line">    |- r.raftLog.committed = r.raftLog.lastIndex() <span class="comment">// 更新raftLog的提交索引</span></span><br><span class="line">    |-  <span class="keyword">for</span> each peer r.addNode(peer.ID) <span class="comment">//为每个peer在Raft中创建一个Progress结构体（没有创建时，若创建了则设置状态）来，来保存该peer的数据复制状态</span></span><br><span class="line">    |- 创建一个raft/node节点 <span class="comment">// 创建node结构体，初始化各种通道</span></span><br><span class="line">    |- 异步执行 node.run(r *raft)方法<span class="comment">// 其内部主要执行事项包括：轮训raft内需要周知其他节点的信息进行发送，监听node的各种通道（请求和响应）作相应处理，和任务超时通知通道</span></span><br></pre></td></tr></table></figure>
<p>下面我们来详细了解下<strong>newRaft</strong>的内容：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">newRaft(c *Config) *raft</span><br><span class="line">|- c.validate() <span class="comment">// 相关参数的校验，比如选举超时时间设置必须大于心跳超时时间设置</span></span><br><span class="line">|- raftlog := newLogWithSize(c.Storage, c.Logger, c.MaxCommittedSizePerReady) <span class="comment">// 创建raftLog结构体，其用于保存raft状态机信息，比如当前节点事务提交的最大log位置、已经应用到应用的最大索引位置、所有未提交不稳定的记录</span></span><br><span class="line">|- <span class="string">`创建raft结构体`</span></span><br><span class="line">|- 对于每个决策节点 <span class="string">`peers`</span>，设置复制初始<span class="string">`Next`</span>位置、复制滑动串口器</span><br><span class="line">|- 对于非决策节点 <span class="string">`learnerPrs`</span>，也进行初始化</span><br><span class="line">|- r.becomeFollower(r.Term, None) <span class="comment">// 将自身设置为 Follower角色，对于一个刚启动的节点，这里Term为0</span></span><br><span class="line">|-</span><br></pre></td></tr></table></figure>
<p>接下来，再来看 <code>becomeFollower</code> 方法，其设置了 <strong>step</strong> 方法和 <strong>tick</strong> 方法、设置了 <code>raft</code>所在任期以及<code>raft</code>的角色状态。我们都知道<code>raft</code>协议中共有三个角色<code>Follower</code>、<code>Candidates</code>、<code>Leader</code>。<code>etcd</code>中通过不同角色设置不同的<code>step</code>来区分开每个角色的处理逻辑，设置不同<code>tick</code>方法来设置超时任务（对于<code>Follower</code>角色，其超时后会发起新一轮选举，而对于<code>Leader</code>角色，则广播一次心跳消息… ）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *raft)</span> <span class="title">becomeFollower</span><span class="params">(term <span class="keyword">uint64</span>, lead <span class="keyword">uint64</span>)</span></span> &#123;</span><br><span class="line">	r.step = stepFollower</span><br><span class="line">	r.reset(term)</span><br><span class="line">	r.tick = r.tickElection</span><br><span class="line">	r.lead = lead</span><br><span class="line">	r.state = StateFollower</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *raft)</span> <span class="title">becomeCandidate</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r.step = stepCandidate</span><br><span class="line">	r.reset(r.Term + <span class="number">1</span>)</span><br><span class="line">	r.tick = r.tickElection</span><br><span class="line">	r.Vote = r.id</span><br><span class="line">	r.state = StateCandidate</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *raft)</span> <span class="title">becomeLeader</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r.step = stepLeader</span><br><span class="line">	r.reset(r.Term)</span><br><span class="line">	r.tick = r.tickHeartbeat</span><br><span class="line">	r.lead = r.id</span><br><span class="line">	r.state = StateLeader</span><br><span class="line">	r.prs[r.id].becomeReplicate()</span><br><span class="line">	r.pendingConfIndex = r.raftLog.lastIndex()</span><br><span class="line">	emptyEnt := pb.Entry&#123;Data: <span class="literal">nil</span>&#125;</span><br><span class="line">	r.reduceUncommittedSize([]pb.Entry&#123;emptyEnt&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，就完成了 <strong>EtcdServer</strong>的创建。</p>
<p>接下来，再来看<code>EtcdServer</code>的开始方法<code>Start</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EtcdServer/Start</span><br><span class="line">    s.start() <span class="comment">// 启动</span></span><br><span class="line">	s.goAttach(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; s.adjustTicks() &#125;) <span class="comment">// 调整频率，启动时加快选举</span></span><br><span class="line">	s.goAttach(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; s.publish(s.Cfg.ReqTimeout()) &#125;) <span class="comment">// 发布节点属性信息，以遍其他节点可查询</span></span><br><span class="line">	s.goAttach(s.purgeFile) <span class="comment">// 启动异步任务做文件的合并操作：db文件\snap文件\WAL文件</span></span><br><span class="line">	s.goAttach(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; monitorFileDescriptor(s.getLogger(), s.stopping) &#125;) <span class="comment">// 监控文件句柄数不能超过系统限制的80%</span></span><br><span class="line">	s.goAttach(s.monitorVersions)</span><br><span class="line">	s.goAttach(s.linearizableReadLoop) <span class="comment">// 线性一致性读异步任务（后续详细讲解）</span></span><br><span class="line">	s.goAttach(s.monitorKVHash)</span><br></pre></td></tr></table></figure>
<p><code>EtcdServer.start()</code>方法，首先进行一系列通道的初始化，然后异步执行<code>EtcdServer.run()</code>方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EtcdServer.run</span><br><span class="line">|- sched := schedule.NewFIFOScheduler() <span class="comment">//首先创建一个先进先出的异步调度器</span></span><br><span class="line">|- rh := &amp;raftReadyHandler&#123;...&#125; <span class="comment">// 创建一个raftReadHanlder用于处理一些节点信息操作的回调。</span></span><br><span class="line">|- s.raftNode.start(rh) <span class="comment">// 启动raftNode的异步处理流程</span></span><br><span class="line">|- 开启循环，监听 raftNode的 applyC通道 以及租约过期通道 <span class="string">`s.lessor.expiredC`</span>。</span><br><span class="line">    |- 对于 <span class="string">`applyC`</span>，当从其中获取消息时，通过先进先出异步调度器顺序执行 applyAll方法</span><br><span class="line">    |- 对于</span><br></pre></td></tr></table></figure>
<p>展开 <code>raftNode.start(rh)</code>的逻辑如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-r.ticker.C: <span class="comment">// 监听超时通知通道</span></span><br><span class="line">		r.tick()</span><br><span class="line">	<span class="keyword">case</span> rd := &lt;-r.Ready(): <span class="comment">// 监听 raft.node的readyC通道，其为需要发送给其他节点或广播的消息</span></span><br><span class="line">	<span class="comment">// 根据消息更新自身状态</span></span><br><span class="line">	<span class="comment">// 然后应用到状态机中，最后发送给其他节点（非主节点时）或广播给其他节点（主节点）</span></span><br><span class="line">		<span class="keyword">if</span> rd.SoftState != <span class="literal">nil</span> &#123;</span><br><span class="line">		  <span class="comment">// 判断是否需要更新主节点信息</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(rd.ReadStates) != <span class="number">0</span> &#123;</span><br><span class="line">		  <span class="comment">// 对于线性一致性读，进行通知回调</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		notifyc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">      <span class="comment">// 通过rh来更新提交索引号</span></span><br><span class="line">		updateCommittedIndex(&amp;ap, rh)</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> r.applyc &lt;- ap:</span><br><span class="line">		<span class="keyword">case</span> &lt;-r.stopped:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> islead &#123;</span><br><span class="line">			r.transport.Send(r.processMessages(rd.Messages))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := r.storage.Save(rd.HardState, rd.Entries); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		r.raftStorage.Append(rd.Entries)</span><br><span class="line">		<span class="keyword">if</span> !islead &#123;</span><br><span class="line">			msgs := r.processMessages(rd.Messages)</span><br><span class="line">	       <span class="comment">// ...</span></span><br><span class="line">			r.transport.Send(msgs)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			notifyc &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		r.Advance()</span><br><span class="line">	<span class="keyword">case</span> &lt;-r.stopped:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>完成<code>etcdServer</code>的启动后，开始<code>http/grpc</code>服务对外提供服务（<code>peer</code>间的服务以及对<code>client</code>开放的服务）。<br>我们以<code>servePeers()</code>来讲解启动服务过程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">servePeers()</span><br><span class="line">|- etcdhttp.NewPeerHandler <span class="comment">//创建 `http.Handler`，用于处理 节点间 以`raft`、`raft/`、`/leases`、`/leases/internal`为前缀的http请求</span></span><br><span class="line">|- 对于每个 <span class="string">`e.Peers`</span>：执行以下操作</span><br><span class="line">    |- gs := v3rpc.Server(e.Server, peerTLScfg) <span class="comment">// 创建grpcServer，然后注册服务描述信息，如kv、watch、lease、cluster、auth、maintenance。</span></span><br><span class="line">    |- m := cmux.New(p.Listener) <span class="comment">// 创建连接多路转接器，用于转发连接到不同的服务里去处理，其工作原理后续讲解</span></span><br><span class="line">    |- <span class="keyword">go</span> gs.Serve(m.Match(cmux.HTTP2())) <span class="comment">// 筛选出http2的链接，并对其服务</span></span><br><span class="line">    |- <span class="keyword">go</span> srv.Serve(m.Match(cmux.Any())) <span class="comment">//对于剩下的连接，用http服务进行处理</span></span><br><span class="line">|- 对每个 <span class="string">`e.Peers`</span>.serve() 启动监听服务</span><br></pre></td></tr></table></figure>
<p>当新连接到达时，处理流程如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cMux.Server()</span><br><span class="line">|- c, err := m.root.Accept() <span class="comment">// 通过最原始的方式获取到达的连接</span></span><br><span class="line">|- m.serve(c, m.donec, &amp;wg) <span class="comment">// 执行serve进行分发</span></span><br><span class="line">    |- <span class="keyword">for</span> _, sl := <span class="keyword">range</span> m.sls &#123;<span class="comment">// sl包装了 其自身的匹配器列表，和转发通道</span></span><br><span class="line">		<span class="keyword">for</span> _, s := <span class="keyword">range</span> sl.ss &#123;<span class="comment">// s为通过cMux.Match方法创建的匹配器</span></span><br><span class="line">			matched := s(muc.Conn, muc.startSniffing())</span><br><span class="line">			<span class="keyword">if</span> matched &#123; <span class="comment">// 若该连接匹配上了，则将该连接通过连接发送到sl的连接接收通道里</span></span><br><span class="line">				<span class="comment">//...</span></span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> sl.l.connc &lt;- muc:</span><br><span class="line">				<span class="keyword">case</span> &lt;-donec:</span><br><span class="line">					_ = c.Close()</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>到此整个初始化过程就完成了。其后开始进行选举，那么选举是哪里出发的呢？<br>回到创建<code>raftNode</code>的地方 <code>r.ticker = time.NewTicker(r.heartbeat)</code> 开启了ticker。当时间到达时，tickder.C中得到通知。而其正在被 <code>raftNode</code>的<code>start</code>方法中的循环监听着。进一步就触发了<code>raftNoe.tick()</code>方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">raftNoe.tick()</span><br><span class="line">|- node.Tick()方法， 之前介绍过 raftNode与node之间的关系</span><br><span class="line">    |- n.tickc &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; 通知 node.tickc通道</span><br><span class="line">    |- node的run循环中监听此通道，进一步调用 <span class="string">`raft.tick()`</span>方法。此方法在 <span class="string">`becomeFollower`</span>时设置成了 <span class="string">`tickElection`</span></span><br><span class="line">    |- r.Step(pb.Message&#123;From: r.id, Type: pb.MsgHup&#125;) <span class="comment">// 到此开始发起选举</span></span><br><span class="line">    |- r.campaign(campaignElection) <span class="comment">// 开始角逐 主节点角色</span></span><br><span class="line">        |- r.becomeCandidate <span class="comment">// 更改节点角色为 候选者</span></span><br><span class="line">            |- r.step = stepCandidate...</span><br><span class="line">        |- r.send(pb.Message&#123;Term: term, To: id, Type: voteMsg, Index: rL.lastIndex, LogTerm: r.raftLog.lastTerm(), Context: ctx&#125;) <span class="comment">// 对每个节点发送 `pb.MsgVote` 消息 携带本节点的任期，索引</span></span><br></pre></td></tr></table></figure>
<p>当其他接收到该节点的投票请求时：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">peer.<span class="keyword">go</span>/startPeer(<span class="number">180</span>L)</span><br><span class="line">|- etcdServer.Pocess <span class="comment">// 转发到ectdServer进行处理</span></span><br><span class="line">    |- node.Step <span class="comment">// 调用 raftNode，并间接调用 raft.node</span></span><br><span class="line">        |- node.stepWithWaitOption</span><br><span class="line">            |- raft.Step</span><br><span class="line">                |- 首先进行判断是否可投票（是否已经投给了这个需要投票的人|| 没投票，且没有主|| 消息的任期比本节点大）</span><br><span class="line">                |- 判断是否要投票给请求投票的节点（请求节点任期比本节点大，或者任期相等时索引Id是否比本节点大）</span><br><span class="line">                |- 上面条件都满足时，返回<span class="string">`MsgVoteResp`</span>消息，告诉请求者，其同意投票给它</span><br><span class="line">                |- 但上述条件不满足时，则返回 拒绝消息给请求者</span><br></pre></td></tr></table></figure>

<p>当节点收到 其他的投票反馈消息时，最终会调用 <code>raft.go/stepCandidate</code>方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// poll方法传进去本消息的投票，返回已经有多少赞成票</span></span><br><span class="line">gr := r.poll(m.From, m.Type, !m.Reject)</span><br><span class="line"><span class="keyword">switch</span> r.quorum() &#123;<span class="comment">// 当达到quorum个时，进行角色转变</span></span><br><span class="line"><span class="keyword">case</span> gr:</span><br><span class="line">	<span class="keyword">if</span> r.state == StatePreCandidate &#123;</span><br><span class="line">		r.campaign(campaignElection)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	   <span class="comment">// 转换为主节点</span></span><br><span class="line">		r.becomeLeader()</span><br><span class="line">		<span class="comment">// 广播消息</span></span><br><span class="line">		r.bcastAppend()</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="built_in">len</span>(r.votes) - gr:</span><br><span class="line">	r.becomeFollower(r.Term, None)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的逻辑，可以看出，当投票数达到quorum数时，转变角色为主节点。同时向所有其他节点广播本节点状态以及记录信息（MsgApp），其他节点接收到此消息后，自动转变为 follower角色，整个集群初始化完成。</p>
<p>对于<code>etcd</code>的选举，还需要说明的是，<code>etcd</code>为了某些网络分区的问题了设置<code>PreVote</code>流程（只需要启动节点的时候 设置 <code>pre-vote</code> 参数）。即在进行真正的选举之前 先进行<code>PreVote</code>得到大多数节点同意选举之后才进行真正的选举。可以解决如下问题：</p>
<ul>
<li>对于网络分区的节点，在重新加入集群的时候不会中断集群；（因为获取不了大部分节点的许可，索引其<code>Term</code>无法增大，所以赢不了选举主节点）。</li>
</ul>
<p>到此，<strong>etcd</strong>的启动到建立集群、完成选举的整个过程就介绍完了。</p>
<p>附加图：<br>下图为 <code>EtcdServer</code>、<code>raftNode</code>、<code>raft.node</code>、<code>raft</code>间的联系。<br><img src="/media/15512352647387.jpg" alt=""></p>
<p>最后补充说明下<code>etcd</code>的<code>proxy</code>模式：<br><code>etcd</code>可以通过命令<code>./etcd –proxy on  –listen-client-urls</code>的形式启动代理模式。代理模式下，它的作用是一个反向代理，接收客户端请求，然后转发到<code>etcd</code>集群。<br>代理模式有2种运行形式：<code>readwrite</code>和<code>readonly</code>，默认情况下为<code>readwrite</code>，即会将读写请求都进行转发，而<code>readonly</code>形式下，则只转发读请求，写请求将报<code>5xx</code>错误，</p>
<p><strong>IDEA</strong>中启动ETCD方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">debug方式运行三个终端程序 <span class="string">`etcd/main.go`</span> 并设置如下参数：</span><br><span class="line">--name infra1 --listen-client-urls http:<span class="comment">//127.0.0.1:2379 --advertise-client-urls http://127.0.0.1:2379 --listen-peer-urls http://127.0.0.1:12380 --initial-advertise-peer-urls http://127.0.0.1:12380 --initial-cluster-token etcd-cluster-1 --initial-cluster infra1=http://127.0.0.1:12380,infra2=http://127.0.0.1:22380,infra3=http://127.0.0.1:32380 --initial-cluster-state new --enable-pprof --logger=zap --log-outputs=stderr</span></span><br><span class="line">--name infra2 --listen-client-urls http:<span class="comment">//127.0.0.1:22379 --advertise-client-urls http://127.0.0.1:22379 --listen-peer-urls http://127.0.0.1:22380 --initial-advertise-peer-urls http://127.0.0.1:22380 --initial-cluster-token etcd-cluster-1 --initial-cluster infra1=http://127.0.0.1:12380,infra2=http://127.0.0.1:22380,infra3=http://127.0.0.1:32380 --initial-cluster-state new --enable-pprof --logger=zap --log-outputs=stderr</span></span><br><span class="line">--name infra3 --listen-client-urls http:<span class="comment">//127.0.0.1:32379 --advertise-client-urls http://127.0.0.1:32379 --listen-peer-urls http://127.0.0.1:32380 --initial-advertise-peer-urls http://127.0.0.1:32380 --initial-cluster-token etcd-cluster-1 --initial-cluster infra1=http://127.0.0.1:12380,infra2=http://127.0.0.1:22380,infra3=http://127.0.0.1:32380 --initial-cluster-state new --enable-pprof --logger=zap --log-outputs=stderr</span></span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2019/11/19/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/etcd/1.etcd-%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.png">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/19/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/etcd/1.etcd-%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">ETCD简介</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-19 00:00:00" itemprop="dateCreated datePublished" datetime="2019-11-19T00:00:00+08:00">2019-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-13 19:56:00" itemprop="dateModified" datetime="2020-02-13T19:56:00+08:00">2020-02-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/etcd/" itemprop="url" rel="index">
                    <span itemprop="name">etcd</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="0-ETCD简介"><a href="#0-ETCD简介" class="headerlink" title="0. ETCD简介"></a>0. ETCD简介</h1><p>本文将从以下几个方面来分析 ETCD （<code>v3.3.12</code>）。</p>
<ol start="0">
<li>整体架构</li>
<li>启动过程</li>
<li>数据存储</li>
<li>通信方式</li>
<li>TTL实现原理</li>
<li>Lease实现原理</li>
<li>单次事务过程</li>
<li>线性一致性读过程</li>
<li>Watch机制</li>
</ol>
<!--9. 运维相关：
    1. 主宕机
    2. 从宕机
    3. 添加新节点-->

<p>在介绍上面所有过程之前，我们先来介绍下 <strong>ETCD</strong>的整体架构以及相关名词术语。</p>
<!--[1.ETCD原理](https://www.cnblogs.com/panpanwelcome/p/8242418.html)-->


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- Node：一个Raft状态机节点；</span><br><span class="line">- Proxy：etcd的一种模式，为etcd集群提供反向代理服务；</span><br><span class="line">- Member： etcd集群中的一个节点。它可以与其他节点进行交互且为客户端提供服务；</span><br><span class="line">- Cluster：由多个Member组成的etcd集群；</span><br><span class="line">- Peer：对处在相同集群中其他节点的称呼；</span><br><span class="line">- Client： 请求客户端；</span><br><span class="line">- Candidate	候选人</span><br><span class="line">- Leader	领导者</span><br><span class="line">- Follower	跟随者</span><br><span class="line">- Term	选举任期，每次选举之后递增1</span><br><span class="line">- Index：索引号，Raft中通过Term和Index来定位数据。</span><br><span class="line">- Vote	选举投票(的ID)</span><br><span class="line">- Commit	提交</span><br><span class="line">- Propose	提议</span><br><span class="line">- WAL：预写式日志</span><br><span class="line">- SoftState：软状态，软状态易变且不需要保存在WAL日志中的状态数据，包括：集群leader、节点的当前状态</span><br><span class="line">- HardState：硬状态，与软状态相反，需要写入持久化存储中，包括：节点当前Term、Vote、Commit</span><br><span class="line">- ReadStates：用于读一致性的数据，后续会详细介绍</span><br><span class="line">- Entries：在向其他集群发送消息之前需要先写入持久化存储的日志数据</span><br><span class="line">- Snapshot：需要写入持久化存储中的快照数据</span><br><span class="line">- CommittedEntries：需要输入到状态机中的数据，这些数据之前已经被保存到持久化存储中了</span><br><span class="line">- Messages：在entries被写入持久化存储中以后，需要发送出去的数据</span><br></pre></td></tr></table></figure>
<p><code>peer</code>间通信消息类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- MsgHup            &#x2F;&#x2F; 不用于节点间通信，仅用于发送给本节点让本节点进行选举</span><br><span class="line">- MsgBeat           &#x2F;&#x2F; 心跳消息</span><br><span class="line">- MsgProp           &#x2F;&#x2F; raft库使用者提议（propose）数据</span><br><span class="line">- MsgApp            &#x2F;&#x2F; 用于leader向集群中其他节点同步数据的消息</span><br><span class="line">- MsgAppResp        &#x2F;&#x2F; 消息同步回复</span><br><span class="line">- MsgVote           &#x2F;&#x2F; 请求投票</span><br><span class="line">- MsgVoteResp       &#x2F;&#x2F; 投票反馈</span><br><span class="line">- MsgSnap           &#x2F;&#x2F; 用于leader向follower同步数据用的快照消息</span><br><span class="line">- MsgHeartbeat      &#x2F;&#x2F; 心跳消息</span><br><span class="line">- MsgHeartbeatResp  &#x2F;&#x2F; 心跳回复消息</span><br><span class="line">- MsgTransferLeader &#x2F;&#x2F; 转移主节点</span><br><span class="line">- MsgReadIndex      &#x2F;&#x2F; 用于线性一致性读</span><br><span class="line">- MsgReadIndexResp  </span><br><span class="line">- MsgPreVote        &#x2F;&#x2F; 请求预先投票</span><br><span class="line">- MsgPreVoteResp</span><br></pre></td></tr></table></figure>

<p><code>Etcd</code>整体架构图如下：<br><img src="/media/15518040419086.jpg" alt=""><br>下面将简单介绍下：</p>
<ol>
<li><code>etcd</code>面向<code>client</code>和<code>peer</code>节点开放<code>http</code>服务以及<code>grpc</code>服务，对于像<code>watch</code>机制就是基于<code>grpc</code>的<code>stream</code>通信模式实现的；</li>
<li><code>EtcdServer</code>是<code>etcd</code>上层结构体，其负责对外提供服务，且负责应用层的实现，比如操作应用层存储器，管理<code>leassor</code>、<code>watch</code>；</li>
<li><code>raftNode</code>负责上层与<code>raft</code>层的衔接。其负责将应用的需求传递到<code>raft</code>中进行处理（通过<code>Step</code>函数）、在消息发送到其他节点前将消息保存到<code>WAL</code>中、调用传输器发送消息；</li>
<li><code>raft</code>是<code>raft</code>协议的承载者；</li>
<li><code>raftLog</code>用于存储状态机信息：<code>memoryStorge</code>保存稳定的记录，<code>unstable</code>保存不稳定的记录。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2019/10/15/istio/3.istio-mcp&galley/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.png">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/15/istio/3.istio-mcp&galley/" class="post-title-link" itemprop="url">Istio MCP&Galley</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-15 00:00:00" itemprop="dateCreated datePublished" datetime="2019-10-15T00:00:00+08:00">2019-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-13 20:07:52" itemprop="dateModified" datetime="2020-02-13T20:07:52+08:00">2020-02-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/istio/" itemprop="url" rel="index">
                    <span itemprop="name">istio</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MCP协议-amp-Galley"><a href="#MCP协议-amp-Galley" class="headerlink" title="MCP协议&amp;Galley"></a>MCP协议&amp;Galley</h1><p>[TOC]</p>
<h2 id="MCP协议"><a href="#MCP协议" class="headerlink" title="MCP协议"></a>MCP协议</h2><ul>
<li><code>MCP</code>协议全称是 <code>Mesh Configuration Protocol</code>。</li>
<li>在<code>Istio</code>历史版本里，基于<code>k8s</code>来存储数据导致其与<code>k8s</code>耦合，限制了<code>Istio</code>的拓展性（非<code>k8s</code>机制则无法使用）。</li>
<li><code>MCP</code>协议的出现即是为了解决与<code>k8s</code>耦合的问题。<code>MCP</code>定义了一套配置订阅与下发的标准协议，<code>Pilot</code>和<code>Mixer</code> 作为<code>MCP client</code>，任何实现了<code>MCP</code>协议的Server(如<code>Galley</code>)通过 <code>MCP协议</code>向<code>Pilot</code>下发配置。</li>
</ul>
<p><code>MCP</code>中对配置生生产者和消费者进行了如下抽象：</p>
<ul>
<li><code>source</code>：配置源，即<code>Istio</code>的<code>Galley</code>(配置中心)，对应的是Grpc中定义的 <strong>Service:</strong> <code>ResourceSource</code>；</li>
<li><code>sink</code>：配置消费者，即<code>Istio</code>中的<code>Pilot</code>、<code>Mixer</code>，对应的Grpc中定义的<code>ResourceSink</code>；</li>
<li><code>resource</code>：配置资源的抽象定义。</li>
</ul>
<hr>
<ol>
<li>通常情况下，<code>source</code>作为Grpc的server，提供<code>ResourceSource</code>服务；<code>sink</code>作为Grpc的client，提供<code>ResourceSink</code>服务，<code>sink</code>主动向<code>source</code>发起连接，请求资源。当有资源更新时<code>source</code>将信息push给<code>sink</code>；</li>
<li>但<code>MCP</code>也支持一些特殊场景，<code>Source</code> 作为<strong>Client</strong> 向<code>Sink</code> <strong>Server</strong>建立新连接，然后<code>Sever</code>向<code>Client</code>发起资源请求（实际还是<code>Sink</code>请求<code>Source</code>，只是<code>Sink</code>作为Server，让<code>Source</code>连上来）。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">participant Sink(Pilot|Mixer) as sink</span><br><span class="line">participant Source(Galley) as source</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">note right of sink: stream established</span><br><span class="line">sink-&gt;source:conn:&#x3D; grpc.Dial</span><br><span class="line">sink-&gt;source: svc:&#x3D;mcp.NewResourceSourceService(conn)</span><br><span class="line">sink-&gt;source: stream:&#x3D;svc.EstablishResourceStream()</span><br><span class="line">sink-&gt;source: stream:&#x3D;stream.Send(RequestResources)</span><br><span class="line">source--&gt;sink: Resources:&#x3D; stream.Recv()</span><br><span class="line"></span><br><span class="line">note right of sink: request Resources</span><br><span class="line">sink-&gt;source: stream:&#x3D; RequestResources&#123;Collection&#x3D;VirtualService,nonce&#x3D;&#125;</span><br><span class="line">source--&gt;sink: Resources&#123;Collection&#x3D;VirtualService, nonce&#x3D;1, reources&#x3D;&#123;&#123;foo,v1&#125;,&#123;bar,v2&#125;&#125;&#125;</span><br><span class="line">sink-&gt;source: stream:&#x3D; RequestResources&#123;Collection&#x3D;VirtualService,nonce&#x3D;1&#125;(ACK)</span><br><span class="line"></span><br><span class="line">note right of sink: push Resources</span><br><span class="line">source--&gt;sink: Resources&#123;Collection&#x3D;VirtualService, nonce&#x3D;2, reources&#x3D;&#123;&#123;foo,v2&#125;,&#123;bar,v3&#125;&#125;&#125;</span><br><span class="line">sink-&gt;source: stream:&#x3D; RequestResources&#123;Collection&#x3D;VirtualService,nonce&#x3D;2&#125;(ACK)</span><br><span class="line"></span><br><span class="line">note right of sink: error Push</span><br><span class="line">source--&gt;sink: Resources&#123;Collection&#x3D;VirtualService, nonce&#x3D;3, reources&#x3D;&#123;&#123;foo,v3&#125;,&#123;bar,v4&#125;&#125;&#125;</span><br><span class="line">sink-&gt;source: stream:&#x3D; RequestResources&#123;Collection&#x3D;VirtualService,nonce&#x3D;3&#125;(NACK)</span><br></pre></td></tr></table></figure>

<p><code>MCP</code>中<code>Sink</code>与<code>Source</code>交互接口定义：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ResourceSource_EstablishResourceStreamClient <span class="keyword">interface</span> &#123;</span><br><span class="line">	Send(*RequestResources) error</span><br><span class="line">	Recv() (*Resources, error)</span><br><span class="line">	grpc.ClientStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Galley"><a href="#Galley" class="headerlink" title="Galley"></a>Galley</h2><p>前面介绍了 <code>MCP</code> 协议，接下来我们先介绍下<code>Galley</code>以及其工作原理，然后再以其与<code>Pilot</code>的交互流程讲解 <code>MCP</code> 的工作原理。</p>
<p><code>Galley</code> 主要负责两方面的功能：<strong>配置验证</strong>（校验配置的正确性）以及<strong>配置管理</strong>（<code>输入、转换、分发</code>）</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><code>Galley</code>启动入口位置：<code>galley/cmd/galley/main.go</code>。<br>首先，创建<code>server.Args</code>，通过参数初始化之后调用<code>server.New</code>创建<code>Galley</code><strong>Server</strong>。然后调用其<code>Start</code>方法开启<code>Galley</code>服务。</p>
<p>创建<code>Server</code>的处理过程如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(a *settings.Args)</span> *<span class="title">Server</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建存活探针</span></span><br><span class="line">	liveness := components.NewProbe(&amp;a.Liveness)</span><br><span class="line">	s.host.Add(liveness)</span><br><span class="line">	 <span class="comment">// 创建可读探针</span></span><br><span class="line">	readiness := components.NewProbe(&amp;a.Readiness)</span><br><span class="line">	s.host.Add(readiness)</span><br><span class="line">	<span class="comment">// 创建配置校验管理器</span></span><br><span class="line">	validation := components.NewValidation(a.KubeConfig, a.ValidationArgs, liveness.Controller(), readiness.Controller())</span><br><span class="line">	s.host.Add(validation)</span><br><span class="line">	<span class="comment">// 创建配置处理器</span></span><br><span class="line">	<span class="keyword">if</span> a.UseOldProcessor &#123;</span><br><span class="line">		s.p = components.NewProcessing(a)</span><br><span class="line">		s.host.Add(s.p)</span><br><span class="line">		t := s.p.ConfigZTopic()</span><br><span class="line">		topics = <span class="built_in">append</span>(topics, t)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		s.p2 = components.NewProcessing2(a)</span><br><span class="line">		s.host.Add(s.p2)</span><br><span class="line">		t := s.p2.ConfigZTopic()</span><br><span class="line">		topics = <span class="built_in">append</span>(topics, t)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建监控接口</span></span><br><span class="line">	mon := components.NewMonitoring(a.MonitoringPort)</span><br><span class="line">	s.host.Add(mon)</span><br><span class="line">	<span class="comment">// 与Pilot一样，ControlZ 运维接口</span></span><br><span class="line">	clz := components.NewCtrlz(a.IntrospectionOptions, topics...)</span><br><span class="line">	s.host.Add(clz)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Galley</code> 让所有组件都实现 <code>Component</code>接口，其定义了<code>Start</code>方法和<code>Stop</code>方法。<code>Server</code>创建所有组件后执行所有组件的<code>Start</code>方法，当<code>Server</code>要退出时执行<code>Stop</code>方法。</p>
<hr>
<h3 id="配置校验器"><a href="#配置校验器" class="headerlink" title="配置校验器"></a>配置校验器</h3><p><code>Istio</code> 中配置非常之多，而 <code>Istio</code> 配置数据的主要来源是 <code>k8s</code>。在 <code>k8s</code> 中创建各种类型的配置 <code>CRD</code> 资源，<code>Istio</code> 通过监听这种类型资源进行处理转换后下发给 <code>Envoy</code>。配置资源如果任意设置可能会导致意想不到的结果，而 <code>k8s</code> 提供了一种叫<code>Admission WebHooks</code>的拓展，用来支持对配置的验证工作。<br>工作原理如下：</p>
<ul>
<li>向<code>k8s</code>中注入用于准入的 <code>WebHookConfiguration</code>（配置校验服务器信息），在<code>k8s</code>中有配置输入时，会向配置的校验服务器发起准入请求；</li>
<li>校验服务器会拿到请求中的资源信息，根据其配置的规则进行校验，若不通过，则返回告诉<code>k8s</code>拒绝，并输入具体信息；否则返回成功。</li>
</ul>
<p><img src="/media/15776177806339.jpg" alt=""></p>
<h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">webhookServerReady := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> params.EnableValidation &#123;</span><br><span class="line">    <span class="comment">//创建与运行校验模块</span></span><br><span class="line">	<span class="keyword">go</span> validation.RunValidation(webhookServerReady, stopCh, params, kubeConfig, liveness, readiness)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> params.EnableReconcileWebhookConfiguration &#123;</span><br><span class="line">    <span class="comment">//创建ValidatingWebhookConfiguration，并向k8s注入此WebhookConfiguration</span></span><br><span class="line">	<span class="keyword">go</span> validation.ReconcileWebhookConfiguration(webhookServerReady, stopCh, params, kubeConfig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其过程分为两步：创建并运行校验模块，当校验模块就绪后向 <code>k8s</code> 注入<code>WebhookConfiguration</code>。<br>首先，先看校验模块的初始化过程：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RunValidation</span><span class="params">(ready <span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125;, stopCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, vc *WebhookParameters, kubeConfig <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	livenessProbeController, readinessProbeController probe.Controller)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建默认的Mixer的校验器</span></span><br><span class="line">	mixerValidator := mixervalidate.NewDefaultValidator(<span class="literal">false</span>)</span><br><span class="line">	<span class="comment">// 创建与k8s交互的客户端</span></span><br><span class="line">	clientset, err := kube.CreateClientset(kubeConfig, <span class="string">""</span>)</span><br><span class="line">	vc.MixerValidator = mixerValidator</span><br><span class="line">	<span class="comment">// 所有Istio的模型</span></span><br><span class="line">	vc.PilotDescriptor = schemas.Istio</span><br><span class="line">	vc.Clientset = clientset</span><br><span class="line">	<span class="comment">// 创建WebHook处理器，并对外输出http操作接口</span></span><br><span class="line">	wh, err := NewWebhook(*vc)</span><br><span class="line">	   |- wh := &amp;Webhook&#123;</span><br><span class="line">    		server: &amp;http.Server&#123;</span><br><span class="line">    			Addr: fmt.Sprintf(<span class="string">":%v"</span>, p.Port),</span><br><span class="line">    		&#125;,</span><br><span class="line">    		descriptor:                    p.PilotDescriptor,</span><br><span class="line">    		validator:                     p.MixerValidator,</span><br><span class="line">    		clientset:                     p.Clientset,</span><br><span class="line">	   |- h.HandleFunc(<span class="string">"/admitpilot"</span>, wh.serveAdmitPilot)</span><br><span class="line">	   |- h.HandleFunc(<span class="string">"/admitmixer"</span>, wh.serveAdmitMixer)</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">go</span> wh.Run(ready, stopCh)</span><br><span class="line">	   |- <span class="keyword">go</span> wh.server.ListenAndServeTLS(<span class="string">""</span>, <span class="string">""</span>) <span class="comment">// 监听端口</span></span><br><span class="line">	   |-	wh.waitForEndpointReady <span class="comment">// 等待资源初始化完成</span></span><br><span class="line">	       |- store, controller := cache.NewInformer(wh.createInformerEndpointSource(wh.clientset, wh.deploymentAndServiceNamespace, wh.serviceName)...</span><br><span class="line">	       |- <span class="comment">// 等待资源同步完成</span></span><br><span class="line">	       |- cache.WaitForCacheSync(stopCh, controller.HasSynced)</span><br><span class="line">	       |- <span class="comment">//检查节点是否准备就绪：</span></span><br><span class="line">	       |- ready := endpointReady(store, queue, wh.deploymentAndServiceNamespace, wh.serviceName)</span><br><span class="line">	   |-	ready &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">//发送信号标识可以向k8s注册此准入检测点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReconcileWebhookConfiguration</span><span class="params">(webhookServerReady, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">	vc *WebhookParameters, kubeConfig <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	clientset, err := kube.CreateClientset(kubeConfig, <span class="string">""</span>)</span><br><span class="line">	<span class="comment">// 创建 WebhookConfigController</span></span><br><span class="line">	whc, err := NewWebhookConfigController(*vc)</span><br><span class="line">	&lt;-webhookServerReady <span class="comment">// 等待检验模块就绪</span></span><br><span class="line">	whc.reconcile(stopCh)</span><br><span class="line">	   |- whc.rebuildWebhookConfig() <span class="comment">// 跟据配置构建Webhook配置</span></span><br><span class="line">	   |- whc.createOrUpdateWebhookConfig() <span class="comment">// 向`k8s`发起创建`webhook`</span></span><br></pre></td></tr></table></figure>
<p>总结其过程：首先创建默认的校验器，其次创建<code>WebHook</code>监听端口并添加指定路径的处理函数，最后通过查询<code>k8s</code>查询到节点可读时告知<code>WebhookController</code>向<code>k8s</code>注册<code>ValidatingWebhookConfiguration</code>。</p>
<h4 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h4><p>接下来，继续跟进具体的校验逻辑，对于<code>Pilot</code>配置逻辑校验入口<code>admitPilot</code>；而对于<code>Mixer</code>配置逻辑校验入口为<code>admitMixer</code>。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wh *Webhook)</span> <span class="title">admitPilot</span><span class="params">(request *AdmissionRequest)</span> *<span class="title">AdmissionResponse</span></span> &#123;</span><br><span class="line">    <span class="comment">// 只校验创建和修改操作</span></span><br><span class="line">    <span class="keyword">switch</span> request.Operation &#123;</span><br><span class="line">	<span class="keyword">case</span> admissionv1beta1.Create, admissionv1beta1.Update:</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> &amp;admissionv1beta1.AdmissionResponse&#123;Allowed: <span class="literal">true</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 解码，并判断是否是Istio关注的类型，若不是则返回无法识别的类型</span></span><br><span class="line">	<span class="keyword">var</span> obj crd.IstioKind</span><br><span class="line">	yaml.Unmarshal(request.Object.Raw, &amp;obj)</span><br><span class="line">	s, exists := wh.descriptor.GetByType(crd.CamelCaseToKebabCase(obj.Kind))</span><br><span class="line">	<span class="comment">// 进行类型转换</span></span><br><span class="line">	out, err := crd.ConvertObject(s, &amp;obj, wh.domainSuffix)</span><br><span class="line">	<span class="comment">// 调用Schema中配置的Validate进行实体校验</span></span><br><span class="line">	s.Validate(out.Name, out.Namespace, out.Spec)</span><br><span class="line">	<span class="comment">// 对属性进行检查，查看必备字段是否无缺失</span></span><br><span class="line">	checkFields(request.Object.Raw, request.Kind.Kind, request.Namespace, obj.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结，<code>Pilot</code>的校验过程较简单，主要检查：</p>
<ul>
<li>解码是否正常；</li>
<li>是否能转换成Istio类型；</li>
<li>是否符合Schema中配置的<code>Validate</code>函数；</li>
<li>必须属性是否无缺失</li>
</ul>
<p><code>Mixer</code>配置校验过程如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> request.Operation &#123;</span><br><span class="line"><span class="keyword">case</span> admissionv1beta1.Create, admissionv1beta1.Update:</span><br><span class="line">	ev.Type = store.Update</span><br><span class="line">	<span class="keyword">var</span> obj unstructured.Unstructured</span><br><span class="line">	<span class="comment">// 解码</span></span><br><span class="line">	yaml.Unmarshal(request.Object.Raw, &amp;obj)</span><br><span class="line">	ev.Value = mixerCrd.ToBackEndResource(&amp;obj)</span><br><span class="line">	ev.Key.Name = ev.Value.Metadata.Name</span><br><span class="line">  <span class="comment">// 检查必备字段是否无缺失</span></span><br><span class="line">	checkFields(request.Object.Raw, request.Kind.Kind, request.Namespace, ev.Key.Name)</span><br><span class="line"><span class="keyword">case</span> <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ev.Type == store.Update &#123;</span><br><span class="line">    <span class="comment">// 执行校验</span></span><br><span class="line">    wh.validator.Validate(ev)</span><br><span class="line">    |- _, ok := v.kinds[bev.Key.Kind] <span class="comment">// 查看是否关注此类型配置</span></span><br><span class="line">    |- ev, err := store.ConvertValue(*bev, v.kinds) <span class="comment">// 根据类型进行转换成mixer定义的对象</span></span><br><span class="line">    |- v.config.ApplyEvent([]*store.Event&#123;&amp;ev&#125;) <span class="comment">// 应用该变化</span></span><br><span class="line">    |- v.config.BuildSnapshot() <span class="comment">// 基于现有所有配置构建一次快照，若成功代表配置无异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结其过程如下：</p>
<ul>
<li>解码，若解码异常则返回失败</li>
<li>必备字段是否无缺失</li>
<li>是否是<code>Mixer</code>关注的类型</li>
<li>是否能转换成<code>Mixer</code>中定义的类型所对应的对象</li>
<li>应用变更</li>
<li>查看是否能成功构建快照成功（之所以这么做的原因是：<code>Mixer</code>中配置之间存在一定的关联性（<code>adapter</code>、<code>template</code>…），只校验单个实体是不够的）</li>
</ul>
<h3 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><p><code>Galley</code>中负责配置管理组件是<code>Processing</code>，它有两个版本<code>Processing</code>和<code>Processing2</code>，下面我们将主要研究<code>Processing2</code>的实现。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 资源快照的缓存</span></span><br><span class="line"><span class="comment">// 索引方法：如果不是SyntheticServiceEntry类型的资源则用默认的快照资源，否则是的话则用为SyntheticServiceEntry单独构建的快照。</span></span><br><span class="line">mcpCache := snapshot.New(groups.IndexFunction)</span><br><span class="line"><span class="keyword">return</span> &amp;Processing2&#123;</span><br><span class="line">	args:         a,</span><br><span class="line">	mcpCache:     mcpCache,</span><br><span class="line">	configzTopic: configz.CreateTopic(mcpCache),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>processing2</code>由以下几个组件组成：</p>
<ul>
<li><code>Source</code>:配置源，如k8s、fs；</li>
<li><code>Runtime</code>:<code>Galley</code>中最复杂的模块，它将<code>Source</code>、<code>Transform</code>、<code>Snapshotter</code>、<code>distributor</code>连接在一起。<ul>
<li><code>runtime</code>中创建带有状态机机制的组件 <strong>session</strong> 来追踪开始、结束事件处理循环<ul>
<li><code>inactive</code>:未激活状态；</li>
<li><code>starting</code>:当会话开始时，即转变为开始状态。为了避免在启动阶段阻塞并可以正确处理所有生命周期事件，其是一个很短暂的状态。当所有数据源初始化完成时，它将会被转换成<code>buffering</code>状态。</li>
<li><code>buffering</code>: 此阶段，所有数据源都已经初始化完成，但还没收到<code>meshconfig</code>时间。所有非<code>meshconfig</code>事件都将会被缓存，直到<code>meshconfig</code>到达；</li>
<li><code>processing</code>: 一旦接收到<code>meshconfig</code>后，<code>runtime</code>将开始做配置转换并开始分发缓存的事件到各转换器。当接收到<code>reset</code>事件或者收到<code>meshconfig</code>的变更时，<code>session</code>将转换成<code>inactive</code>状态或者创建新的<code>session</code>。</li>
</ul>
</li>
</ul>
</li>
<li><code>snapshot.Cache</code>: 配置快照</li>
</ul>
<p><strong>processing2</strong> 初始化流程实现如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Processing2)</span> <span class="title">Start</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建本地文件类型的配置源</span></span><br><span class="line">    mesh = meshcfgNewFS(p.args.MeshConfigFile)</span><br><span class="line">    <span class="comment">// 从本地文件`metadata.yaml`中加载所有元数据信息</span></span><br><span class="line">    m := metadata.MustGet()</span><br><span class="line">    <span class="comment">// 根据元数据中转换配置以及其他配置构建类型转换器提供者逻辑，即告知输入参数类型、输出参数类型，以及转换函数实现</span></span><br><span class="line">    transformProviders := transforms.Providers(m)</span><br><span class="line">    <span class="keyword">var</span> colsInSnapshots collection.Names</span><br><span class="line">    <span class="comment">// 默认输入参数中，Snapshots包含Default和SyntheticServiceEntry。从元数据中获取所有在这些Snapshot中的集合</span></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> m.AllCollectionsInSnapshots(p.args.Snapshots) &#123;</span><br><span class="line">		colsInSnapshots = <span class="built_in">append</span>(colsInSnapshots, collection.NewName(c))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 过滤出所有需要的k8s资源信息（这里有个判断，如果Galley不充当服务发现角色则过滤掉k8s内置的资源信息，如k8s的Service\Node\Endpoint等）</span></span><br><span class="line">	kubeResources := kuberesource.DisableExcludedKubeResources(m.KubeSource().Resources(), transformProviders,</span><br><span class="line">		colsInSnapshots, p.args.ExcludedResourceKinds, p.args.EnableServiceDiscovery)</span><br><span class="line">	<span class="comment">// 创建 k8s来源的数据源，其会对k8s中所有`crd`资源进行watch</span></span><br><span class="line">	src, updater, err = p.createSourceAndStatusUpdater(kubeResources)</span><br><span class="line">	<span class="comment">// 分配器</span></span><br><span class="line">	<span class="keyword">var</span> distributor snapshotter.Distributor = snapshotter.NewMCPDistributor(p.mcpCache)</span><br><span class="line">	<span class="comment">// 创建运行时，进行一些快照以及分类内容的初始化</span></span><br><span class="line">	p.runtime, err = processorInitialize(processorSettings)</span><br><span class="line">	|-	<span class="comment">//... 初始化快照参数（更新策略，是否防抖动）</span></span><br><span class="line">	|- procProvider := <span class="function"><span class="keyword">func</span><span class="params">(o processing.ProcessorOptions)</span> <span class="title">event</span>.<span class="title">Processor</span></span> &#123;</span><br><span class="line">		xforms := settings.TransformProviders.Create(o)</span><br><span class="line">		s, err := snapshotter.NewSnapshotter(xforms, options)</span><br><span class="line">		<span class="keyword">return</span> s</span><br><span class="line">	   &#125;</span><br><span class="line">	|- processing.NewRuntime(rtOpt) <span class="comment">//创建运行时，并向配置源注册事件处理器</span></span><br><span class="line">	   |- r := &amp;Runtime&#123;</span><br><span class="line">		      options: o.Clone(),</span><br><span class="line">	      &#125;</span><br><span class="line">	   |- h := event.HandlerFromFn(r.handle)</span><br><span class="line">	   |- o.Source.Dispatch(h)   </span><br><span class="line">	<span class="comment">// 创建 grpc sever   </span></span><br><span class="line">	p.grpcServer = grpc.NewServer(grpcOptions...)</span><br><span class="line">	<span class="comment">// 向指定地址服务器发起建立连接，并对对方提供配置服务（galley中特别的设计，client_source模式）</span></span><br><span class="line">	p.callOut, err = newCallout(p.args.SinkAddress, p.args.SinkAuthMode, md, options)</span><br><span class="line">	<span class="comment">//创建 MCP Server Source</span></span><br><span class="line">	p.mcpSource = source.NewServer(options, serverOptions)</span><br><span class="line">	<span class="comment">// 将MCP Server注册到grpc server上对外提供服务</span></span><br><span class="line">	mcp.RegisterResourceSourceServer(p.grpcServer, p.mcpSource)</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	p.runtime.Start()</span><br><span class="line">	|- <span class="keyword">go</span> r.run(...) <span class="comment">// 异步运行</span></span><br><span class="line">	   |- se, done := newSession(sid, r.options) <span class="comment">// 创建并初始化配置处理会话</span></span><br><span class="line">		|- r.session.Store(se)</span><br><span class="line">		|- se.start()</span><br><span class="line">		  |- s.transitionTo(starting) <span class="comment">//更改状态</span></span><br><span class="line">		  |- <span class="keyword">go</span> s.startSources()</span><br><span class="line">		    |- s.options.Source.Start() <span class="comment">//开始所有配置源组件</span></span><br><span class="line">		    |- 当Source初始化成功后，会向runtime发送一个<span class="string">`FullSync`</span>事件。</span><br><span class="line">	gs.Serve(l) <span class="comment">// 开启grpc服务</span></span><br><span class="line">	p.callOut.run()</span><br><span class="line">	|- conn, err := c.pt.grpcDial(c.address, c.do...) <span class="comment">// dial</span></span><br><span class="line">	|- client := mcp.NewResourceSinkClient(conn) <span class="comment">// 创建Mcp sink client</span></span><br><span class="line">	|- mcpClient := c.pt.sourceNewClient(client, c.so) <span class="comment">// 创建mcp client</span></span><br><span class="line">	|- mcpClient.Run(ctx) <span class="comment">// 运行 client_source</span></span><br><span class="line">	   |- c.sendTriggerResponse(stream) <span class="comment">// $triggerCollection（特别记号）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结其流程如下：</p>
<ol>
<li>初始化配置源<code>Source</code>: <code>meshSource</code>(文件配置源)、<code>apiServer.Source</code>（k8s crd配置源）；</li>
<li>解析配置文件中的元数据，初始化转换器提供者；</li>
<li>创建并初始化 <code>Runtime</code>；</li>
<li>创建<code>Callout</code>(将<code>galley</code>作为<code>client</code>方式为目标服务提供配置服务)；</li>
<li>创建 <strong>gRpc Service</strong> <code>mcpSource</code>，为配置使用方服务；</li>
<li>启动 <code>Runtime</code>，过程比较复杂，下面将详细介绍；</li>
<li>启动<code>grpc</code>提供服务；</li>
<li>启动<code>callout</code>连接到目标服务，对其提供服务。</li>
</ol>
<p>可以看到<code>Runtime</code>是<code>Galley</code>的核心，对接各种配置源，并进行配置转换。而<code>mcpSource</code>是用来对配置客户端提供服务的，他们之间通过<code>mcpCache</code>进行衔接。<code>Runtime</code>经过一系列处理后构建<code>Snapshot</code>，然后将快照传进<code>mcpCache</code>。<code>mcpSource</code>从<code>mcpCache</code>中获取配置信息，同时监听<code>mcpCache</code>的配置变更并push到客户端。</p>
<p><code>Runtime</code>启动流程大致如下：<br><img src="/media/15780350474622.jpg" alt=""></p>
<p>总结起来，<code>Galley</code>整体架构如下：<br><img src="/media/15780373176301.jpg" alt=""></p>
<h4 id="配置处理流程"><a href="#配置处理流程" class="headerlink" title="配置处理流程"></a>配置处理流程</h4><ol>
<li>当<code>client</code>首次与<strong>gRpcServer</strong>建立连接后，会从<code>stream</code>中获取其节点信息<code>PeerInfo</code>，同时从<code>PeerInfo</code>中截取<code>AuthInfo</code>进行校验；</li>
<li><code>mcpSource</code>调用<code>Processtream</code>方法对<code>Stream</code>进行处理：<ul>
<li>首先为每个客户端创建一个<code>connection</code>对象，用来保存其元信息（节点信息、订阅类型以及订阅类型的监听状态等）</li>
<li>然后会同时监听<code>connection</code>的请求通道<code>reuqestC</code>和向其推送信息的队列<code>queue</code></li>
</ul>
</li>
</ol>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> connection <span class="keyword">struct</span> &#123;</span><br><span class="line">    peerAddr <span class="keyword">string</span></span><br><span class="line">    stream   Stream</span><br><span class="line">    id       <span class="keyword">int64</span></span><br><span class="line">    streamNonce <span class="keyword">int64</span> <span class="comment">// 请求-响应记号 // 只有在server端每次发送数据时才会修改该值</span></span><br><span class="line">    requestC <span class="keyword">chan</span> *mcp.RequestResources</span><br><span class="line">    watches  <span class="keyword">map</span>[<span class="keyword">string</span>]*watch <span class="comment">//每种类型配置的监听状态</span></span><br><span class="line">    watcher  Watcher <span class="comment">// mcpCache</span></span><br><span class="line">    queue *internal.UniqueQueue</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>初次请求处理流程如下：</strong><br><img src="/media/15780405468904.jpg" alt=""></p>
<p><strong>变更下发流程如下：</strong><br>以<code>apiServer</code>为配置源，资源 <code>VirtualService</code> 为例来讲解配置下发流程：<br><img src="/media/15780623306136.jpg" alt=""><br>可以看出其流程非常之长，但概括起来其过程：</p>
<ul>
<li><strong>Source变更</strong> -&gt; <strong>Runtime进行转换</strong> -&gt; <strong>Cache更新快照</strong> -&gt; <strong>connectin连接下发更新</strong></li>
</ul>
<h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><ol>
<li><code>metadata.yaml</code> 元数据配置文件<br><img src="/media/15779491994478.jpg" alt=""></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2019/10/14/istio/2.istio-pilot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.png">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/14/istio/2.istio-pilot/" class="post-title-link" itemprop="url">Istio Pilot</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-14 00:00:00" itemprop="dateCreated datePublished" datetime="2019-10-14T00:00:00+08:00">2019-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-13 20:07:15" itemprop="dateModified" datetime="2020-02-13T20:07:15+08:00">2020-02-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/istio/" itemprop="url" rel="index">
                    <span itemprop="name">istio</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Pilot"><a href="#Pilot" class="headerlink" title="Pilot"></a>Pilot</h1><p><code>Pilot</code>是Istio的控制中枢，它负责<code>sidecar</code>的生命周期管理并负责向<code>Sidecar</code>下发控制数据。</p>
<p>[TOC]</p>
<p>下面将从以下几个方面来分析<code>Pilot</code>:</p>
<ul>
<li>整体架构</li>
<li>启动过程</li>
<li><code>Sidecar</code> 初始拉取过程 <strong>&amp;</strong> 信息下发过程</li>
<li>拓展性</li>
</ul>
<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><code>Pilot</code> 内部整体架构如下：</p>
<ul>
<li>实现 <strong>Grpc Server</strong> 对<code>Envoy</code>提供查询配置以及服务发现服务；</li>
<li>支持配置控制器、服务控制器</li>
<li>配置控制器支持聚合多种类型配置源，如 K8s、基于文件系统的内存配置源、Galley 以及其他的实现MCP协议的拓展配置中心服务；</li>
<li>服务控制器同样支持多种类型服务注册中心，如 K8s、Consul以及可以拓展MCP协议实现的注册中心服务</li>
<li>另外，通过<code>ControlZ</code>服务对外暴露 <code>Pilot</code> 内部配置&amp;运行时信息的查询和修改接口</li>
</ul>
<p><img src="/media/15769864174743.jpg" alt=""></p>
<h2 id="启动分析"><a href="#启动分析" class="headerlink" title="启动分析"></a>启动分析</h2><p>首先其入口地址为：<code>istio/pilot/cmd/pilot-discovery</code>。<br>启动前，<code>init</code>方法预先执行，其解析出启动参数如：<code>registries</code>(注册中心配置，若未配置，则默认注册中心为<code>k8s</code>)、<code>meshConfig</code>(mesh的配置文件地址)、<code>httpAddr</code>、<code>grpcAddr</code> 服务器启动http、Grpc端口等。<br><code>discoveryCmd.Run</code>方法为启动入口，首先通过<code>bootstrap.NewServer</code>创建<strong>Server</strong>，然后通过<code>Start</code>方法启动 <strong>Server</strong>。<br>首先，看<code>bootstrap.NewServer</code>方法：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">s := &amp;Server&#123;</span><br><span class="line">    <span class="comment">// 文件监听器组件，用于监听文件更新事件</span></span><br><span class="line">	fileWatcher: filewatcher.NewWatcher(),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建k8s client</span></span><br><span class="line">s.initKubeClient(&amp;args)</span><br><span class="line"><span class="comment">// 初始化 mesh配置 根据配置地址从指定位置获取配置，并添加文件监听器监听更新</span></span><br><span class="line">s.initMesh(&amp;args)</span><br><span class="line"><span class="comment">//  初始化Mesh网络配置，根据配置地址从指定位置获取配置，并添加文件监听器监听更新</span></span><br><span class="line">s.initMeshNetworks(&amp;args)</span><br><span class="line"><span class="comment">// 初始化证书控制器</span></span><br><span class="line">s.initCertController(&amp;args)</span><br><span class="line"><span class="comment">// 初始化配置控制器</span></span><br><span class="line">s.initConfigController(&amp;args)</span><br><span class="line"><span class="comment">// 初始化服务控制器</span></span><br><span class="line">s.initServiceControllers(&amp;args)</span><br><span class="line"><span class="comment">// 初始化发现服务</span></span><br><span class="line">s.initDiscoveryService(&amp;args)</span><br><span class="line"><span class="comment">// 初始化监控服务</span></span><br><span class="line">s.initMonitor(&amp;args)</span><br><span class="line"><span class="comment">// 初始化集群注册器，监控远程集群并初始化多集群结构</span></span><br><span class="line">s.initClusterRegistries(&amp;args)</span><br></pre></td></tr></table></figure>
<p>创建完<code>DiscoveryServer</code>后，通过调用<code>Start</code>方法启动各组件。<br>上面执行流程大致过程如下：首先创建与<code>k8s</code>的交互客户端，然后根据初始传入配置路径读取配置文件中<code>mesh</code>以及网络的配置，同时监听、维护配置文件更新；其后创建三个控制器：证书、配置、服务控制器分别管理 Secert、config、service信息；再创建发现服务：聚合上面所有控制器的能力对<strong>Sidecar</strong>提供服务。<br>下面将分别介绍初始化<code>mesh</code>配置以及网络配置过程，初始化证书、配置以及服务控制器，以及初始化发现服务。</p>
<h3 id="初始化Mesh配置"><a href="#初始化Mesh配置" class="headerlink" title="初始化Mesh配置"></a>初始化<code>Mesh</code>配置</h3><p> <strong>initMesh</strong>方法，首先判断是否配置了<code>args.Mesh.ConfigFile</code>。若是，则从文件中读取配置信息，并添加文件监听器当有更新时回调更新方法（下发配置）；若无，则从<code>k8s</code>中获取mesh配置信息。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// args.Mesh.ConfigFile != ""</span></span><br><span class="line">meshConfig, err = cmd.ReadMeshConfig(args.Mesh.ConfigFile)</span><br><span class="line">s.addFileWatcher(args.Mesh.ConfigFile, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	meshConfig, err = cmd.ReadMeshConfig(args.Mesh.ConfigFile)</span><br><span class="line">	<span class="keyword">if</span> !reflect.DeepEqual(meshConfig, s.mesh) &#123;</span><br><span class="line">		s.mesh = meshConfig</span><br><span class="line">		<span class="keyword">if</span> s.EnvoyXdsServer != <span class="literal">nil</span> &#123;</span><br><span class="line">			s.EnvoyXdsServer.Env.Mesh = meshConfig</span><br><span class="line">			<span class="comment">//下发配置</span></span><br><span class="line">			s.EnvoyXdsServer.ConfigUpdate(&amp;model.PushRequest&#123;Full: <span class="literal">true</span>&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 从k8s中获取配置信息 namespace:istio-system, name:istio</span></span><br><span class="line">cfg, err := kube.CoreV1().ConfigMaps(namespace).Get(name, meta_v1.GetOptions&#123;&#125;)</span><br><span class="line">cfgYaml, exists := cfg.Data[ConfigMapKey]</span><br><span class="line">meshConfig, err := mesh.ApplyMeshConfigDefaults(cfgYaml)</span><br></pre></td></tr></table></figure>

<h3 id="初始化配置控制器"><a href="#初始化配置控制器" class="headerlink" title="初始化配置控制器"></a>初始化配置控制器</h3><p><strong>Pilot</strong> 支持对接多配置中心，支持从多个配置中心获取配置值：</p>
<ol>
<li>若设置了配置源<code>mesh.ConfigSources</code>，则初始化<code>MCPConfigController</code>；</li>
<li>若设置了配置文件目录<code>Config.FileDir</code>，则创建一个内存配置控制器。并定时（<code>100ms</code>）同步指定文件目录下的配置到内存配置控制器中；</li>
<li>创建 <strong>k8s</strong> 配置控制器，每种Istio配置类型对应一种<code>CRD</code>资源，并创建每种资源的informer，构成配置更新机制。</li>
</ol>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s.mesh.ConfigSources) &gt; <span class="number">0</span> &#123;</span><br><span class="line">  s.initMCPConfigController(args)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> args.Config.Controller != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="comment">// 正常流程不会走到此处</span></span><br><span class="line">	s.configController = args.Config.Controller</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> args.Config.FileDir != <span class="string">""</span> &#123;</span><br><span class="line">	store := memory.Make(schemas.Istio)</span><br><span class="line">	configController := memory.NewController(store)</span><br><span class="line">	err := s.makeFileMonitor(args.Config.FileDir, configController)</span><br><span class="line">	s.configController = configController</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	cfgController, err := s.makeKubeConfigController(args)</span><br><span class="line">	s.configController = cfgController</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后添加置后 <strong>Start</strong>方法，在所有组件初始化完成执行（Pilot中所有组件都是如此）。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.addStartFunc(<span class="function"><span class="keyword">func</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> s.configController.Run(stop)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>完成基本类型配置控制器创建后，会继续判断是否支持 <code>Ingress</code> 模式的配置；若是则对控制器进行包装：添加一种配置类型<code>Ingress</code>，并按类型进行映射：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   configController, err := configaggregate.MakeCache([]model.ConfigStoreCache&#123;</span><br><span class="line">	s.configController,</span><br><span class="line">	ingress.NewController(s.kubeClient, s.mesh, args.Config.ControllerOptions),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>最后，根据创建的配置控制器创建 <code>IstioConfigStore</code>。其作用就是配置访问层，提供具体配置查询接口，定义如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IstioConfigStore <span class="keyword">interface</span> &#123;</span><br><span class="line">	ConfigStore</span><br><span class="line">	ServiceEntries() []Config</span><br><span class="line">	Gateways(workloadLabels labels.Collection) []Config</span><br><span class="line">	EnvoyFilter(workloadLabels labels.Collection) *Config</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<strong>MCP</strong>协议 是<code>Istio</code>中最近比较火的概念，下文将详细讲解<code>initMCPConfigController</code>：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">initMCPConfigController</span><span class="params">(args *PilotArgs)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> _, configSource := <span class="keyword">range</span> s.mesh.ConfigSources &#123;</span><br><span class="line">        <span class="keyword">if</span> strings.Contains(configSource.Address, fsScheme+<span class="string">"://"</span>) &#123;</span><br><span class="line">        <span class="comment">// ... 若是，则创建文件配置控制器，上文中有提起此种类型控制器</span></span><br><span class="line">            configStores = <span class="built_in">append</span>(configStores, configController)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据配置创建与MCP server的grpc链接</span></span><br><span class="line">        conn, err := grpc.DialContext(</span><br><span class="line">			ctx,<span class="comment">//... 配置</span></span><br><span class="line">			)</span><br><span class="line">			<span class="comment">// 创建MCP控制</span></span><br><span class="line">			s.mcpController(args, conn, reporter, &amp;clients, &amp;configStores)</span><br><span class="line">			|- <span class="comment">// 基于Grpc链接创建grpc资源客户端，其用于与MCP服务端建立Stream通道，</span></span><br><span class="line">			|- cl := mcpapi.NewResourceSourceClient(conn)</span><br><span class="line">			<span class="comment">// 创建MCP客户端</span></span><br><span class="line">			|- mcpClient := sink.NewClient(cl, sinkOptions)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// ！！！这里很有意思即可以 MCP服务端同时当成 注册中心使用</span></span><br><span class="line">			<span class="keyword">if</span> resourceContains(configSource.SubscribedResources, meshconfig.Resource_SERVICE_REGISTRY) &#123;</span><br><span class="line">			    args.Service.Registries = []<span class="keyword">string</span>&#123;<span class="keyword">string</span>(serviceregistry.MCPRegistry)&#125;</span><br><span class="line">    			conn, err := grpc.DialContext(</span><br><span class="line">    				ctx,</span><br><span class="line">    				<span class="comment">//...配置)</span></span><br><span class="line">    			conns = <span class="built_in">append</span>(conns, conn)</span><br><span class="line">    			<span class="comment">// 合成服务注册中心</span></span><br><span class="line">    			s.sseMCPController(args, conn, reporter, &amp;clients, &amp;configStores)</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 添加启动方法</span></span><br><span class="line">	s.addStartFunc(<span class="function"><span class="keyword">func</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> clients &#123;</span><br><span class="line">			client := clients[i]</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				client.Run(ctx)</span><br><span class="line">			&#125;()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将多个配置服务源进行聚合</span></span><br><span class="line">	aggregateMcpController, err := configaggregate.MakeCache(configStores)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续跟进<code>s.mcpController(args, conn, reporter, &amp;clients, &amp;configStores)</code>，逻辑：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">mcpController</span><span class="params">(args *PilotArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">	conn *grpc.ClientConn,</span></span></span><br><span class="line"><span class="function"><span class="params">	reporter monitoring.Reporter,</span></span></span><br><span class="line"><span class="function"><span class="params">	clients *[]*sink.Client,</span></span></span><br><span class="line"><span class="function"><span class="params">	configStores *[]model.ConfigStoreCache)</span></span> &#123;</span><br><span class="line">	<span class="comment">//  CoreDataModel 结构，用于配置临时存储并接收MCP Server下发的变更</span></span><br><span class="line">	mcpController := coredatamodel.NewController(s.mcpOptions)</span><br><span class="line">	sinkOptions := &amp;sink.Options&#123;</span><br><span class="line">		CollectionOptions: collections,</span><br><span class="line">		Updater:           mcpController,</span><br><span class="line">		ID:                clientNodeID,</span><br><span class="line">		Reporter:          reporter,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建资源客户端</span></span><br><span class="line">	cl := mcpapi.NewResourceSourceClient(conn)</span><br><span class="line">	<span class="comment">// 创建Sink客户端，针对MCP而设计的资源信息交互组件，后面我们将分章节讲解MCP整体交互实现。</span></span><br><span class="line">	mcpClient := sink.NewClient(cl, sinkOptions)</span><br><span class="line">	configz.Register(mcpClient)</span><br><span class="line">	*clients = <span class="built_in">append</span>(*clients, mcpClient)</span><br><span class="line">	*configStores = <span class="built_in">append</span>(*configStores, mcpController)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结创建 <strong>MCPConfigController</strong>的执行过程如下：</p>
<ul>
<li>对于每种配置源，根据<code>configSource.Address</code>以及配置创建与<strong>MCP</strong>服务端的grpc链接以及stream client；</li>
<li>创建 <code>mcpController</code> 用于接收 <strong>MCP Server</strong> 的配置变更；</li>
<li>创建 <code>Sink</code>组件，维护与 <strong>MCP Server</strong> 的交互；</li>
<li>别外，如果若配置源同时也维护 <strong>服务资源</strong>（充当注册中心的角色），同时会创建 <code>SyntheticServiceEntryController</code>。</li>
</ul>
<h3 id="初始化服务控制器"><a href="#初始化服务控制器" class="headerlink" title="初始化服务控制器"></a>初始化服务控制器</h3><p>Pilot同时也支持对接多个注册中心，其同时可以从多个注册中心获取服务注册信息。目前Pilot支持三种类型的注册中心：k8s、consul和基于MCP协议实现的注册中心。<br>初始化时，创建指定类型<code>Registry</code>，然后加到<code>aggregate.Controller</code>中，其聚合不同注册中心的数据，对sidecar服务。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">initServiceControllers</span><span class="params">(args *PilotArgs)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> args.Service.Registries &#123;</span><br><span class="line">        <span class="keyword">switch</span> serviceRegistry &#123;</span><br><span class="line">		<span class="keyword">case</span> serviceregistry.KubernetesRegistry:</span><br><span class="line">		  s.createK8sServiceControllers(serviceControllers, args)</span><br><span class="line">		<span class="keyword">case</span> serviceregistry.ConsulRegistry:</span><br><span class="line">			s.initConsulRegistry(serviceControllers, args)</span><br><span class="line">		<span class="keyword">case</span> serviceregistry.MCPRegistry:</span><br><span class="line">			<span class="keyword">if</span> s.mcpDiscovery != <span class="literal">nil</span> &#123;</span><br><span class="line">				serviceControllers.AddRegistry(</span><br><span class="line">					aggregate.Registry&#123;</span><br><span class="line">						Name:             serviceregistry.MCPRegistry,</span><br><span class="line">						<span class="comment">// mcpDiscovery为之前初始化配置服务时创建</span></span><br><span class="line">						ServiceDiscovery: s.mcpDiscovery,</span><br><span class="line">						Controller:       s.mcpDiscovery,</span><br><span class="line">					&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将配置中心包装成注册中心，其会将配置数据转换成Sidecar需要的Sercice\Instance数据。</span></span><br><span class="line">    serviceEntryStore := external.NewServiceDiscovery(s.configController, s.istioConfigStore)</span><br><span class="line">    serviceEntryRegistry := aggregate.Registry&#123;</span><br><span class="line">		Name:             <span class="string">"ServiceEntries"</span>,</span><br><span class="line">		Controller:       serviceEntryStore,</span><br><span class="line">		ServiceDiscovery: serviceEntryStore,</span><br><span class="line">	&#125;</span><br><span class="line">	serviceControllers.AddRegistry(serviceEntryRegistry)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加开启方法</span></span><br><span class="line">s.addStartFunc(<span class="function"><span class="keyword">func</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> s.ServiceController.Run(stop)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>初始化服务发现控制器的过程主要如下：</p>
<ul>
<li>根据注册器配置列表创建相应类型服务发现管理器；</li>
<li>将配置中心包装成发现服务；</li>
<li>将生成的所有发现服务聚合成<code>aggregate.Controller</code></li>
</ul>
<p>再深入<code>Registry</code>服务逻辑，首先看其定义：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Registry <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 服务注册类型</span></span><br><span class="line">	Name serviceregistry.ServiceRegistry</span><br><span class="line">	<span class="comment">// 集群ID，当有多个同种类型注册中心时，用ClusterID来区分它们</span></span><br><span class="line">	ClusterID <span class="keyword">string</span></span><br><span class="line">   <span class="comment">// 控制器：提供接口让依赖方可以加入变更事件处理器</span></span><br><span class="line">	model.Controller</span><br><span class="line">	<span class="comment">// 定义获取资源的接口</span></span><br><span class="line">	model.ServiceDiscovery</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Controller <span class="keyword">interface</span> &#123;</span><br><span class="line">	AppendServiceHandler(f <span class="function"><span class="keyword">func</span><span class="params">(*Service, Event)</span>) <span class="title">error</span></span></span><br><span class="line">	AppendInstanceHandler(f <span class="function"><span class="keyword">func</span><span class="params">(*ServiceInstance, Event)</span>) <span class="title">error</span></span></span><br><span class="line">	Run(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ServiceDiscovery <span class="keyword">interface</span> &#123;</span><br><span class="line">	Services() ([]*Service, error)</span><br><span class="line">	GetService(hostname host.Name) (*Service, error)</span><br><span class="line">	InstancesByPort(svc *Service, servicePort <span class="keyword">int</span>, labels labels.Collection) ([]*ServiceInstance, error)</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面将以<code>k8s</code>为具体发现服务来讲解其工作原理。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">createK8sServiceControllers</span><span class="params">(serviceControllers *aggregate.Controller, args *PilotArgs)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	clusterID := <span class="keyword">string</span>(serviceregistry.KubernetesRegistry)</span><br><span class="line">	args.Config.ControllerOptions.ClusterID = clusterID</span><br><span class="line">	<span class="comment">// 构建k8s服务发现控制器</span></span><br><span class="line">	kubectl := controller2.NewController(s.kubeClient, args.Config.ControllerOptions)</span><br><span class="line">	s.kubeRegistry = kubectl</span><br><span class="line">	serviceControllers.AddRegistry(</span><br><span class="line">		aggregate.Registry&#123;</span><br><span class="line">			Name:             serviceregistry.KubernetesRegistry,</span><br><span class="line">			ClusterID:        clusterID,</span><br><span class="line">			ServiceDiscovery: kubectl,</span><br><span class="line">			Controller:       kubectl,</span><br><span class="line">		&#125;)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上文可以看出<code>controller2.NewController</code>是 <strong>k8sRegistry</strong> 的核心部分。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewController</span><span class="params">(client kubernetes.Interface, options Options)</span> *<span class="title">Controller</span></span> &#123;</span><br><span class="line">	<span class="comment">// Queue requires a time duration for a retry delay after a handler error</span></span><br><span class="line">	out := &amp;Controller&#123;</span><br><span class="line">		domainSuffix:               options.DomainSuffix,</span><br><span class="line">		client:                     client,</span><br><span class="line">		queue:                      kube.NewQueue(<span class="number">1</span> * time.Second),</span><br><span class="line">		ClusterID:                  options.ClusterID,</span><br><span class="line">		XDSUpdater:                 options.XDSUpdater,</span><br><span class="line">		servicesMap:                <span class="built_in">make</span>(<span class="keyword">map</span>[host.Name]*model.Service),</span><br><span class="line">		externalNameSvcInstanceMap: <span class="built_in">make</span>(<span class="keyword">map</span>[host.Name][]*model.ServiceInstance),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 基于k8s的client创建Informer(与k8s apiserver的交互组件)</span></span><br><span class="line">	sharedInformers := informers.NewSharedInformerFactoryWithOptions(client, options.ResyncPeriod, informers.WithNamespace(options.WatchedNamespace))</span><br><span class="line">	<span class="comment">// 创建 Service、Endpoint、Node、Pod 的 Informer，并向每个informer中添加事件监听器，监听每种类型的变更事件。当有变更时会通知controller的queue，Queue中会定时`1s`捞事件执行回调，回调什么将从下文中介绍</span></span><br><span class="line">	svcInformer := sharedInformers.Core().V1().Services().Informer()</span><br><span class="line">	out.services = out.createCacheHandler(svcInformer, <span class="string">"Services"</span>)</span><br><span class="line"></span><br><span class="line">	epInformer := sharedInformers.Core().V1().Endpoints().Informer()</span><br><span class="line">	out.endpoints = out.createEDSCacheHandler(epInformer, <span class="string">"Endpoints"</span>)</span><br><span class="line"></span><br><span class="line">	nodeInformer := sharedInformers.Core().V1().Nodes().Informer()</span><br><span class="line">	out.nodes = out.createCacheHandler(nodeInformer, <span class="string">"Nodes"</span>)</span><br><span class="line"></span><br><span class="line">	podInformer := sharedInformers.Core().V1().Pods().Informer()</span><br><span class="line">	out.pods = newPodCache(out.createCacheHandler(podInformer, <span class="string">"Pod"</span>), out)</span><br><span class="line">	<span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先基于 <code>k8s</code> client创建 <code>Service</code>、<code>Endpoint</code>、<code>Node</code>、<code>Pod</code>（<code>k8s</code>中的服务角色） 的 Informer（k8s为了简化各组件之间交互而构建的工具，其即具有缓存的功能同时也有查询与实时变更通知的功能）。</li>
<li>向每种 <code>Informer</code> 添加变更事件回调方法，回调方法会往<code>controller</code>的<code>queue</code>中Push变更task</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">handler := &amp;kube.ChainHandler&#123;Funcs: []kube.Handler&#123;c.notify&#125;&#125;</span><br><span class="line">informer.AddEventHandler(</span><br><span class="line">		cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">			AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    			<span class="comment">// ...</span></span><br><span class="line">    			c.queue.Push(kube.Task&#123;Handler: handler.Apply, Obj: obj, Event: model.EventAdd&#125;)</span><br><span class="line">			&#125;,</span><br><span class="line">			UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, cur <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    			<span class="comment">// ...</span></span><br><span class="line">			&#125;,</span><br><span class="line">			DeleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		      <span class="comment">// ...</span></span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;)</span><br><span class="line">handler := &amp;kube.ChainHandler&#123;Funcs: []kube.Handler&#123;c.notify&#125;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>queue</code>是一个防抖动的设计，其会缓存一秒的变更对象，然后集中执行<code>Handler</code>方法，而<code>Handler</code>则是一个调用链。其允许添加多个处理器</li>
<li>再看对<code>Controller</code>接口的实现方法，其实就是往<code>queue</code>的调用链中添加处理方法：</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">AppendServiceHandler</span><span class="params">(f <span class="keyword">func</span>(*model.Service, model.Event)</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">	c.services.handler.Append(<span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;, event model.Event)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		svc, ok := obj.(*v1.Service)</span><br><span class="line">		hostname := svc.Name + <span class="string">"."</span> + svc.Namespace</span><br><span class="line">		ports := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">uint32</span>&#123;&#125;</span><br><span class="line">		portsByNum := <span class="keyword">map</span>[<span class="keyword">uint32</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> _, port := <span class="keyword">range</span> svc.Spec.Ports &#123;</span><br><span class="line">			ports[port.Name] = <span class="keyword">uint32</span>(port.Port)</span><br><span class="line">			portsByNum[<span class="keyword">uint32</span>(port.Port)] = port.Name</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将</span></span><br><span class="line">		svcConv := kube.ConvertService(*svc, c.domainSuffix, c.ClusterID)</span><br><span class="line">		instances := kube.ExternalNameServiceInstances(*svc, svcConv)</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="comment">// EDS needs the port mapping.</span></span><br><span class="line">		c.XDSUpdater.SvcUpdate(c.ClusterID, hostname, ports, portsByNum)</span><br><span class="line">     <span class="comment">// 回调</span></span><br><span class="line">		f(svcConv, event)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化发现服务"><a href="#初始化发现服务" class="headerlink" title="初始化发现服务"></a>初始化发现服务</h3><p><code>EnvoyXdsServer</code> 的作用是聚合服务控制器、配置控制器、mesh配置、meshNetworks配置信息，为<code>Sidecar</code>提供服务。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">initDiscoveryService</span><span class="params">(args *PilotArgs)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    environment := &amp;model.Environment&#123;</span><br><span class="line">		Mesh:             s.mesh,</span><br><span class="line">		MeshNetworks:     s.meshNetworks,</span><br><span class="line">		IstioConfigStore: s.istioConfigStore,</span><br><span class="line">		ServiceDiscovery: s.ServiceController,</span><br><span class="line">		PushContext:      model.NewPushContext(),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 添加 `/v1/registration`路径处理函数，查询所有Service和Endpoint</span></span><br><span class="line">	discovery, err := envoy.NewDiscoveryService(</span><br><span class="line">		environment,</span><br><span class="line">		args.DiscoveryOptions,</span><br><span class="line">	)</span><br><span class="line">	s.mux = discovery.RestContainer.ServeMux</span><br><span class="line">	<span class="comment">// 1. 聚合配置中心、注册中心，并往其中添加各种类型的事件处理器</span></span><br><span class="line">	<span class="comment">// 2. 创建配置生成器</span></span><br><span class="line">	s.EnvoyXdsServer = envoyv2.NewDiscoveryServer(environment,</span><br><span class="line">		istio_networking.NewConfigGenerator(args.Plugins),</span><br><span class="line">		s.ServiceController, s.kubeRegistry, s.configController)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">if</span> s.kubeRegistry != <span class="literal">nil</span> &#123;</span><br><span class="line">		s.kubeRegistry.Env = environment</span><br><span class="line">		s.kubeRegistry.InitNetworkLookup(s.meshNetworks)</span><br><span class="line">		<span class="comment">// 设置k8s注册器的更新回调</span></span><br><span class="line">		s.kubeRegistry.XDSUpdater = s.EnvoyXdsServer</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> s.mcpOptions != <span class="literal">nil</span> &#123;</span><br><span class="line">	   <span class="comment">// 设置mcp配置更新回调</span></span><br><span class="line">		s.mcpOptions.XDSUpdater = s.EnvoyXdsServer</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> s.incrementalMcpOptions != <span class="literal">nil</span> &#123;</span><br><span class="line">		clusterID := args.Config.ControllerOptions.ClusterID</span><br><span class="line">		s.incrementalMcpOptions.XDSUpdater = s.EnvoyXdsServer</span><br><span class="line">		s.incrementalMcpOptions.ClusterID = clusterID</span><br><span class="line">		<span class="comment">// 设置服务发现配置更新回调</span></span><br><span class="line">		s.discoveryOptions.XDSUpdater = s.EnvoyXdsServer</span><br><span class="line">		s.discoveryOptions.Env = environment</span><br><span class="line">		s.discoveryOptions.ClusterID = clusterID</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s.addStartFunc(<span class="function"><span class="keyword">func</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		s.EnvoyXdsServer.Start(stop)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// 创建GrpServer，并将 EnvoyXdsServer 服务注册到GrpcServer中</span></span><br><span class="line">	s.initGrpcServer(args.KeepaliveOptions)</span><br><span class="line">	<span class="comment">// 创建安全端口服务</span></span><br><span class="line">	<span class="keyword">if</span> args.DiscoveryOptions.SecureGrpcAddr != <span class="string">""</span> &#123;</span><br><span class="line">    	s.initSecureGrpcServer(args.KeepaliveOptions)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>其中，最重要的是创建<code>EnvoyXdsServer</code>，构建参数分别是 <code>Environment</code> 所有数据源、<code>ConfigGenerator</code>配置生成器（其作用是根据已有信息生成<code>Sidecar</code>需要的 <code>Cluster</code>、<code>Route</code>、<code>Listener</code>，并且会构建相应的filter链）。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">s.EnvoyXdsServer = envoyv2.NewDiscoveryServer(environment,</span><br><span class="line">		istio_networking.NewConfigGenerator(args.Plugins),</span><br><span class="line">		s.ServiceController, s.kubeRegistry, s.configController)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDiscoveryServer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	env *model.Environment,</span></span></span><br><span class="line"><span class="function"><span class="params">	generator core.ConfigGenerator,</span></span></span><br><span class="line"><span class="function"><span class="params">	ctl model.Controller,</span></span></span><br><span class="line"><span class="function"><span class="params">	kubeController *controller.Controller,</span></span></span><br><span class="line"><span class="function"><span class="params">	configCache model.ConfigStoreCache)</span> *<span class="title">DiscoveryServer</span></span> &#123;</span><br><span class="line">	serviceHandler := <span class="function"><span class="keyword">func</span><span class="params">(svc *model.Service, _ model.Event)</span></span> &#123;</span><br><span class="line">		pushReq := &amp;model.PushRequest&#123;</span><br><span class="line">			Full:               <span class="literal">true</span>,</span><br><span class="line">			NamespacesUpdated:  <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;&#123;svc.Attributes.Namespace: &#123;&#125;&#125;,</span><br><span class="line">			ConfigTypesUpdated: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;&#123;schemas.ServiceEntry.Type: &#123;&#125;&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">		out.ConfigUpdate(pushReq)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 往注册中心添加Service变更处理器</span></span><br><span class="line">	ctl.AppendServiceHandler(serviceHandler)</span><br><span class="line">	instanceHandler := <span class="function"><span class="keyword">func</span><span class="params">(si *model.ServiceInstance, _ model.Event)</span></span> &#123;</span><br><span class="line">		out.ConfigUpdate(&amp;model.PushRequest&#123;</span><br><span class="line">			Full:              <span class="literal">true</span>,</span><br><span class="line">			NamespacesUpdated: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;&#123;si.Service.Attributes.Namespace: &#123;&#125;&#125;,</span><br><span class="line">			ConfigTypesUpdated: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;&#123;schemas.ServiceEntry.Type: &#123;&#125;&#125;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	ctl.AppendInstanceHandler(instanceHandler)</span><br><span class="line">	configHandler := <span class="function"><span class="keyword">func</span><span class="params">(c model.Config, _ model.Event)</span></span> &#123;</span><br><span class="line">		pushReq := &amp;model.PushRequest&#123;</span><br><span class="line">			Full:               <span class="literal">true</span>,</span><br><span class="line">			ConfigTypesUpdated: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;&#123;c.Type: &#123;&#125;&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">		out.ConfigUpdate(pushReq)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 往配置中心添加配置变更处理器</span></span><br><span class="line">	<span class="keyword">for</span> _, descriptor := <span class="keyword">range</span> schemas.Istio &#123;</span><br><span class="line">		configCache.RegisterEventHandler(descriptor.Type, configHandler)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="初始化更新下发流程"><a href="#初始化更新下发流程" class="headerlink" title="初始化更新下发流程"></a>初始化更新下发流程</h4><p>创建完 <code>EnvoyXdsServer</code>后，执行其<code>Start</code>方法，开启<code>push</code>通道处理流程：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">Start</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 接收 配置中心、注册中心的配置变更</span></span><br><span class="line">	<span class="keyword">go</span> s.handleUpdates(stopCh)</span><br><span class="line">	<span class="comment">// 周期性刷新Metrics信息</span></span><br><span class="line">	<span class="keyword">go</span> s.periodicRefreshMetrics(stopCh)</span><br><span class="line">	<span class="comment">// 往下发送变更</span></span><br><span class="line">	<span class="keyword">go</span> s.sendPushes(stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，先来看处理变更流程：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">handleUpdates</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// pushChannel接收上层配置中心、注册中心的更新</span></span><br><span class="line">	debounce(s.pushChannel, stopCh, s.Push)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">debounce</span><span class="params">(ch <span class="keyword">chan</span> *model.PushRequest, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, pushFn <span class="keyword">func</span>(req *model.PushRequest)</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">var</span> req *model.PushRequest</span><br><span class="line">	free := <span class="literal">true</span></span><br><span class="line">	freeCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	push := <span class="function"><span class="keyword">func</span><span class="params">(req *model.PushRequest)</span></span> &#123;</span><br><span class="line">		pushFn(req)</span><br><span class="line">		freeCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pushWorker := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	   <span class="comment">// 距离上一次开始防抖动时间开始</span></span><br><span class="line">		eventDelay := time.Since(startDebounce)</span><br><span class="line">		<span class="comment">// 距离上次配置更新间隔时间</span></span><br><span class="line">		quietTime := time.Since(lastConfigUpdateTime)</span><br><span class="line">      <span class="comment">// 大于 10s，100ms</span></span><br><span class="line">		<span class="keyword">if</span> eventDelay &gt;= DebounceMax || quietTime &gt;= DebounceAfter &#123;</span><br><span class="line">			<span class="keyword">if</span> req != <span class="literal">nil</span> &#123;</span><br><span class="line">			   <span class="comment">// ... 打印下发信息</span></span><br><span class="line">				free = <span class="literal">false</span></span><br><span class="line">				<span class="keyword">go</span> push(req)</span><br><span class="line">				req = <span class="literal">nil</span></span><br><span class="line">				debouncedEvents = <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			timeChan = time.After(DebounceAfter - quietTime)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-freeCh:</span><br><span class="line">			free = <span class="literal">true</span></span><br><span class="line">			pushWorker()</span><br><span class="line">		<span class="keyword">case</span> r := &lt;-ch:</span><br><span class="line">			<span class="comment">// ... 对于EDS而言，如果未配置防抖动，且不是全局更新，则立即下发     </span></span><br><span class="line">			lastConfigUpdateTime = time.Now()</span><br><span class="line">			<span class="comment">// 第一次更新事件</span></span><br><span class="line">			<span class="keyword">if</span> debouncedEvents == <span class="number">0</span> &#123;</span><br><span class="line">				timeChan = time.After(DebounceAfter)</span><br><span class="line">				startDebounce = lastConfigUpdateTime</span><br><span class="line">			&#125;</span><br><span class="line">			debouncedEvents++</span><br><span class="line">            <span class="comment">// 合并变更</span></span><br><span class="line">			req = req.Merge(r)</span><br><span class="line">		<span class="keyword">case</span> &lt;-timeChan:</span><br><span class="line">		   <span class="comment">// 时间窗口到来时，下发更新</span></span><br><span class="line">			<span class="keyword">if</span> free &#123;</span><br><span class="line">				pushWorker()</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理变更处理流程是一个<strong>防抖动</strong>的设计，处理流程大致如下：</p>
<ol>
<li>当 <code>配置中心</code> 或者 <code>注册中心</code> 有变更时 会发送到 <strong>pushChannel</strong>；</li>
<li>每个抖动窗口（默认 100ms，<strong>DebounceAfter</strong>）第一次接收更新，设置到期 <code>timer</code>，后续不断接收更新，并合并更新；</li>
<li>当抖动窗口期到期时则调用<code>pushWorker</code>下发更新；</li>
<li>另外通过 变量<code>free</code>和<code>freeCh</code>来防止上一次没下发完后一次就开始了。</li>
</ol>
<p>合并请求主要内容如下（<code>push_context.go/L201</code>）：</p>
<ul>
<li>如果任意一个更新是全局 <strong>Push</strong>，则合并更新即为全局 <strong>Push</strong>；</li>
<li>如果不是全局 <strong>Push</strong>，则合并 <strong>EdsUpdates</strong>信息，标识哪些 <strong>Service</strong> 需要更新；</li>
<li>合并需要更新的目标命名空间；</li>
<li>合并需要更新的配置类型。</li>
</ul>
<p><code>pushWorker</code>最后调用的是 <code>EnvoyXdsServer</code>的<code>Push</code>方法：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">Push</span><span class="params">(req *model.PushRequest)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !req.Full &#123;</span><br><span class="line">	   <span class="comment">// 部分下发，只下发EDS</span></span><br><span class="line">		req.Push = s.globalPushContext()</span><br><span class="line">		<span class="keyword">go</span> s.AdsPushAll(versionInfo(), req)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	oldPushContext := s.globalPushContext()</span><br><span class="line">	<span class="keyword">if</span> oldPushContext != <span class="literal">nil</span> &#123;</span><br><span class="line">		oldPushContext.OnConfigChange()</span><br><span class="line">	&#125;</span><br><span class="line">	t0 := time.Now()</span><br><span class="line">	<span class="comment">// 创建新的PushContext，并基于已有PushContext和请求以及环境初始化新的PushContext</span></span><br><span class="line">	push := model.NewPushContext()</span><br><span class="line">	push.InitContext(s.Env, oldPushContext, req)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据最新的push信息，更新本地缓存</span></span><br><span class="line">	<span class="keyword">if</span> err := s.updateServiceShards(push); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s.updateMutex.Lock()</span><br><span class="line">	s.Env.PushContext = push</span><br><span class="line">	s.updateMutex.Unlock()</span><br><span class="line">  <span class="comment">// 生成版本号</span></span><br><span class="line">	versionLocal := time.Now().Format(time.RFC3339) + <span class="string">"/"</span> + strconv.FormatUint(versionNum.Load(), <span class="number">10</span>)</span><br><span class="line">	versionNum.Inc()</span><br><span class="line">	initContextTime := time.Since(t0)</span><br><span class="line">	versionMutex.Lock()</span><br><span class="line">	version = versionLocal</span><br><span class="line">	versionMutex.Unlock()</span><br><span class="line">	req.Push = push</span><br><span class="line">	<span class="keyword">go</span> s.AdsPushAll(versionLocal, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结其执行流程如下：</p>
<ol>
<li>若部分更新即只有EDS更新，则异步调用<code>AdsPushAll</code>下发；</li>
<li>若全局更新，首先创建出初始化新的Push上下文 <code>PushContext</code>（包含全局信息）；</li>
<li>根据最新的Push上下文更新本地的<code>IstioEndpoint</code>缓存；</li>
<li>生成新的版本号；</li>
<li>最后异步执行 <code>AdsPushAl</code> 下发。</li>
</ol>
<p>继续跟进<code>AdsPushAll</code>方法中：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">AdsPushAll</span><span class="params">(version <span class="keyword">string</span>, req *model.PushRequest)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !req.Full &#123;</span><br><span class="line">	   <span class="comment">// 增量eds更新下发，更新本地缓存。</span></span><br><span class="line">		s.edsIncremental(version, req.Push, req)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	cMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*EdsCluster, <span class="built_in">len</span>(edsClusters))</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> edsClusters &#123;</span><br><span class="line">		cMap[k] = v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> clusterName, edsCluster := <span class="keyword">range</span> cMap &#123;</span><br><span class="line">	   <span class="comment">// 更新本地缓存</span></span><br><span class="line">		s.updateCluster(req.Push, clusterName, edsCluster)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 下发将所有与DiscoveryServer建立的链接XdsConnection和下发请求组队，放入 pushQueue。s.pushQueue.Enqueue(p, req)</span></span><br><span class="line">	s.startPush(req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AdsPushAll</code>首先会根据下发请求更新本地缓存，然后再执行 <code>startPush</code> 进行下发。<code>startPush</code>将所有与DiscoveryServer建立的链接XdsConnection和下发请求组队，放入 pushQueue</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">startPush</span><span class="params">(req *model.PushRequest)</span></span> &#123;</span><br><span class="line">    pending := []*XdsConnection&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> adsClients &#123;</span><br><span class="line">		pending = <span class="built_in">append</span>(pending, v)</span><br><span class="line">	&#125;</span><br><span class="line">	req.Start = time.Now()</span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> pending &#123;</span><br><span class="line">		s.pushQueue.Enqueue(p, req)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>discovery.go/doSendPushes</code>方法会阻塞等待pushQueue的内容：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSendPushes</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, semaphore <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, queue *PushQueue)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		     <span class="comment">// 控制下发的并发度</span></span><br><span class="line">			semaphore &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">             <span class="comment">// 阻塞等待下发			</span></span><br><span class="line">			client, info := queue.Dequeue()</span><br><span class="line">			doneFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				queue.MarkDone(client)</span><br><span class="line">				&lt;-semaphore</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			   <span class="comment">// ...</span></span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="comment">// 向每个链接的下发通道中发送事件</span></span><br><span class="line">				<span class="keyword">case</span> client.pushChannel &lt;- &amp;XdsEvent&#123;</span><br><span class="line">					push:               info.Push,</span><br><span class="line">					edsUpdatedServices: edsUpdates,</span><br><span class="line">					done:               doneFunc,</span><br><span class="line">					start:              info.Start,</span><br><span class="line">					namespacesUpdated:  info.NamespacesUpdated,</span><br><span class="line">					configTypesUpdated: info.ConfigTypesUpdated,</span><br><span class="line">					noncePrefix:        info.Push.Version,</span><br><span class="line">				&#125;:</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				<span class="keyword">case</span> &lt;-client.stream.Context().Done(): <span class="comment">// 连接断开					doneFunc()</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="初始化集群注册器"><a href="#初始化集群注册器" class="headerlink" title="初始化集群注册器"></a>初始化集群注册器</h3><p><code>Pilot</code> 支持创建多集群注册中心，通过配置<code>istio/multiCluster=true</code> <strong>Secrets</strong> 类型，可以<code>Pilot</code>对接多<code>k8s</code>集群。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartSecretController</span><span class="params">(k8s kubernetes.Interface,</span></span></span><br><span class="line"><span class="function"><span class="params">    // ...</span></span></span><br><span class="line"><span class="function"><span class="params">	namespace <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	clusterStore := newClustersStore()</span><br><span class="line">	controller := NewController(k8s, namespace, clusterStore, addCallback, removeCallback)</span><br><span class="line">	<span class="keyword">go</span> controller.Run(stopCh)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewController</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	kubeclientset kubernetes.Interface,</span></span></span><br><span class="line"><span class="function"><span class="params">	namespace <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	cs *ClusterStore,</span></span></span><br><span class="line"><span class="function"><span class="params">	addCallback addSecretCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">	removeCallback removeSecretCallback)</span> *<span class="title">Controller</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Secret的Informer，监听 带`istio/multiCluster=true`d的Secret资源</span></span><br><span class="line">	secretsInformer := cache.NewSharedIndexInformer(</span><br><span class="line">		&amp;cache.ListWatch&#123;</span><br><span class="line">			ListFunc: <span class="function"><span class="keyword">func</span><span class="params">(opts meta_v1.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line">				opts.LabelSelector = MultiClusterSecretLabel + <span class="string">"=true"</span></span><br><span class="line">				<span class="keyword">return</span> kubeclientset.CoreV1().Secrets(namespace).List(opts)</span><br><span class="line">			&#125;,</span><br><span class="line">			WatchFunc: <span class="function"><span class="keyword">func</span><span class="params">(opts meta_v1.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</span><br><span class="line">				opts.LabelSelector = MultiClusterSecretLabel + <span class="string">"=true"</span></span><br><span class="line">				<span class="keyword">return</span> kubeclientset.CoreV1().Secrets(namespace).Watch(opts)</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		&amp;corev1.Secret&#123;&#125;, <span class="number">0</span>, cache.Indexers&#123;&#125;,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	controller := &amp;Controller&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		queue:          queue,</span><br><span class="line">		addCallback:    addCallback,</span><br><span class="line">		removeCallback: removeCallback,</span><br><span class="line">	&#125;</span><br><span class="line">	secretsInformer.AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			key, err := cache.MetaNamespaceKeyFunc(obj)</span><br><span class="line">			queue.Add(key)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> controller</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> c.informer.Run(stopCh)</span><br><span class="line">	wait.Until(c.runWorker, <span class="number">5</span>*time.Second, stopCh)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建集群</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">addMemberCluster</span><span class="params">(secretName <span class="keyword">string</span>, s *corev1.Secret)</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建跨集群注册服务流程如下：</p>
<ol>
<li>向当前对接k8s集群添加 带有<code>istio/multiCluster=true</code>的<strong>Secret</strong>资源；</li>
<li><strong>Pilot</strong> 获取此配置后，解析配置，并根据配置创建对应<code>k8s</code>集群的<code>client</code>，并基于此创建相应的注册器。</li>
</ol>
<p>初始化完所有组件后，调用<code>Server.Start</code>方法执行之前注入的<code>StartFunc</code>。<br>到此，<strong>Pilot</strong> 的初始化过程就结束了。</p>
<h3 id="初始化-ControlZ"><a href="#初始化-ControlZ" class="headerlink" title="初始化 ControlZ"></a>初始化 <code>ControlZ</code></h3><p><code>Pilot</code> 里挺有意思的一个设计。作用是开启一个端口向外暴露运维查询界面：<a href="https://istio.io/docs/ops/diagnostic-tools/controlz/" target="_blank" rel="noopener">官方介绍</a>。<br>目前支持：</p>
<ul>
<li><strong>ScopeTopic：</strong> 查询和修改日志级别</li>
<li><strong>MemTopic：</strong> 查询内存统计、强制GC</li>
<li><strong>ProcTopic：</strong>查询进程执行情况：进程ID、协程数、hostName等</li>
<li><strong>ArgsTopic：</strong>启动参数</li>
<li><strong>MetricsTopic：</strong> metric信息</li>
<li>…</li>
</ul>
<p>同时该机制支持组件拓展，比如配置服务可以通过该机制对外暴露接口查询信息。目前，<code>McpController</code>以及<code>sseMcpController</code>（组合服务MCP控制器）也是通过它来暴露查询信息接口的：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *configzTopic)</span> <span class="title">Activate</span><span class="params">(context fw.TopicContext)</span></span> &#123;</span><br><span class="line">	l := template.Must(context.Layout().Clone())</span><br><span class="line">	c.tmpl = template.Must(l.Parse(<span class="keyword">string</span>(assets.MustAsset(<span class="string">"templates/config.html"</span>))))</span><br><span class="line">	_ = context.HTMLRouter().StrictSlash(<span class="literal">true</span>).NewRoute().Path(<span class="string">"/"</span>).HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		d := c.collectData()</span><br><span class="line">		fw.RenderHTML(w, c.tmpl, d)</span><br><span class="line">	&#125;)</span><br><span class="line">	_ = context.JSONRouter().StrictSlash(<span class="literal">true</span>).NewRoute().Methods(<span class="string">"GET"</span>).Path(<span class="string">"/"</span>).HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		d := c.collectData()</span><br><span class="line">		fw.RenderJSON(w, http.StatusOK, d)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *configzTopic)</span> <span class="title">collectData</span><span class="params">()</span> *<span class="title">data</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;data&#123;</span><br><span class="line">		ID:             c.topic.ID(),</span><br><span class="line">		Metadata:       c.topic.Metadata(), <span class="comment">// mcp元数据</span></span><br><span class="line">		Collections:    c.topic.Collections(), <span class="comment">// mcp请求的资源集合包含版本信息</span></span><br><span class="line">		LatestRequests: c.topic.SnapshotRequestInfo(), <span class="comment">// 最近一组已知请求结果的快照信息</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CtrolZ</code>提供 接口<code>ctrlz.RegisterTopic(CreateTopic(topic)</code>来拓展信息暴露</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结启动过程大致如下：<br><img src="/media/15766110366375.jpg" alt=""></p>
<ol>
<li>根据参数创建 <code>k8s</code> Client；</li>
<li>从配置地址中获取 <strong>mesh</strong> 配置，并监听文件变更；</li>
<li>从配置地址获取 <strong>mesh</strong> 网络配置，并监听变更；</li>
<li>初始化配置控制器，支持文件配置、k8s配置、MCP协议配置服务；</li>
<li>初始化注册服务控制器，支持k8s、consul、实现MCP协议的拓展注册中心并且将配置控制器也包装成注册中心；</li>
<li>初始化发现服务，聚合之前初始化的控制器对外提供服务，包括http查询服务以及对<code>sidecar</code>服务的grpc服务；</li>
<li>初始化集群注册服务，使得pilot可以对接多k8s集群；</li>
<li></li>
<li>初始化所有组件后，调用初始化过程中添加的<code>StartFunc</code>开启所有组件的执行流程。</li>
</ol>
<h2 id="信息拉取与下发"><a href="#信息拉取与下发" class="headerlink" title="信息拉取与下发"></a>信息拉取与下发</h2><p>上一节介绍过，<code>DiscoveryServer.StreamAggregatedResources</code>用来接收客户端请求。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">StreamAggregatedResources</span><span class="params">(stream ads.AggregatedDiscoveryService_StreamAggregatedResourcesServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 从grpc stream上下文中获取 连接信</span></span><br><span class="line">    peerInfo, ok := peer.FromContext(stream.Context())</span><br><span class="line">    <span class="comment">//  初始化Push上下文，若是第一次，则会根据之前构建的Enviroment属性里面的 注册服务和配置服务 的内容初始化下全局的缓存信息</span></span><br><span class="line">    err := s.globalPushContext().InitContext(s.Env, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// 将每个sidecar对应stream、节点地址包装成XdsConnection，其会在下发时被使用</span></span><br><span class="line">    con := newXdsConnection(peerAddr, stream)</span><br><span class="line">    <span class="comment">// 开启 异步接收代理（sidecar、gateray）通过Stream发送过来的信息</span></span><br><span class="line">    <span class="keyword">go</span> receiveThread(con, reqChannel, &amp;receiveError)</span><br><span class="line">    <span class="comment">// 处理流程的核心部分：</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="comment">// 对于来自于 Sidecar的请求</span></span><br><span class="line">		<span class="keyword">case</span> discReq, ok := &lt;-reqChannel:</span><br><span class="line">		   <span class="comment">// 如果是第一次，代理会带上其自身节点信息 Node属性</span></span><br><span class="line">		  <span class="comment">// 使用解析出来的信息填充 XdsConnection</span></span><br><span class="line">			<span class="keyword">if</span> discReq.Node != <span class="literal">nil</span> &amp;&amp; discReq.Node.Id != <span class="string">""</span> &#123;</span><br><span class="line">				err = s.initConnectionNode(discReq.Node, con)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">switch</span> discReq.TypeUrl &#123;</span><br><span class="line">    			<span class="keyword">case</span> ClusterType:</span><br><span class="line">    				con.CDSWatch = <span class="literal">true</span></span><br><span class="line">    				<span class="comment">// 首先，跟据节点信息 构建envoy.Cluster信息</span></span><br><span class="line">    				<span class="comment">// 跟据Cluster构建DiscoveryResponse通过Stream返回代理</span></span><br><span class="line">    				s.pushCds(con, s.globalPushContext(), versionInfo())</span><br><span class="line">    			<span class="keyword">case</span> ListenerType:</span><br><span class="line">        			con.LDSWatch = <span class="literal">true</span></span><br><span class="line">        			<span class="comment">// 构建Listener信息</span></span><br><span class="line">        			<span class="comment">// 构建DiscoveryResponse通过Stream返回代理</span></span><br><span class="line">        			err := s.pushLds(con, s.globalPushContext(), versionInfo())</span><br><span class="line">        		<span class="keyword">case</span> RouteType:</span><br><span class="line">        		  <span class="comment">//...</span></span><br><span class="line">        		  err := s.pushRoute(con, s.globalPushContext(), versionInfo())</span><br><span class="line">        		<span class="keyword">case</span> EndpointType:</span><br><span class="line">        		  clusters := discReq.GetResourceNames()</span><br><span class="line">        		  <span class="keyword">for</span> _, cn := <span class="keyword">range</span> con.Clusters &#123;</span><br><span class="line">        		      s.removeEdsCon(cn, con.ConID)</span><br><span class="line">        		  &#125;</span><br><span class="line">        		  <span class="keyword">for</span> _, cn := <span class="keyword">range</span> clusters &#123;</span><br><span class="line">        		      s.getOrAddEdsCluster(cn, con.ConID, con)</span><br><span class="line">        		  &#125;</span><br><span class="line">        		  err := s.pushEds(s.globalPushContext(), con, versionInfo(), <span class="literal">nil</span>)</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">if</span> !con.added &#123;</span><br><span class="line">				con.added = <span class="literal">true</span></span><br><span class="line">				s.addCon(con.ConID, con)</span><br><span class="line">				<span class="keyword">defer</span> s.removeCon(con.ConID, con)</span><br><span class="line">			&#125;</span><br><span class="line">        <span class="keyword">case</span> pushEv := &lt;-con.pushChannel:</span><br><span class="line">            <span class="comment">// 接收更新下发</span></span><br><span class="line">            err := s.pushConnection(con, pushEv)</span><br><span class="line">            pushEv.done()</span><br></pre></td></tr></table></figure>
<p>总结其实现流程如下：</p>
<ol>
<li>首先 <code>StreamAggregatedResources</code> 是代理（Envoy， 可以是Sidecar角色也可以是Gateway角色）的入口，接收代理的Grpc Stream；</li>
<li>如果全局PushContext未初始化好，则进行一次初始化；</li>
<li>根据Stream信息构建 <code>XdsConnection</code></li>
<li>构建一个协程用于接收代理的请求，当请求到达时，丢进reqChannel中；</li>
<li>构建一个循环，同时接收代理的请求和要下发给代理的XdsEvent；</li>
<li><strong>对于请求：</strong><ul>
<li>当是首次接收代理的请求时，代理请求中会携带<code>Node</code>信息，Pilot会解析此信息并根据<code>Controller</code>查询相关信息来填充 <code>XdsConnection</code> 信息(代理的类型（sidecar\gateway）、ip地址、版本号、节点标签、关联的<code>ServiceInstance</code>)；</li>
<li>其后根据请求的<code>TypeUrl</code>判断请求类型进行相应处理；</li>
<li>对于每种类型请求<ul>
<li>会将对应的<code>XdsConnection.XXXWatch</code>置为True，表示代理对这种类型数据敏感，当有这种类型数据变更时，下发给它；</li>
<li>同时需要注意的是，下发的时候会带上版本号（<code>VersionInfo</code>）；</li>
<li>根据 <code>XdsConnection</code> 信息构建相应类型数据；（<code>pushXds</code>）</li>
<li>根据数据构建 <code>DiscoveryResponse</code>进行下发。</li>
</ul>
</li>
<li>最后会将<code>XdsConnection</code> 添加到<code>DiscoveryServer</code>中。</li>
</ul>
</li>
<li><strong>数据下发</strong>（之前提到：当信息变更时会捞出<code>DiscoveryServer</code>中保存的所有<code>XdsConnection</code>，然后往其<code>pushChannel</code>中发送<code>XdsEvent</code>）<ul>
<li>数据下发接口最终会调用<code>pushConnection</code>方法，其处理流程大致如下：<ul>
<li>如果只是Eds信息更新，则只下发<code>pushEds</code>；</li>
<li>如不是，则会依次下发 <code>CDS</code>、<code>EDS</code>、<code>LDS</code>、<code>Route</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="拓展性"><a href="#拓展性" class="headerlink" title="拓展性"></a>拓展性</h2><p>提到<code>Pilot</code>的拓展性，首先想到其支持对接实现<code>MCP</code>协议的配置中心和注册中心。下一章将首先介绍<code>MCP</code>协议，然后再结合<code>Galley</code>实例来讲解<code>MCP</code>的工作原理。<a href="https://github.com/istio/api/tree/master/mcp?spm=a2c4e.10696291.0.0.3b0419a4nAPVr2" target="_blank" rel="noopener">官方文档</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2019/10/12/istio/1.istio-%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.png">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/12/istio/1.istio-%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">Istio 简介</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-12 00:00:00" itemprop="dateCreated datePublished" datetime="2019-10-12T00:00:00+08:00">2019-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-13 19:02:53" itemprop="dateModified" datetime="2020-02-13T19:02:53+08:00">2020-02-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/istio/" itemprop="url" rel="index">
                    <span itemprop="name">istio</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a><a href="https://github.com/istio/istio" target="_blank" rel="noopener">Istio</a></h1><p>  <strong>Istio</strong> 是<code>An open platform to connect, manage, and secure microservices.</code>（用于连接、管理、保护微服务的开发平台)。由Google|Lyft|IBM联合开发，是当下开源社区最火的ServiceMesh项目。<br>  由于作者从事ServiceMesh相关研发工作，因此决定抽出时间来细致研究<code>Istio</code>核心原理，并落地本系列文章。<br>  本系列文章将详细讲解如下内容：<br>    1. <code>Istio</code> 整体架构&amp;核心工作流程<br>    2. <code>Pilot</code> 控制中枢源码解析<br>    2. <code>Galley</code><strong>&amp;</strong><code>MCP</code>源码解析<br>    3. <code>Mixer</code> 原理解析<br>    4. <code>Envoy</code> 原理解析<br>    5. 总结&amp;讨论</p>
<p>特别说明，本文内容基于<code>Istio@1.4.2</code>进行的源码分析。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2019/08/18/k8s/7.k8s-kubetl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.png">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/18/k8s/7.k8s-kubetl/" class="post-title-link" itemprop="url">k8s/7.k8s-kubetl</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-18 21:32:36" itemprop="dateCreated datePublished" datetime="2019-08-18T21:32:36+08:00">2019-08-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-13 20:55:41" itemprop="dateModified" datetime="2020-02-13T20:55:41+08:00">2020-02-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zamperini"
      src="/images/avator.png">
  <p class="site-author-name" itemprop="name">Zamperini</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/DorgenJones" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;DorgenJones" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:dblpfilter@163.com" title="E-Mail → mailto:dblpfilter@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/1938368215" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;1938368215" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zamperini</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
