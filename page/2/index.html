<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.3">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.3" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Hexo, NexT" />


<meta property="og:type" content="website">
<meta property="og:title" content="Zamperini">
<meta property="og:url" content="https://dorgenjones.github.io/page/2/index.html">
<meta property="og:site_name" content="Zamperini">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zamperini">
<meta name="twitter:card" content="summary">






  <link rel="canonical" href="https://dorgenjones.github.io/page/2/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>Zamperini</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Zamperini</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2019/11/23/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/etcd/5.etcd-%E4%BA%8B%E5%8A%A1%E8%AF%B7%E6%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/23/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/etcd/5.etcd-%E4%BA%8B%E5%8A%A1%E8%AF%B7%E6%B1%82/" itemprop="url">ETCD事务请求</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-23T00:00:00+08:00">2019-11-23</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/etcd/" itemprop="url" rel="index"><span itemprop="name">etcd</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="4-事务请求"><a href="#4-事务请求" class="headerlink" title="4. 事务请求"></a>4. 事务请求</h1><p>[TOC]</p>
<p>本节我们将讲述 <code>etcd</code>集群的事务请求处理过程。首先我们将以<code>put</code>操作为例来讲解一般性事务请求过程。其次，我们将介绍 <code>etcd</code>特有的线性一致性读请求过程。</p>
<h2 id="put-请求"><a href="#put-请求" class="headerlink" title="put 请求"></a>put 请求</h2><p>通过 <code>etcdctl put ty dj</code> 命令，向本地监听<code>2380</code>端口的节点发送 写请求。<br>该请求为<code>GRPC</code>请求，会中转到<code>quotaKVServer</code>进行处理。</p>
<h3 id="Leader接收请求，并广播消息"><a href="#Leader接收请求，并广播消息" class="headerlink" title="Leader接收请求，并广播消息"></a><code>Leader</code>接收请求，并广播消息</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">quotaKVServer.Put</span><br><span class="line">|- s.qa.check(ctx,r) <span class="comment">//检查是否满足quota,即是否有足够的内存，如果没有则忽略请求，并发报警</span></span><br><span class="line">|- EtcdServer.Put <span class="comment">// 调用EtcdServer进行写</span></span><br><span class="line">    |- s.raftRequest(ctx, pb.InternalRaftRequest&#123;Put: r&#125;) <span class="comment">// EtcdServer将请求进行包装成 `InternalRaftRequest`</span></span><br><span class="line">      并调用<span class="string">`raftRequest`</span>进行请求，并等待获取结果</span><br><span class="line">        |- s.processInternalRaftRequestOnce<span class="comment">// 最终会调用此方法  </span></span><br><span class="line">            |- <span class="keyword">if</span> ci &gt; ai+maxGapBetweenApplyAndCommitIndex <span class="comment">//首先检查apply索引和 commit索引是否相差太大，若太大则忽略请求（自我保护机制）</span></span><br><span class="line">            |- 生成请求头，并生成请求ID <span class="string">`s.reqIDGen.Next()`</span></span><br><span class="line">            |- r.Marshal() <span class="comment">// 对请求进行编码</span></span><br><span class="line">            |- ch := s.w.Register(id) <span class="comment">// 注册请求响应回调</span></span><br><span class="line">            |- err = s.r.Propose(cctx, data) <span class="comment">// 向 raftNode 发起提议，申请写入数据</span></span><br><span class="line">            |- <span class="keyword">select</span> &#123; <span class="comment">// 等待结果，或超时</span></span><br><span class="line">            	   <span class="keyword">case</span> x := &lt;-ch:</span><br><span class="line">            		  <span class="keyword">return</span> x.(*applyResult), <span class="literal">nil</span></span><br><span class="line">            		  <span class="keyword">case</span> timeout</span><br><span class="line">            	&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就进入了主要的处理流程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node.Propose</span><br><span class="line">|- n.stepWait(ctx, pb.Message&#123;Type: pb.MsgProp, Entries: []pb.Entry&#123;&#123;Data: data&#125;&#125;&#125;) <span class="comment">// 将请求包装成 `MsgProp`消息</span></span><br><span class="line">    |- n.stepWithWaitOption</span><br><span class="line">        |- pm := msgWithResult&#123;m: m&#125; <span class="comment">// 将消息再一次封装</span></span><br><span class="line">        |- 将消息传递给 通道<span class="string">`n.propc`</span></span><br></pre></td></tr></table></figure>
<p>可以看出 将请求两层封装之后传递给通道<code>n.propc</code>。<br>在<code>node</code>的循环中，其会监听<code>proc</code>通道，当有消息到来时：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">node.start | <span class="number">360</span>+L</span><br><span class="line">|- m.From = r.id <span class="comment">// 将自己的id设置到消息的Form字段里</span></span><br><span class="line">|- err := r.Step(m) <span class="comment">// 再交给raft处理</span></span><br><span class="line">    |- r.step(r, m) <span class="comment">//此处就会根据节点的角色不同进行不同处理，若本节点是Follower则会转交给Leader节点进行处理，然后再进行如上的流程。这里假设本节点是主节点 即 stepLeader方法</span></span><br><span class="line">        |- r.appendEntry(m.Entries...) <span class="comment">// 将该记录追加到`raftLog`中</span></span><br><span class="line">            |- r.increaseUncommittedSize(es) <span class="comment">// 校验是否超过上界</span></span><br><span class="line">            |- r.raftLog.<span class="built_in">append</span>(es...) <span class="comment">// 追加到日志中记录下来（unstable中）</span></span><br><span class="line">            |- r.getProgress(r.id).maybeUpdate(li) <span class="comment">//更新本节点的复制进度</span></span><br><span class="line">            |- r.maybeCommit() <span class="comment">//对于单节点，尝试更新一次 raftLog中的 commit索引。//大多数节点都到达的索引</span></span><br><span class="line">        |- r.bcastAppend()  <span class="comment">// 广播消息</span></span><br><span class="line">            |- 对于每个其他成员节点，都执行 <span class="string">`r.sendAppend(id)`</span></span><br><span class="line">                |- pr := r.getProgress(to) <span class="comment">//获取节点的复制进程</span></span><br><span class="line">                |- term, errt := r.raftLog.term(pr.Next - <span class="number">1</span>) <span class="comment">// p.Next为该节点下次复制的索引号</span></span><br><span class="line">                |- ents, erre := r.raftLog.entries(pr.Next, r.maxMsgSize) <span class="comment">// 获取需要复制给对方节点的记录</span></span><br><span class="line">                |- 叫这些信息都封装成<span class="string">`MsgApp`</span>消息，进行发送</span><br><span class="line">                    |- r.send(m)</span><br><span class="line">                        |- r.msgs = <span class="built_in">append</span>(r.msgs, m) <span class="comment">// 将消息追加到了r.msgs中</span></span><br></pre></td></tr></table></figure>
<p>当本节点将需要发送给每个成员节点的消息都放到<code>r.msgs</code>后，<code>node.run</code>会进入下一轮循环。此时：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">node.run</span><br><span class="line">|- rd = newReady(r, prevSoftSt, prevHardSt) <span class="comment">// 准备准备好发送的消息结构体 Ready</span></span><br><span class="line">    |- rd := Ready&#123;</span><br><span class="line">    		Entries:          r.raftLog.unstableEntries(),</span><br><span class="line">    		CommittedEntries: r.raftLog.nextEnts(),</span><br><span class="line">    		Messages:         r.msgs, <span class="comment">// 消息在此进行包装</span></span><br><span class="line">    	&#125;</span><br><span class="line">|- readyc = n.readyc    	</span><br><span class="line">|- <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> readyc &lt;- rd: <span class="comment">// 此处即将消息传递到 n.readyc通道中</span></span><br><span class="line">     <span class="comment">//完成传递后，会进行一些状态的更新</span></span><br><span class="line">     <span class="keyword">if</span> index := rd.appliedCursor(); index != <span class="number">0</span> &#123;</span><br><span class="line">			applyingToI = index <span class="comment">// 提交消息的最大索引号</span></span><br><span class="line">		&#125;</span><br><span class="line">     advancec = n.advancec <span class="comment">// 赋值后，待本次消息发送完成后，进入下次循环。（等待 `raftNode`的通知）</span></span><br><span class="line">     <span class="keyword">case</span> &lt;-advancec:</span><br><span class="line">        <span class="comment">// 得到通知后，即知道之前的已提交的消息都已经发送出去了可以应用了</span></span><br><span class="line">			<span class="keyword">if</span> applyingToI != <span class="number">0</span> &#123;</span><br><span class="line">				r.raftLog.appliedTo(applyingToI)</span><br><span class="line">				applyingToI = <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送到<code>n.readyc</code>通道中的消息，会被<code>raftNode</code>捕获：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> rd := &lt;-r.Ready():</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">			<span class="keyword">if</span> islead &#123; <span class="comment">// 发送消息给相应节点</span></span><br><span class="line">		      r.transport.Send(r.processMessages(rd.Messages))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">			r.Advance() <span class="comment">// 这里是通知 node.advancec 可以处理下一个循坏</span></span><br><span class="line">    <span class="comment">// ...   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是<code>Leader</code>角色接收到<code>Put</code>请求，然后自身进行处理，然后向 <code>Follower</code>发送<code>MsgApp</code>消息。</p>
<h3 id="Follower接收到Leader的广播，进行处理回复"><a href="#Follower接收到Leader的广播，进行处理回复" class="headerlink" title="Follower接收到Leader的广播，进行处理回复"></a><code>Follower</code>接收到<code>Leader</code>的广播，进行处理回复</h3><p>当<code>Follower</code>收到消息后，会执行<code>EtcdServer.Process</code>方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EtcdServer.Process</span><br><span class="line">|- node.Step</span><br><span class="line">    |- node.step</span><br><span class="line">        |- n.recvc &lt;- m <span class="comment">// 最终传递给node.recvc通道</span></span><br><span class="line">            |- raft.Step <span class="comment">// node监听node.recvc，接收到消息后调用 raft执行逻辑</span></span><br><span class="line">            |- stepFollower</span><br><span class="line">                |- r.handleAppendEntries(m) <span class="comment">//处理追加记录</span></span><br><span class="line">                    |- r.raftLog.maybeAppend(m.Index, m.LogTerm, m.Commit, m.Entries...) <span class="comment">// 尝试追加消息</span></span><br><span class="line">                        |- l.matchTerm(index, logTerm) <span class="comment">// 校验 term 和index信息是否跟本节点一致</span></span><br><span class="line">                        |- l.findConflict(ents) <span class="comment">//找出冲突的索引号</span></span><br><span class="line">                        |- l.<span class="built_in">append</span>(ents[ci-offset:]...) <span class="comment">// 追加记录到raftLog中(unstable中)</span></span><br><span class="line">                        |- l.commitTo(min(committed, lastnewi)) <span class="comment">// 更新 commitId</span></span><br><span class="line">                    |- r.send(pb.Message&#123;To: m.From, Type: pb.MsgAppResp, Index: mlastIndex&#125;) <span class="comment">// 向 Leader反馈 信息`MsgAppResp`和索引号</span></span><br><span class="line">                        |- r.msgs = <span class="built_in">append</span>(r.msgs, m) <span class="comment">// 将消息追加到了r.msgs中</span></span><br></pre></td></tr></table></figure>
<p>发送的消息最终被 <code>raftNode</code>接收:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> rd := &lt;-r.Ready():</span><br><span class="line">        notifyc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">			ap := apply&#123;</span><br><span class="line">				entries:  rd.CommittedEntries, <span class="comment">// raft中已经提交的消息，</span></span><br><span class="line">				snapshot: rd.Snapshot,</span><br><span class="line">				notifyc:  notifyc,</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 将Committed数据应用到</span></span><br><span class="line">			updateCommittedIndex(&amp;ap, rh) <span class="comment">// 更新 EtcdServer的CommitId</span></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> r.applyc &lt;- ap: <span class="comment">// 将应用信息传递到 raftNode.applyc通道中，其被EtcdServer所监听。后续详解</span></span><br><span class="line">			&#125;</span><br><span class="line">			r.storage.Save(rd.HardState, rd.Entries) <span class="comment">// 实际调用WAL的Save方法，将记录写入到文件中 // ... wal</span></span><br><span class="line">			r.raftStorage.Append(rd.Entries) <span class="comment">// 将消息追加到 MemoryStorage中  </span></span><br><span class="line">		   <span class="keyword">if</span> !islead &#123;</span><br><span class="line">		      notifyc &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		      r.transport.Send(msgs)</span><br><span class="line">		   &#125;</span><br><span class="line">			r.Advance() <span class="comment">// 这里是通知 node.advancec 可以处理下一个循坏</span></span><br><span class="line">    <span class="comment">// ...   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看<code>EtcdServer</code>接收到<code>apply</code>消息后的处理：<br>再来看 <code>EtcdServer</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">EtcdServer/<span class="number">1020</span>L+-</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> ap := &lt;-s.r.apply():</span><br><span class="line">		f := <span class="function"><span class="keyword">func</span><span class="params">(context.Context)</span></span> &#123; s.applyAll(&amp;ep, &amp;ap) &#125;</span><br><span class="line">		sched.Schedule(f) <span class="comment">// 顺序调用`s.appAll`方法</span></span><br><span class="line">		s.applySnapshot(ep, apply)</span><br><span class="line">	   s.applyEntries(ep, apply) <span class="comment">//这里是应用服务最重要的地方</span></span><br><span class="line">	   |- 首先筛选出需要应用到此<span class="string">`EtcdServer`</span>的记录</span><br><span class="line">	   |- s.apply(ents, &amp;ep.confState)<span class="comment">//然后将这些记录应用到 `EtcdServer`中</span></span><br><span class="line">	       |- 对于正常的记录（<span class="string">`EntryNormal`</span>类型）</span><br><span class="line">	           |- <span class="keyword">case</span> raftpb.EntryNormal:</span><br><span class="line">            		s.applyEntryNormal(&amp;e)</span><br><span class="line">            		  |- s.consistIndex.setConsistentIndex(e.Index)<span class="comment">// 设置一致性索引号</span></span><br><span class="line">            		  |- 解码消息 Unmarshal</span><br><span class="line">            		  |- ar = s.applyV3.Apply(&amp;raftReq) <span class="comment">// 应用到应用数据存储中</span></span><br><span class="line">            		  |- s.w.Trigger(id, ar) <span class="comment">// 回调，通知该记录对应的请求</span></span><br><span class="line">           		    s.setAppliedIndex(e.Index)</span><br><span class="line">           			s.setTerm(e.Term)</span><br><span class="line"></span><br><span class="line">    |- &lt;-apply.notifyc <span class="comment">// 接到raftNode的通知已经完成发送等操作</span></span><br><span class="line">    |- s.triggerSnapshot(ep) <span class="comment">// 检查是否有 SnapshotCount操作，如果有则进行快照</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结起来，<code>Follower</code>节点接收到<code>Leader</code>节点的<code>MsgApp</code>应用到其节点中，然后向反馈<code>Leader</code> <code>MsgAppResp</code>消息，并带上自己的最大记录号。</p>
<h3 id="Leader收到Follower的回复进行处理"><a href="#Leader收到Follower的回复进行处理" class="headerlink" title="Leader收到Follower的回复进行处理"></a><code>Leader</code>收到<code>Follower</code>的回复进行处理</h3><p><code>Leader</code>收到<code>MsgAppResp</code>消息后，经过层层传递到<code>stepLeader</code>方法中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|- pr := r.getProgress(m.From) <span class="comment">// 获取该节点的进度</span></span><br><span class="line">|- <span class="keyword">switch</span> m.Type &#123;</span><br><span class="line">	<span class="keyword">case</span> pb.MsgAppResp:</span><br><span class="line">	   pr.RecentActive = <span class="literal">true</span> <span class="comment">//设置该节点状态</span></span><br><span class="line">	   |- pr.maybeUpdate(m.Index) <span class="comment">//更新该节点在 主节点中的进度信息（已经复制到什么位置了）</span></span><br><span class="line">	   |- 根据该节点的状态进行相应操作</span><br><span class="line">	   |- <span class="keyword">if</span> r.maybeCommit() &#123; <span class="comment">// 判断是否可以提交</span></span><br><span class="line">			r.bcastAppend()  <span class="comment">// 若可以提交，则广播消息</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们先来看判断是否可以提交的逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">raft.maybeCommit</span><br><span class="line">mis := r.matchBuf[:<span class="built_in">len</span>(r.prs)]</span><br><span class="line">idx := <span class="number">0</span></span><br><span class="line"><span class="comment">// 首先将每个成员节点确认的同步消息索引号放入数组中</span></span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> r.prs &#123;</span><br><span class="line">	mis[idx] = p.Match</span><br><span class="line">	idx++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按索引号排序</span></span><br><span class="line">sort.Sort(mis)</span><br><span class="line"><span class="comment">// 获取 len(mis)-r.quorum()位的索引位置</span></span><br><span class="line">mci := mis[<span class="built_in">len</span>(mis)-r.quorum()]</span><br><span class="line"><span class="keyword">return</span> r.raftLog.maybeCommit(mci, r.Term) <span class="comment">//判断是否比raftLog中的CommitId大，若是则表示有数据可以提交</span></span><br><span class="line">    |- <span class="keyword">if</span> maxIndex &gt; l.committed &amp;&amp; l.zeroTermOnErrCompacted(l.term(maxIndex)) == term &#123;</span><br><span class="line">		l.commitTo(maxIndex) <span class="comment">// 更新commitId</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>r.bcastAppend()</code>的处理过程之前以及介绍过，其会构造一遍<code>Ready</code>数据结构，带上<code>CommitedEntries</code>提交的数据、其他节点未同步的<code>Entries</code>，传递给<code>raftNode</code>。<code>raftNode</code>接收到此消息后，会执行与上面分析的<code>Follower</code>的逻辑类似。</p>
<h2 id="线性一致性读"><a href="#线性一致性读" class="headerlink" title="线性一致性读"></a>线性一致性读</h2><p>线性一致性读和一般的读不通的时候，会在进行真正的读请求之前，先与其他节点进行一个check，查看当前集群主是否发生了变化。通过<code>etcdctl get ty</code>命令，向监听本地<code>2380</code>端口的节点发送<code>GRPC</code>请求，会被中转到<code>quotaKVServer</code>上。<br><code>get</code>请求在<code>etcdctl</code>中会被转换成<code>Range</code>请求。<code>quotaKVServer</code>最终会调用<code>EtcdServer.Range</code>方法。</p>
<h3 id="Leader节点收到请求后，广播心跳消息"><a href="#Leader节点收到请求后，广播心跳消息" class="headerlink" title="Leader节点收到请求后，广播心跳消息"></a><code>Leader</code>节点收到请求后，广播心跳消息</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">quotaKVServer</span><br><span class="line">|- kvServer.Range</span><br><span class="line">    |- EtcdServer.Range</span><br><span class="line">        |- <span class="keyword">if</span> !r.Serializable &#123; <span class="comment">//是否线性一致性</span></span><br><span class="line">    		err = s.linearizableReadNotify(ctx)</span><br><span class="line">    		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    		&#125;</span><br><span class="line">    		resp, err = s.applyV3Base.Range(<span class="literal">nil</span>, r)</span><br><span class="line">    	&#125;</span><br></pre></td></tr></table></figure>
<p>线性一致性读的主要逻辑体现在 <code>s.linearizableReadNotify</code>中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s.linearizableReadNotify  <span class="comment">// 线性读通知</span></span><br><span class="line">|- nc := s.readNotifier <span class="comment">// 用于通知读协程可以进行读操作</span></span><br><span class="line">|- <span class="keyword">select</span> &#123;</span><br><span class="line">	   <span class="keyword">case</span> s.readwaitc &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;: <span class="comment">//通知读等待通道</span></span><br><span class="line">	&#125;</span><br><span class="line">|- <span class="keyword">select</span> &#123;</span><br><span class="line">	   <span class="keyword">case</span> &lt;-nc.c: <span class="comment">// 等待读状态通知</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>EtcdServer</code>在启动的时候会启动<code>linearizableReadLoop</code>线性一致性读循环。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">linearizableReadLoop</span><br><span class="line">|- ctxToSend := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">8</span>)</span><br><span class="line">|- id1 := s.reqIDGen.Next()</span><br><span class="line">|- binary.BigEndian.PutUint64(ctxToSend, id1)</span><br><span class="line">|- <span class="keyword">for</span> ;; &#123;</span><br><span class="line">     <span class="keyword">select</span> &#123;</span><br><span class="line">    	<span class="keyword">case</span> &lt;-s.readwaitc: <span class="comment">// 当接收到线性一致性读请求后，循环就可以往下走</span></span><br><span class="line">    	&#125;</span><br><span class="line">    	nextnr := newNotifier() <span class="comment">// 创建新的读通知器，给下一个读请求使用</span></span><br><span class="line">    	nr := s.readNotifier</span><br><span class="line">		s.readNotifier = nextnr</span><br><span class="line">		err := s.r.ReadIndex(cctx, ctxToSend) <span class="comment">// 调用`node.ReadeIndex`发起读索引请求</span></span><br><span class="line">	   <span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> rs = &lt;-s.r.readStateC:</span><br><span class="line">			done = bytes.Equal(rs.RequestCtx, ctxToSend)</span><br><span class="line">		<span class="keyword">case</span> &lt;-leaderChangedNotifier:</span><br><span class="line">			nr.notify(ErrLeaderChanged)</span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(s.Cfg.ReqTimeout()):</span><br><span class="line">			nr.notify(ErrTimeout)</span><br><span class="line">			timeout = <span class="literal">true</span></span><br><span class="line">			slowReadIndex.Inc()</span><br><span class="line">		<span class="keyword">case</span> &lt;-s.stopping:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">|- nr.notify(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">node.ReadIndex</span><br><span class="line">|- n.step(ctx, pb.Message&#123;Type: pb.MsgReadIndex, Entries: []pb.Entry&#123;&#123;Data: rctx&#125;&#125;&#125;) <span class="comment">//</span></span><br><span class="line">    |- raft.Step</span><br><span class="line">        |- raft.stepLeader</span><br><span class="line">            |- <span class="keyword">if</span> r.raftLog.zeroTermOnErrCompacted(r.raftLog.term(r.raftLog.committed)) != r.Term &#123; <span class="comment">// 当本任期没有提交任何消息时，拒绝读</span></span><br><span class="line">    				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    			&#125;</span><br><span class="line">    			<span class="keyword">switch</span> r.readOnly.option &#123;</span><br><span class="line">    			<span class="keyword">case</span> <span class="string">`ReadOnlySafe`</span>:</span><br><span class="line">    				r.readOnly.addRequest(r.raftLog.committed, m) <span class="comment">// 将只读请求添加到`readyOnly`结构里。</span></span><br><span class="line">    				r.bcastHeartbeatWithCtx(m.Entries[<span class="number">0</span>].Data)<span class="comment">// 带上请求的ID，向所有成员节点发送心跳。</span></span><br><span class="line">    			<span class="keyword">case</span> <span class="string">`ReadOnlyLeaseBased`</span>:</span><br><span class="line">    				ri := r.raftLog.committed</span><br><span class="line">    				<span class="keyword">if</span> m.From == None || m.From == r.id &#123; <span class="comment">// from local member</span></span><br><span class="line">    					r.readStates = <span class="built_in">append</span>(r.readStates, ReadState&#123;Index: r.raftLog.committed, RequestCtx: m.Entries[<span class="number">0</span>].Data&#125;)</span><br><span class="line">    				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    					r.send(pb.Message&#123;To: m.From, Type: pb.MsgReadIndexResp, Index: ri, Entries: m.Entries&#125;)</span><br><span class="line">    				&#125;</span><br><span class="line">    			&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Follower接收到Leader的心跳请求，并返回"><a href="#Follower接收到Leader的心跳请求，并返回" class="headerlink" title="Follower接收到Leader的心跳请求，并返回"></a><code>Follower</code>接收到<code>Leader</code>的心跳请求，并返回</h3><p><code>Follower</code>接收到<code>Leader</code>的心跳请求，最终会调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r.raftLog.commitTo(m.Commit)</span><br><span class="line">r.send(pb.Message&#123;To: m.From, Type: pb.MsgHeartbeatResp, Context: m.Context&#125;) <span class="comment">// 发送心跳回复</span></span><br></pre></td></tr></table></figure>
<h3 id="Leader接收Follower回复，通知客户端请求继续"><a href="#Leader接收Follower回复，通知客户端请求继续" class="headerlink" title="Leader接收Follower回复，通知客户端请求继续"></a><code>Leader</code>接收<code>Follower</code>回复，通知客户端请求继续</h3><p><code>Leader</code>节点接收到<code>Follower</code>的回复后，最终会调用如下逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">pr.RecentActive = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> pr.Match &lt; r.raftLog.lastIndex() &#123; <span class="comment">// 当Follower节点有数据没复制时，进行发送</span></span><br><span class="line">	r.sendAppend(m.From)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 操作readyOnly接收Ack，并返回有多少节点已经确认</span></span><br><span class="line">ackCount := r.readOnly.recvAck(m)</span><br><span class="line"><span class="keyword">if</span> ackCount &lt; r.quorum() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回有哪些请求可以继续往下走</span></span><br><span class="line">rss := r.readOnly.advance(m)</span><br><span class="line"><span class="keyword">for</span> _, rs := <span class="keyword">range</span> rss &#123;</span><br><span class="line">	req := rs.req</span><br><span class="line">	<span class="keyword">if</span> req.From == None || req.From == r.id &#123;</span><br><span class="line">	   <span class="comment">// 将可以读的请求信息放到 r.readStates中，等后面提交到 ReadyC结构体，向上提交进行处理。</span></span><br><span class="line">		r.readStates = <span class="built_in">append</span>(r.readStates, ReadState&#123;Index: rs.index, RequestCtx: req.Entries[<span class="number">0</span>].Data&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ro *readOnly)</span> <span class="title">recvAck</span><span class="params">(m pb.Message)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	rs, ok := ro.pendingReadIndex[<span class="keyword">string</span>(m.Context)]  <span class="comment">// m.Context 为请求ID</span></span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	rs.acks[m.From] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(rs.acks) + <span class="number">1</span> <span class="comment">// 返回已经有多少Follower进行了应答</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回容许读的请求ID列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ro *readOnly)</span> <span class="title">advance</span><span class="params">(m pb.Message)</span> []*<span class="title">readIndexStatus</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		i     <span class="keyword">int</span></span><br><span class="line">		found <span class="keyword">bool</span></span><br><span class="line">	)</span><br><span class="line">	ctx := <span class="keyword">string</span>(m.Context)</span><br><span class="line">	rss := []*readIndexStatus&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, okctx := <span class="keyword">range</span> ro.readIndexQueue &#123;</span><br><span class="line">		i++</span><br><span class="line">		rs, ok := ro.pendingReadIndex[okctx]</span><br><span class="line">		rss = <span class="built_in">append</span>(rss, rs)</span><br><span class="line">		<span class="comment">// 找到匹配的读，以及可以触发读的请求队列。</span></span><br><span class="line">		<span class="keyword">if</span> okctx == ctx &#123;</span><br><span class="line">			found = <span class="literal">true</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> found &#123;</span><br><span class="line">		ro.readIndexQueue = ro.readIndexQueue[i:]<span class="comment">// 剔除之前的读请求</span></span><br><span class="line">		<span class="keyword">for</span> _, rs := <span class="keyword">range</span> rss &#123;</span><br><span class="line">			<span class="built_in">delete</span>(ro.pendingReadIndex, <span class="keyword">string</span>(rs.req.Entries[<span class="number">0</span>].Data))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> rss</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>raftNode</code>结构体接收到<code>Ready</code>消息时，会检查是否有<code>ReadStates</code>，然后对其进行处理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(rd.ReadStates) != <span class="number">0</span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> r.readStateC &lt;- rd.ReadStates[<span class="built_in">len</span>(rd.ReadStates)<span class="number">-1</span>]:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再回到<code>linearizableReadLoop</code>中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> rs = &lt;-s.r.readStateC:</span><br><span class="line">	<span class="keyword">case</span> &lt;-leaderChangedNotifier:</span><br><span class="line">		nr.notify(ErrLeaderChanged)</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(s.Cfg.ReqTimeout()):</span><br><span class="line">		nr.notify(ErrTimeout)</span><br><span class="line">	<span class="keyword">case</span> &lt;-s.stopping:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">nr.notify(<span class="literal">nil</span>) <span class="comment">// 通知客户端可以进行查询请求</span></span><br></pre></td></tr></table></figure>
<p>到此就完成线性一致性读的全过程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2019/11/22/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/etcd/4.etcd-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/22/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/etcd/4.etcd-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" itemprop="url">ETCD网络通信</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-22T00:00:00+08:00">2019-11-22</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/etcd/" itemprop="url" rel="index"><span itemprop="name">etcd</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="2-网络通信"><a href="#2-网络通信" class="headerlink" title="2. 网络通信"></a>2. 网络通信</h1><p>在上一节，我们介绍了<code>etcd</code>集群的启动过程。在其中也简单介绍了会初始化与其他成员节点通信的连接，以及启动为其他成员节点提供服务的<code>GRPC</code>服务和<code>Http</code>服务以及启动服务客户端的服务。本章我们将详细介绍通信相关的实现。</p>
<h2 id="2-1-成员节点间通信（peer）"><a href="#2-1-成员节点间通信（peer）" class="headerlink" title="2.1 成员节点间通信（peer）"></a>2.1 成员节点间通信（peer）</h2><p>前一章节介绍了peer服务端启动过程。下面，我们来讲解下调用端是如何初始化以及如何调用的。<br>与成员节点间通信传输的初始化之前介绍过，是调用<code>Transport.AddPeer</code>方法。<br>前面我们介绍了<code>Transport</code>的作用：向成员节点发送raft消息，并从成员节点获取raft消息。下面将详细描述其作用。<br>首先来看其初始化和启动过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">tr := &amp;rafthttp.Transport&#123;</span><br><span class="line">	DialTimeout: cfg.peerDialTimeout(),</span><br><span class="line">	ID:          id,</span><br><span class="line">	URLs:        cfg.PeerURLs,</span><br><span class="line">	ClusterID:   cl.ID(),</span><br><span class="line">	Raft:        srv, <span class="comment">// EtcdServer</span></span><br><span class="line">	Snapshotter: ss,</span><br><span class="line">	ServerStats: sstats,</span><br><span class="line">	LeaderStats: lstats,</span><br><span class="line">	ErrorC:      srv.errorc,</span><br><span class="line">&#125;</span><br><span class="line">tr.Start()</span><br><span class="line">|- t.streamRt = newStreamRoundTripper(t.TLSInfo, t.DialTimeout) <span class="comment">// 其作用前面介绍过：可以执行事务性HTTP请求，给定请求获取结果</span></span><br><span class="line">|- t.pipelineRt = NewRoundTripper(t.TLSInfo, t.DialTimeout) <span class="comment">//</span></span><br><span class="line">|- t.remotes = <span class="built_in">make</span>(<span class="keyword">map</span>[types.ID]*remote) <span class="comment">// 初始化复制节点映射</span></span><br><span class="line">|- t.peers = <span class="built_in">make</span>(<span class="keyword">map</span>[types.ID]Peer) <span class="comment">// 初始化成员节点映射</span></span><br><span class="line">|- t.pipelineProber = probing.NewProber(t.pipelineRt) <span class="comment">// Prober的作用是探测，探测链路监控状态</span></span><br><span class="line">|- t.streamProber = probing.NewProber(t.streamRt)</span><br></pre></td></tr></table></figure>
<p>接下来，继续了解<code>AddPeer</code>实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Transport/AddPeer</span><br><span class="line">|- startPeer</span><br><span class="line">    |- picker := newURLPicker(urls) <span class="comment">// 其用于选取通信通道（负载均衡作用）</span></span><br><span class="line">    |- pipeline := &amp;pipeline&#123;...&#125; <span class="comment">// 创建pipeline，多通道发送消息。</span></span><br><span class="line">    |- pipeline.start() <span class="comment">// 开启多个异步任务，监听 msgC通道，进行数据发送</span></span><br><span class="line">    |- p := &amp;peer&#123;...&#125; <span class="comment">// 创建peer结构体，初始化其属性，如recev、propc通道、消息发送器 msgAppV2Writer、writer（StreamWriter）</span></span><br><span class="line">    |- <span class="keyword">go</span> <span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> mm := &lt;-p.recvc:  <span class="comment">//监听 recev通道发来的消息，并将其丢给 EtcdServer.`Process`方法处理</span></span><br><span class="line">				<span class="keyword">if</span> err := r.Process(ctx, mm)</span><br><span class="line">			&#125;</span><br><span class="line">    |- <span class="keyword">go</span> <span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> mm := &lt;-p.propc: <span class="comment">// 监听 propc 通道发来的消息，将其丢给...</span></span><br><span class="line">				<span class="keyword">if</span> err := r.Process(ctx, mm);</span><br><span class="line">		  &#125;</span><br><span class="line">    |-  初始化 <span class="string">`p.msgAppV2Reader`</span>、<span class="string">`p.msgAppReader`</span> 用于读取消息</span><br><span class="line">    |- p.msgAppV2Reader.start() <span class="comment">// 开启监听消息读取</span></span><br><span class="line">    |- p.msgAppReader.start()    </span><br><span class="line">|- addPeerToProber(t.Logger, t.pipelineProber, id.String(), us, RoundTripperNameSnapshot, rttSec) <span class="comment">// 将该节点添加到探测器中，进行定期探测状态</span></span><br><span class="line">|-	addPeerToProber(t.Logger, t.streamProber, id.String(), us, RoundTripperNameRaftMessage, rttSec)</span><br></pre></td></tr></table></figure>
<p>从上面的流程可以看出 <code>peer</code>使用stream模式通信方式。读写分别用不同的协程去监听处理。其中<code>streamWriter</code>负责消息发送，<code>streamReader</code>负责消息接收。见下面详情：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">w := &amp;streamWriter&#123;</span><br><span class="line">	peerID:  id,</span><br><span class="line">	status: status,</span><br><span class="line">	fs:     fs,</span><br><span class="line">	r:      r,</span><br><span class="line">	msgc:   <span class="built_in">make</span>(<span class="keyword">chan</span> raftpb.Message, streamBufSize),</span><br><span class="line">	connc:  <span class="built_in">make</span>(<span class="keyword">chan</span> *outgoingConn),</span><br><span class="line">	stopc:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">	done:   <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">&#125;</span><br><span class="line">w.run:</span><br><span class="line">|- <span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-heartbeatc:</span><br><span class="line">	<span class="comment">//发送心跳消息</span></span><br><span class="line">	<span class="keyword">case</span> m := &lt;-msgc:</span><br><span class="line">	<span class="comment">// 接收到需要发送的消息，进行编码并使用conn进行发送</span></span><br><span class="line">    <span class="keyword">case</span> conn := &lt;-cw.connc:</span><br><span class="line">    <span class="comment">// 监听附加上来的连接通道，进行初始化 编码器、Flusher等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>streamWriter</code>里比较关键的一点是，这里的<code>conn</code>从哪来？往<code>cw.connc</code>传递<code>conn</code>的只有<code>peer.attachOutgoingConn</code>方法。<br>而在上面初始化并启动<code>peer</code>的时候是没有发现调用这个方法的 ？？？哪是哪里进行执行的呢？通过 追踪<code>peer.attachOutgoingConn</code>的调用方，最终发现，其在<code>rafthhtp/http.go/ServeHTTP() L483</code>处调用。而这个方法会在客户端建立连接<strong>进行http服务调用</strong>的时候执行。所以，在这里调用 <code>peer.attachOutgoingConn</code> 的作用是复用<code>连接</code>。当我们分析完读处理过程后，再来整体看 <code>etcd</code>节点是怎么建立通信链路的。</p>
<p><code>StreamReader</code>的处理比<code>StreamWriter</code>的处理要简单一些。初始化完其属性后，调用<code>start</code>方法启动监听读请求过程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StreamReader/start</span><br><span class="line">|- run</span><br><span class="line">    |- rc, err := cr.dial(t) <span class="comment">// 进行拨号，建立起与peer之间的连接</span></span><br><span class="line">    |- err = cr.decodeLoop(rc, t) <span class="comment">// 获取返回结果，进行解码</span></span><br><span class="line">        |- <span class="keyword">for</span>&#123; m, err := dec.decode() <span class="comment">//循环解码</span></span><br><span class="line">        |- 如果 m 是<span class="string">`MsgProp`</span>类型，则将消息传递到 propc通道，否则到 recv通道</span><br></pre></td></tr></table></figure>
<p>这样每个peer之间的链路就建立了。回过头来，可以看出每对<code>peer</code>之间至少会有两条<code>connection</code>。且他们之间交互交错使用。</p>
<p>单<code>peer</code>往对方发送的消息，是通过 <strong>对方跟自己建立的连接</strong> 来发送的。</p>
<p>最后，我们通过单次请求响应过程，来介绍节点间的通信过程。</p>
<p>当要想集群其他成员节点发送消息时，最终会调用<code>peer.send</code>方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">peer.send</span><br><span class="line">|- writec, name := p.pick(m) <span class="comment">// 首先peer会根据m的类型来选择一个发送通道</span></span><br><span class="line">    |- isMsgSnap(m) <span class="keyword">return</span> p.pipeline.msgc, pipelineMsg <span class="comment">// 如果是快照消息，则通过pipeline.msgc来发送消息</span></span><br><span class="line">    |- isMsgApp(m) <span class="keyword">return</span> p.msgAppV2Writer.writec(),streamAppV2 <span class="comment">// 如果是MsgApp消息</span></span><br><span class="line">    |- 如果 p.writer.writec() 可用，<span class="keyword">return</span> p.writer.writec()</span><br><span class="line">    |- 备用 p.pipeline.msgc, pipelineMsg</span><br><span class="line">|- writec &lt;- m: <span class="comment">// 即发送数据到 写通道中，`StreamWriter` 中会监听此通道。</span></span><br><span class="line"></span><br><span class="line">StreamWriter.run</span><br><span class="line">|- <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> m := &lt;-msgc:</span><br><span class="line">     |- enc.encode(&amp;m)</span><br><span class="line">        |- binary.Write(enc.w, binary.BigEndian, <span class="keyword">uint64</span>(m.Size())) <span class="comment">// 对于 messageEncoder，首先发送字节长度</span></span><br><span class="line">        |- enc.w.Write(pbutil.MustMarshal(m)) <span class="comment">//再发送字节内容</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目标节点的 <strong>StreamReader</strong>（<code>p.msgAppReader</code>）接收到消息后，通过解析后传递到 <code>EtcdServer</code>(Process)，即完成单次通信；对于请求的响应，则通过对方的<code>peer</code>来发送给本节点，本节点的<code>StreamReader</code>来接受响应消息。</p>
<h2 id="2-2-客户端通信"><a href="#2-2-客户端通信" class="headerlink" title="2.2 客户端通信"></a>2.2 客户端通信</h2><p>对于客户端通信，因为是<code>GRPC</code>或者<code>HTTP</code>简单的请求响应方式，因此这里就不再介绍了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2019/11/21/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/etcd/3.etcd-%E5%AD%98%E5%82%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/21/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/etcd/3.etcd-%E5%AD%98%E5%82%A8/" itemprop="url">ETCD数据存储</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-21T00:00:00+08:00">2019-11-21</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/etcd/" itemprop="url" rel="index"><span itemprop="name">etcd</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="3-数据存储"><a href="#3-数据存储" class="headerlink" title="3. 数据存储"></a>3. 数据存储</h1><p><code>Etcd</code>的存储部分，可以分两部分来讲解。一部分是其应用层的数据存储方式，另一部分是<code>raft</code>相关数据的存储。<code>Etcd</code>应用层的数据存储从<code>v3</code>版本开始就延用<code>boltDB</code>，其也是<code>CoreOS</code>的产品<a href="https://github.com/etcd-io/bbolt" target="_blank" rel="noopener">boltDB</a>。PS:本文主要聚焦于v3版本，对于v2版本不作解读。</p>
<p>下面将分别介绍这两部分内容：</p>
<h2 id="3-1-raft数据存储"><a href="#3-1-raft数据存储" class="headerlink" title="3.1 raft数据存储"></a>3.1 raft数据存储</h2><p>首先我们来介绍下<code>raft</code>相关的数据存储：<br><code>raft</code>中有两个比较重要的组件：</p>
<ul>
<li><code>raftLog</code>：用来保存状态机相关信息的，包括当前任期、索引号、不稳定记录项等；</li>
<li><code>WAL</code>：预写日志器，用于以顺序形式写入操作记录，以便故障时数据恢复；</li>
<li><code>Snapshot</code>：数据快照，一般用于启动时快速恢复数据。</li>
</ul>
<p>首先来看<code>raftLog</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> raftLog <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 包含所有稳定的记录 MemeoryStorge</span></span><br><span class="line">	storage Storage</span><br><span class="line"> <span class="comment">// 包含所有不稳定的记录</span></span><br><span class="line">	unstable unstable</span><br><span class="line"> <span class="comment">// 提交记录索引</span></span><br><span class="line">	committed <span class="keyword">uint64</span></span><br><span class="line"><span class="comment">// 应用记录索引</span></span><br><span class="line">	applied <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> MemoryStorage <span class="keyword">struct</span> &#123;</span><br><span class="line">	hardState pb.HardState</span><br><span class="line">	<span class="comment">// 快照信息（保存 v2版存储中的保存的数据快照、任期、索引、ConfState[集群节点信息]）。快照生成一般有个条件：距上次提交的次数大于`SnapshotCount`（默认10000）</span></span><br><span class="line">	snapshot  pb.Snapshot</span><br><span class="line">	ents []pb.Entry</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从名字也可以看出其用途</span></span><br><span class="line"><span class="keyword">type</span> unstable <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 快照信息，这里只会在节点加入集群，主节点向其发送`MsgSnap`消息的时候才会有</span></span><br><span class="line">	snapshot *pb.Snapshot</span><br><span class="line">	entries []pb.Entry</span><br><span class="line">	offset  <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图描述了数据从客户端请求到落地各个阶段与以前存储结构的关系：<br><img src="/media/15516348174091.jpg" alt=""></p>
<p>其中，8’、9、11 是涉及 <strong>I/O</strong> 的操作，其他均为内存操作。<br>对<code>WAL</code>的操作在每次写事务操作中都会存在，因此其是制约<code>etcd</code>写性能的一个重要因素。接下来，将重点介绍<code>WAL</code>的工作原理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WAL <span class="keyword">struct</span> &#123;</span><br><span class="line">	dir <span class="keyword">string</span>       <span class="comment">// WAL文件所在目录</span></span><br><span class="line">	dirFile *os.File <span class="comment">// 目录文件句柄</span></span><br><span class="line">	metadata []<span class="keyword">byte</span>  <span class="comment">// 元数据，记录在每个wal文件头</span></span><br><span class="line">	state    raftpb.HardState <span class="comment">// 硬状态（任期、索引号），记录在每个文件头</span></span><br><span class="line">	start     walpb.Snapshot <span class="comment">// snapshot to start reading</span></span><br><span class="line">	decoder   *decoder       <span class="comment">// 解码器</span></span><br><span class="line">	enti    <span class="keyword">uint64</span>   <span class="comment">// 保存到WAL的最大索引号</span></span><br><span class="line">	encoder *encoder <span class="comment">// 编码器</span></span><br><span class="line">	locks []*fileutil.LockedFile <span class="comment">// 文件锁</span></span><br><span class="line">	fp    *filePipeline    <span class="comment">// 文件创建工具，预先创建文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，来看其创建过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">wal.Create</span><br><span class="line">|- tmpdirpath := filepath.Clean(dirpath) + <span class="string">".tmp"</span></span><br><span class="line">|- os.RemoveAll(tmpdirpath)</span><br><span class="line">|-	fileutil.CreateDirAll(tmpdirpath)</span><br><span class="line">|- p := filepath.Join(tmpdirpath, walName(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">|- f, err := fileutil.LockFile(p, os.O_WRONLY|os.O_CREATE, fileutil.PrivateFileMode)</span><br><span class="line">|- f.Seek(<span class="number">0</span>, io.SeekEnd)</span><br><span class="line">|- fileutil.Preallocate(f.File, SegmentSizeBytes, <span class="literal">true</span>)  <span class="comment">// 预分配空间</span></span><br><span class="line">|- w := &amp;WAL&#123;</span><br><span class="line">    	lg:       lg,</span><br><span class="line">    	dir:      dirpath,</span><br><span class="line">    	metadata: metadata,</span><br><span class="line">    &#125;</span><br><span class="line">|- w.encoder, err = newFileEncoder(f.File, <span class="number">0</span>)	<span class="comment">// 编码器，编码器编码的同时会将结果写到文件中</span></span><br><span class="line">|- w.locks = <span class="built_in">append</span>(w.locks, f)</span><br><span class="line">|-	w.saveCrc(<span class="number">0</span>) w.encoder.encode(&amp;walpb.Record&#123;Type: metadataType, Data: metadata&#125;)<span class="comment">// 写文件头</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">|- w.SaveSnapshot(walpb.Snapshot&#123;&#125;)</span><br><span class="line">|- w.renameWAL(tmpdirpath)  <span class="comment">// 更改零时文件名称为waldir，创建FilePipeline（用于预先创建文件）</span></span><br><span class="line">|-pdir, perr := fileutil.OpenDir(filepath.Dir(w.dir))</span><br><span class="line">|- fileutil.Fsync(pdir)</span><br></pre></td></tr></table></figure>
<p>创建<code>WAL</code>时，会初始化编码器以及<code>FilePipeline</code>。下面再以其<code>Save</code>方法来介绍保存记录的过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">WAL.Save</span><br><span class="line">|- mustSync := raft.MustSync(st, w.state, <span class="built_in">len</span>(ents)) <span class="comment">// 判断是否需要文件同步，写入磁盘</span></span><br><span class="line">|- <span class="keyword">for</span> each ents: saveEntry</span><br><span class="line">    |- b := pbutil.MustMarshal(e) rec := &amp;walpb.Record&#123;Type: entryType, Data: b&#125;</span><br><span class="line">    |- w.encoder.encode(rec) <span class="comment">// 编码后写入文件</span></span><br><span class="line">|- w.saveState(&amp;st) <span class="comment">// 保存状态</span></span><br><span class="line">|- curOff, err := w.tail().Seek(<span class="number">0</span>, io.SeekCurrent)</span><br><span class="line">|- <span class="keyword">if</span> curOff &lt; SegmentSizeBytes &amp; mustSync w.sync() 如果文件还没大于SegmentSizeBytes，且需要同步，则进行文件同步</span><br><span class="line">|- 如果大于，则进行切割文件 <span class="string">`w.cut`</span></span><br><span class="line">    |- fpath := filepath.Join(w.dir, walName(w.seq()+<span class="number">1</span>, w.enti+<span class="number">1</span>))</span><br><span class="line">    |- newTail, err := w.fp.Open() <span class="comment">// 通过filePipeline获取一个新的零时文件</span></span><br><span class="line">    |- 进行初始化 w.encoder, err = newFileEncoder(w.tail().File, prevCrc) ...</span><br><span class="line">    |- os.Rename(newTail.Name(), fpath) <span class="comment">// 重命名</span></span><br><span class="line">    |- w.sync()</span><br></pre></td></tr></table></figure>
<p>随着记录的增加，<code>wal</code>文件会越来越多，入股不做处理的话会导致磁盘被占满。那么<code>etcd</code>是怎么做的呢？<br>其实是由两步构成的：</p>
<ol>
<li>当<code>etcd</code>每次进行执行快照的实时，会进行<code>wal.ReleaseLockTo(snap.Metadata.Index)</code>释放文件锁的操作。（释放快照对应索引号之前的所有WAL文件句柄）</li>
<li>之前在<code>EtcdServer</code>启动章节介绍过，其启动后会启动一个定时任务<code>purgeFile</code>。其会针对<code>snap.db</code>、<code>snap</code>、<code>wal</code>文件做30秒一次的<code>fileutil.PurgeFile</code>任务：<ol>
<li>任务带有参数 <code>MaxWalFiles</code>，获取指定<code>wal.dir</code>下所有文件，然后按文件名排序，从小到大进行遍历：尝试锁文件。如果成功，则进行删除，否则的话说明依然被<code>etcd</code>锁占用。</li>
</ol>
</li>
</ol>
<h2 id="3-2-应用数据存储"><a href="#3-2-应用数据存储" class="headerlink" title="3.2 应用数据存储"></a>3.2 应用数据存储</h2><p>在解析<code>etcd</code>应用层数据存储结构前，先来介绍下<code>etcd</code>的数据存储形式。<code>etcd</code>对数据的存储并不是直接存储<code>key-value</code>对，而是引入了一种带版本号<code>revision</code>的存储方式：以数据的<code>revison</code>为<code>key</code>，键值对为值。<br><code>revision</code>由两部分组成：<code>main-revision</code>.<code>sub-revision</code>。<code>main-revision</code>为事务ID，<code>sub-revision</code>为事务中一次操作ID。</p>
<p>举例来说：<br>系统刚启动后，在一个事务中执行<code>put ty dj \n put dj ty</code>两个操作，实际存储的是</p>
<ol>
<li>{1,0} key=ty val=dj</li>
<li>{1,1} key=dj val=ty</li>
</ol>
<p>紧接着执行第二次操作：<code>put ty dj90 \n put dj ty92</code>，那么存储中会追加如下信息：</p>
<ol>
<li>{2,0} key=ty val=dj90</li>
<li>{2,1} key=dj val=ty92</li>
</ol>
<p>而为了支持这种存储形式快速查询，<code>etcd</code>建立了<code>treeIndex</code>结构，用于建立<code>key</code>与<code>revision</code>间的关系。随之，通过<code>key</code>查询<code>val</code>的过程如下：<br><img src="/media/15516311446785.jpg" alt=""></p>
<p><strong>treeIndex</strong>是一个<code>b-ree</code>，其存储这<code>keyIndex</code>信息。<code>KeyIndex</code>的结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">key         []<span class="keyword">byte</span></span><br><span class="line">modified    revision <span class="comment">// 最后一次更改版本信息</span></span><br><span class="line">generations []generation <span class="comment">// 代：每一代记录着键值对从创建到删除的过程</span></span><br><span class="line">|- ver     <span class="keyword">int64</span> <span class="comment">// 存放了多少次修改</span></span><br><span class="line">	created revision <span class="comment">// 创建此generation的第一个版本</span></span><br><span class="line">	revs    []revision</span><br></pre></td></tr></table></figure>
<p><code>keyIndex</code>中，需要特别说明的是<code>generation</code>数据内部，保存的<code>revs</code>，如果最后一项为<code>tombstone</code>，则表示在这个代中被删除了。被<code>tombstone</code>的<code>generation</code>是可以被删除的。针对此，<code>keyIndex</code>有个专门的函数<code>compact</code>，<code>compact(n)</code>可以将主版本小于n的数据。</p>
<p>将完了其存储结构和存储格式，下面将从启动和执行一次操作两个流程来讲解其的工作原理。对<code>boltDB</code>不了解的读者建议先去了解下 <a href="https://github.com/etcd-io/bbolt" target="_blank" rel="noopener"><code>boltDB</code></a>、<a href="https://segmentfault.com/a/1190000010098668" target="_blank" rel="noopener"><code>boltDB学习</code></a>。</p>
<h3 id="3-2-1-启动过程"><a href="#3-2-1-启动过程" class="headerlink" title="3.2.1 启动过程"></a>3.2.1 启动过程</h3><p><code>etcd</code>应用层存储创建过程如下：<br>首先创建<code>backend</code>，其是对<code>boltDB</code>的封装，加入一些批量提交逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bepath := cfg.backendPath()</span><br><span class="line">beExist := fileutil.Exist(bepath)</span><br><span class="line">be := openBackend(cfg) <span class="comment">// 创建</span></span><br><span class="line">|- newBackend</span><br><span class="line">    |- bolt.Open(bcfg.Path, <span class="number">0600</span>, bopts)</span><br><span class="line">    |- b := &amp;backend&#123;</span><br><span class="line">		db: db,</span><br><span class="line">		batchInterval: bcfg.BatchInterval,</span><br><span class="line">		batchLimit:    bcfg.BatchLimit ...</span><br><span class="line">		&#125;</span><br><span class="line">	 |- b.run() <span class="comment">// 定时任务，批量周期进行提交</span></span><br><span class="line">	   |- t := time.NewTimer(b.batchInterval)</span><br><span class="line">	   |- <span class="keyword">select</span> &#123;</span><br><span class="line">    		<span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">    			b.batchTx.CommitAndStop()</span><br><span class="line">    			<span class="keyword">return</span></span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">if</span> b.batchTx.safePending() != <span class="number">0</span> &#123;</span><br><span class="line">    			b.batchTx.Commit()</span><br><span class="line">    		&#125;</span><br></pre></td></tr></table></figure>
<p>有了<code>backend</code>后，会再基于此作一层封装：<code>mvcc.New(srv.getLogger(), srv.be, srv.lessor, &amp;srv.consistIndex)</code>，其内部包含<code>watcher</code>处理机制：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mvcc.New</span><br><span class="line">|- s := &amp;watchableStore&#123;</span><br><span class="line">    store:    NewStore(lg, b, le, ig),</span><br><span class="line">    victimc:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>),</span><br><span class="line">    unsynced: newWatcherGroup(),</span><br><span class="line">    synced:   newWatcherGroup(),</span><br><span class="line">    &#125;</span><br><span class="line">|- s.store.ReadView = &amp;readView&#123;s&#125;</span><br><span class="line">	s.store.WriteView = &amp;writeView&#123;s&#125;</span><br><span class="line">	<span class="keyword">if</span> s.le != <span class="literal">nil</span> &#123;</span><br><span class="line">		s.le.SetRangeDeleter(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">lease</span>.<span class="title">TxnDelete</span></span> &#123; <span class="keyword">return</span> s.Write() &#125;)</span><br><span class="line">	&#125;    </span><br><span class="line">|- <span class="keyword">go</span> s.syncWatchersLoop() <span class="comment">// 用于watch机制的异步任务</span></span><br><span class="line">|- <span class="keyword">go</span> s.syncVictimsLoop()</span><br></pre></td></tr></table></figure>
<p>这里我们比较关注的是<code>NewStore</code>逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">mvcc.NewStore</span><br><span class="line">|- s := &amp;store&#123;</span><br><span class="line">		b:       b,</span><br><span class="line">		kvindex: newTreeIndex(lg), <span class="comment">// 创建 treeIndex</span></span><br><span class="line">		le: le,</span><br><span class="line">		currentRev:     <span class="number">1</span>, <span class="comment">// 最近一次事务的版次</span></span><br><span class="line">		compactMainRev: <span class="number">-1</span>,<span class="comment">//最近一次事务的主版次</span></span><br><span class="line">		bytesBuf8: <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">8</span>),</span><br><span class="line">		fifoSched: schedule.NewFIFOScheduler(),</span><br><span class="line">		stopc: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">	&#125;</span><br><span class="line">|- s.ReadView = &amp;readView&#123;s&#125;</span><br><span class="line">	s.WriteView = &amp;writeView&#123;s&#125;</span><br><span class="line">	<span class="keyword">if</span> s.le != <span class="literal">nil</span> &#123;</span><br><span class="line">		s.le.SetRangeDeleter(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">lease</span>.<span class="title">TxnDelete</span></span> &#123; <span class="keyword">return</span> s.Write() &#125;)</span><br><span class="line">	&#125;</span><br><span class="line">|- tx.UnsafeCreateBucket(keyBucketName) <span class="comment">// 创建bucket-"key"用来存储kv数据，</span></span><br><span class="line">|- tx.UnsafeCreateBucket(metaBucketName) <span class="comment">//创建Bucket-”meta“用来存储元数据</span></span><br><span class="line">|- s.restore() <span class="comment">// 恢复存储</span></span><br><span class="line"><span class="comment">// TreeIndex 是b树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTreeIndex</span><span class="params">(lg *zap.Logger)</span> <span class="title">index</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;treeIndex&#123;</span><br><span class="line">		tree: btree.New(<span class="number">32</span>),</span><br><span class="line">		lg:   lg,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">s.restore</span><br><span class="line">|- rkvc, revc := restoreIntoIndex(s.lg, s.kvindex)<span class="comment">// 构建tree-index方法，返回两个通道，用于向内传入数据</span></span><br><span class="line">|- <span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 分页提取key-val</span></span><br><span class="line">		keys, vals := tx.UnsafeRange(keyBucketName, min, max, <span class="keyword">int64</span>(restoreChunkKeys))</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(keys) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将key-val进行解码，然后传递给`rkvc`通道，在restoreIntoIndex中监听`rkvc`通道，进行构建`treeIndex`</span></span><br><span class="line">		restoreChunk(s.lg, rkvc, keys, vals, keyToLease)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(keys) &lt; restoreChunkKeys &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		newMin := bytesToRev(keys[<span class="built_in">len</span>(keys)<span class="number">-1</span>][:revBytesLen])</span><br><span class="line">		newMin.sub++</span><br><span class="line">		revToBytes(newMin, min)</span><br><span class="line">	&#125;</span><br><span class="line">|- ...</span><br></pre></td></tr></table></figure>
<p>由此就完成了<code>treeIndex</code>和<code>boltDB</code>的初始化。<br>最后，<code>etcd</code>又对<code>mvcc.watchableStore</code>进行了一次封装<code>srv.newApplierV3Backend()</code>，其用于衔接存储和<code>raft</code>消息请求。</p>
<h3 id="3-2-2-请求应用到存储"><a href="#3-2-2-请求应用到存储" class="headerlink" title="3.2.2 请求应用到存储"></a>3.2.2 请求应用到存储</h3><p><code>put ty dj</code>请求通过<code>raft</code>协议提交决策后，最终会调用到<code>applierV3backend.put</code>方法进行应用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">applierV3backend.put</span><br><span class="line">|- txn = a.s.KV().Write()</span><br><span class="line">|- txn.Put(p.Key, val, leaseID)</span><br><span class="line">    |- storeTxnWrite.put</span><br><span class="line">        |- rev := tw.beginRev + <span class="number">1</span></span><br><span class="line">        	c := rev</span><br><span class="line">        	|- _, created, ver, err := tw.s.kvindex.Get(key, rev) <span class="comment">// 如果key存在则获取</span></span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        		c = created.main</span><br><span class="line">        		oldLease = tw.s.le.GetLease(lease.LeaseItem&#123;Key: <span class="keyword">string</span>(key)&#125;)</span><br><span class="line">        	&#125;</span><br><span class="line">        	|- ibytes := newRevBytes()</span><br><span class="line">            |- idxRev := revision&#123;main: rev, sub: <span class="keyword">int64</span>(<span class="built_in">len</span>(tw.changes))&#125;</span><br><span class="line">            |- revToBytes(idxRev, ibytes)</span><br><span class="line">            |- ver = ver + <span class="number">1</span></span><br><span class="line">            |- kv := mvccpb.KeyValue&#123;</span><br><span class="line">            		Key:            key,</span><br><span class="line">            		Value:          value,</span><br><span class="line">            		CreateRevision: c,</span><br><span class="line">            		ModRevision:    rev,</span><br><span class="line">            		Version:        ver,</span><br><span class="line">            		Lease:          <span class="keyword">int64</span>(leaseID),</span><br><span class="line">            	&#125;</span><br><span class="line">            |- d, err := kv.Marshal()</span><br><span class="line">            |- 	tw.tx.UnsafeSeqPut(keyBucketName, ibytes, d) <span class="comment">// 存储到boltDB中，key为`revision`</span></span><br><span class="line">            |- tw.s.kvindex.Put(key, idxRev) <span class="comment">// 将key到 revision的映射存储到treeIndex中</span></span><br></pre></td></tr></table></figure>
<p>到此就完成了存储模块的讲解。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2019/11/20/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/etcd/2.etcd-%E5%88%9D%E5%A7%8B%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/20/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/etcd/2.etcd-%E5%88%9D%E5%A7%8B%E5%8C%96/" itemprop="url">ETCD初始化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-20T00:00:00+08:00">2019-11-20</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/etcd/" itemprop="url" rel="index"><span itemprop="name">etcd</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-Etcd初始化流程解析"><a href="#1-Etcd初始化流程解析" class="headerlink" title="1. Etcd初始化流程解析"></a>1. Etcd初始化流程解析</h1><p><code>Etcd</code>的启动类为 父目录的<code>main.go</code>文件。其启动过程调用如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main.<span class="keyword">go</span></span><br><span class="line">|- etcdmain/main.<span class="keyword">go</span>(暂且忽略<span class="string">`gateway`</span>和<span class="string">`proxy`</span>模式启动)</span><br><span class="line">    |- checkSupportArch <span class="comment">// 检查是否是支持的处理器架构</span></span><br><span class="line">    |- startEtcdOrProxyV2 <span class="comment">// 解析参数并根据参数决定启动etcd节点还是按Proxy模式启动（这里按etcd节点形式启动）</span></span><br><span class="line">        |- 生成默认参数<span class="string">`newConfig()`</span>解析参数 <span class="string">`cfg.parse(os.Args[1:])`</span>解析命令行启动参数</span><br><span class="line">        |- startEtcd(&amp;cfg.ec)<span class="comment">// 启动过程最核心的地方</span></span><br></pre></td></tr></table></figure>
<p><code>startEtcd</code>中执行<code>etcd</code>启动的主要过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">embed.startEtcd(inCfg *Config)</span><br><span class="line">|- inCfg.Validate() <span class="comment">//校验配置，检查url是否是以ip地址开头的，否则报错终止流程</span></span><br><span class="line">|- configurePeerListeners(cfg) <span class="comment">// 根据配置初始化peerListener结构体（为`peer`服务的服务器配置）</span></span><br><span class="line">|- configureClientListeners(cfg) <span class="comment">// 根据配置初始化clientListener结构体，（为`client`服务的服务器配置）</span></span><br><span class="line">|- 通过判断是否有 <span class="string">`wal`</span>文件来判断是否已经有其他节点信息</span><br><span class="line">    |- cfg.PeerURLsMapAndToken(<span class="string">"etcd"</span>)方法，其用于解析出其他节点的信息。</span><br><span class="line">    |- etcd集群模式有三种启动方式，其具体实现即实现在其内部。（<span class="string">`后续我们将详细分析`</span>）</span><br><span class="line">|- etcdserver.NewServer(srvcfg) <span class="comment">// 执行etcdServer初始化</span></span><br><span class="line">|- e.Server.Start() <span class="comment">// 启动 etcdServer</span></span><br><span class="line">|- e.servePeers() <span class="comment">// 启动 监听etcd节点间请求的GRPC服务</span></span><br><span class="line">|- e.serveClients() <span class="comment">// 启动监听客户端请求的GRPC服务</span></span><br><span class="line">|- e.serveMetrics() <span class="comment">// 启动Metrics Http服务，供外部查询Metrics信息</span></span><br></pre></td></tr></table></figure>
<p>通过 <strong>cfg.PeerURLsMapAndToken(“etcd”)</strong> 逻辑，了解到<code>etcd</code>有三种方式来获取集群中其他节点信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> cfg.Durl != <span class="string">""</span>:<span class="comment">// etcd自发现模式：配置 “discovery”参数设置。这里没有真正获取集群所有节点。比较trick的作用，等后面来处理。</span></span><br><span class="line">	<span class="keyword">case</span> cfg.DNSCluster != <span class="string">""</span>:<span class="comment">// 通过DNS自发现模式，配置”discovery-srv“</span></span><br><span class="line">  <span class="keyword">default</span>:<span class="comment">// 默认的静态配置方式，通过参数 "initial-cluster"进行设置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>准备好创建<code>etcd</code>节点后开始初始化节点信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">etcdserver/NewServer(srvcfg)</span><br><span class="line">|- fileutil.TouchDirAll(cfg.DataDir) <span class="comment">//检查是否可以获取目录权限：DataDir:"集群名.etcd"</span></span><br><span class="line">|- fileutil.TouchDirAll(cfg.SnapDir()) <span class="comment">// 检查是佛偶可以获取快照目录权限 ”集群名.etcd/member/snap“</span></span><br><span class="line">|- snap.New(cfg.Logger, cfg.SnapDir()) <span class="comment">//创建快照管理器</span></span><br><span class="line">|- be := openBackend(cfg) <span class="comment">// 创建数据库后端，其底层使用boltDB存储数据，然后在其之上进行了一次封装：包括批量提交事务。（关于存储的内容，我们后面讲单独讲解）</span></span><br><span class="line">|- rafthttp.NewRoundTripper(cfg.PeerTLSInfo, cfg.peerDialTimeout()) <span class="comment">// 创建一个RoundTripper，其作用是封装一个具有执行一次http事务，为一个http request获取response的对象</span></span><br></pre></td></tr></table></figure>
<p>初始化快照管理器和数据库后端后，就会根据一系列条件来决定怎样启动节点：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> !haveWAL &amp;&amp; !cfg.NewCluster:<span class="comment">// 非新集群，同事也没有WAL文件</span></span><br><span class="line">	<span class="comment">// 首先进行一些校验工作：比如判断本地集群成员列表是否与远程其他节点的成本列表配置是否相同</span></span><br><span class="line">	<span class="comment">// 判断集群每个节点的版本是否兼容</span></span><br><span class="line">	id, n, s, w = startNode(cfg, cl, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">case</span> !haveWAL &amp;&amp; cfg.NewCluster: <span class="comment">// 新集群，且没有WAL文件</span></span><br><span class="line">	<span class="comment">// 此处就是接着 PeerURLsMapAndToken的处理，如果配置`Discovery`参数，etcd则进行自发现流程 `v2discovery.JoinCluster`</span></span><br><span class="line">	id, n, s, w = startNode(cfg, cl, cl.MemberIDs())</span><br><span class="line">	<span class="keyword">case</span> haveWAL:                  <span class="comment">// 非新集群，且有WAL文件</span></span><br><span class="line">	<span class="comment">// 首先读取快照文件</span></span><br><span class="line">	<span class="comment">// 从快照文件中恢复数据库后端</span></span><br><span class="line">	snapshot, err = ss.Load()</span><br><span class="line">	<span class="comment">// 调用restartNode方法重启节点</span></span><br><span class="line">	id, cl, n, s, w = restartNode(cfg, snapshot)</span><br><span class="line">	<span class="comment">// 其再从wal内进一步恢复内容</span></span><br><span class="line">	<span class="keyword">default</span>:   <span class="comment">//异常情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建完<code>raft.Node</code>并绑定相应<strong>raft</strong>后，继续初始化:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">|- stats.NewServerStats <span class="comment">// 初始化统计计数</span></span><br><span class="line">|- stats.NewLeaderStats</span><br><span class="line">|- heartbeat := time.Duration(cfg.TickMs) * time.Millisecond <span class="comment">// 初始化心跳参数</span></span><br><span class="line">|- 创建 <span class="string">`EtcdServer`</span>：同时创建 <span class="string">`RaftNode`</span>、初始化ID生成器</span><br><span class="line">    |- newRaftNode  </span><br><span class="line">|- lease.NewLessor <span class="comment">//创建或恢复租约管理器</span></span><br><span class="line">|- srv.kv = mvcc.New(srv.getLogger(), srv.be, srv.lessor, &amp;srv.consistIndex) <span class="comment">// 创建KV存储器，其封装了backend、TreeIndex、Lessor，另外其内部也运行着 Watch 机制。（后续独立章节详细解析）</span></span><br><span class="line">|- srv.applyV3Base = srv.newApplierV3Backend() <span class="comment">// 创建 ApplierV3 接口实现，其用于处理v3 raft消息，为应用层的操作。</span></span><br><span class="line">|- restoreAlarms <span class="comment">// 恢复报警设置，如要是节点存储的报警：如空间不足、崩溃</span></span><br><span class="line">|- tr := &amp;rafthttp.Transport&#123;...&#125; <span class="comment">// 创建Transporter，其用于向其他节点发送raft消息，并从其他节点获取raft消息。</span></span><br><span class="line">|- 每个remotes执行：tr.AddRemote(m.ID, m.PeerURLs) <span class="comment">// 初始化与每个Learner的通信</span></span><br><span class="line">|- 每个Members执行：tr.AddPeer(m.ID, m.PeerURLs) <span class="comment">// 初始化与每个Member节点的通信</span></span><br></pre></td></tr></table></figure>
<p>下面来看<code>raftNode</code>的详细创建过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">newRaftNode(</span><br><span class="line">	raftNodeConfig&#123;</span><br><span class="line">		Node:        n,</span><br><span class="line">		heartbeat:   heartbeat,</span><br><span class="line">		raftStorage: s,</span><br><span class="line">		storage:     NewStorage(w, ss),</span><br><span class="line">	&#125;,</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newRaftNode</span><span class="params">(cfg raftNodeConfig)</span> *<span class="title">raftNode</span></span> &#123;</span><br><span class="line">	r := &amp;raftNode&#123;</span><br><span class="line">		lg:             cfg.lg,</span><br><span class="line">		tickMu:         <span class="built_in">new</span>(sync.Mutex),</span><br><span class="line">		raftNodeConfig: cfg,</span><br><span class="line">		td:         contention.NewTimeoutDetector(<span class="number">2</span> * cfg.heartbeat),</span><br><span class="line">		readStateC: <span class="built_in">make</span>(<span class="keyword">chan</span> raft.ReadState, <span class="number">1</span>),</span><br><span class="line">		msgSnapC:   <span class="built_in">make</span>(<span class="keyword">chan</span> raftpb.Message, maxInFlightMsgSnap),</span><br><span class="line">		applyc:     <span class="built_in">make</span>(<span class="keyword">chan</span> apply),</span><br><span class="line">		stopped:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		done:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 开始心跳 Ticker</span></span><br><span class="line">	r.ticker = time.NewTicker(r.heartbeat)</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出<code>raftNode</code>和<code>raft.node</code>之间的关系。通过<code>raftNode</code>可以直接访问<code>raft.node</code>的所有公有方法。</p>
<p>回到 <code>startNode</code> 方法，我们以新集群且没有<code>WAL</code>文件的场景来了解下<code>startNode</code>的处理过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">etcdserver/raft.<span class="keyword">go</span>/startNode</span><br><span class="line">|- wal.Create() <span class="comment">// 创建 WAL文件</span></span><br><span class="line">|- raft.NewMemoryStorage()  <span class="comment">// 创建raft的数据存储器，这里为内存储存</span></span><br><span class="line">|- n = raft/node.<span class="keyword">go</span>/StartNode(c, peers) <span class="comment">// 开始节点</span></span><br><span class="line">    |- r := newRaft(c) <span class="comment">// 为当前节点创建raft对象</span></span><br><span class="line">    |- r.becomeFollower(<span class="number">1</span>, None) <span class="comment">//初始化当前节点成为 follower角色</span></span><br><span class="line">    |- 对每个节点，追加一条<span class="string">`ConfChangeAddNode`</span>配置更改记录到 raftLog中</span><br><span class="line">    |- r.raftLog.committed = r.raftLog.lastIndex() <span class="comment">// 更新raftLog的提交索引</span></span><br><span class="line">    |-  <span class="keyword">for</span> each peer r.addNode(peer.ID) <span class="comment">//为每个peer在Raft中创建一个Progress结构体（没有创建时，若创建了则设置状态）来，来保存该peer的数据复制状态</span></span><br><span class="line">    |- 创建一个raft/node节点 <span class="comment">// 创建node结构体，初始化各种通道</span></span><br><span class="line">    |- 异步执行 node.run(r *raft)方法<span class="comment">// 其内部主要执行事项包括：轮训raft内需要周知其他节点的信息进行发送，监听node的各种通道（请求和响应）作相应处理，和任务超时通知通道</span></span><br></pre></td></tr></table></figure>
<p>下面我们来详细了解下<strong>newRaft</strong>的内容：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">newRaft(c *Config) *raft</span><br><span class="line">|- c.validate() <span class="comment">// 相关参数的校验，比如选举超时时间设置必须大于心跳超时时间设置</span></span><br><span class="line">|- raftlog := newLogWithSize(c.Storage, c.Logger, c.MaxCommittedSizePerReady) <span class="comment">// 创建raftLog结构体，其用于保存raft状态机信息，比如当前节点事务提交的最大log位置、已经应用到应用的最大索引位置、所有未提交不稳定的记录</span></span><br><span class="line">|- <span class="string">`创建raft结构体`</span></span><br><span class="line">|- 对于每个决策节点 <span class="string">`peers`</span>，设置复制初始<span class="string">`Next`</span>位置、复制滑动串口器</span><br><span class="line">|- 对于非决策节点 <span class="string">`learnerPrs`</span>，也进行初始化</span><br><span class="line">|- r.becomeFollower(r.Term, None) <span class="comment">// 将自身设置为 Follower角色，对于一个刚启动的节点，这里Term为0</span></span><br><span class="line">|-</span><br></pre></td></tr></table></figure>
<p>接下来，再来看 <code>becomeFollower</code> 方法，其设置了 <strong>step</strong> 方法和 <strong>tick</strong> 方法、设置了 <code>raft</code>所在任期以及<code>raft</code>的角色状态。我们都知道<code>raft</code>协议中共有三个角色<code>Follower</code>、<code>Candidates</code>、<code>Leader</code>。<code>etcd</code>中通过不同角色设置不同的<code>step</code>来区分开每个角色的处理逻辑，设置不同<code>tick</code>方法来设置超时任务（对于<code>Follower</code>角色，其超时后会发起新一轮选举，而对于<code>Leader</code>角色，则广播一次心跳消息… ）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *raft)</span> <span class="title">becomeFollower</span><span class="params">(term <span class="keyword">uint64</span>, lead <span class="keyword">uint64</span>)</span></span> &#123;</span><br><span class="line">	r.step = stepFollower</span><br><span class="line">	r.reset(term)</span><br><span class="line">	r.tick = r.tickElection</span><br><span class="line">	r.lead = lead</span><br><span class="line">	r.state = StateFollower</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *raft)</span> <span class="title">becomeCandidate</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r.step = stepCandidate</span><br><span class="line">	r.reset(r.Term + <span class="number">1</span>)</span><br><span class="line">	r.tick = r.tickElection</span><br><span class="line">	r.Vote = r.id</span><br><span class="line">	r.state = StateCandidate</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *raft)</span> <span class="title">becomeLeader</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r.step = stepLeader</span><br><span class="line">	r.reset(r.Term)</span><br><span class="line">	r.tick = r.tickHeartbeat</span><br><span class="line">	r.lead = r.id</span><br><span class="line">	r.state = StateLeader</span><br><span class="line">	r.prs[r.id].becomeReplicate()</span><br><span class="line">	r.pendingConfIndex = r.raftLog.lastIndex()</span><br><span class="line">	emptyEnt := pb.Entry&#123;Data: <span class="literal">nil</span>&#125;</span><br><span class="line">	r.reduceUncommittedSize([]pb.Entry&#123;emptyEnt&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，就完成了 <strong>EtcdServer</strong>的创建。</p>
<p>接下来，再来看<code>EtcdServer</code>的开始方法<code>Start</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EtcdServer/Start</span><br><span class="line">    s.start() <span class="comment">// 启动</span></span><br><span class="line">	s.goAttach(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; s.adjustTicks() &#125;) <span class="comment">// 调整频率，启动时加快选举</span></span><br><span class="line">	s.goAttach(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; s.publish(s.Cfg.ReqTimeout()) &#125;) <span class="comment">// 发布节点属性信息，以遍其他节点可查询</span></span><br><span class="line">	s.goAttach(s.purgeFile) <span class="comment">// 启动异步任务做文件的合并操作：db文件\snap文件\WAL文件</span></span><br><span class="line">	s.goAttach(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; monitorFileDescriptor(s.getLogger(), s.stopping) &#125;) <span class="comment">// 监控文件句柄数不能超过系统限制的80%</span></span><br><span class="line">	s.goAttach(s.monitorVersions)</span><br><span class="line">	s.goAttach(s.linearizableReadLoop) <span class="comment">// 线性一致性读异步任务（后续详细讲解）</span></span><br><span class="line">	s.goAttach(s.monitorKVHash)</span><br></pre></td></tr></table></figure>
<p><code>EtcdServer.start()</code>方法，首先进行一系列通道的初始化，然后异步执行<code>EtcdServer.run()</code>方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EtcdServer.run</span><br><span class="line">|- sched := schedule.NewFIFOScheduler() <span class="comment">//首先创建一个先进先出的异步调度器</span></span><br><span class="line">|- rh := &amp;raftReadyHandler&#123;...&#125; <span class="comment">// 创建一个raftReadHanlder用于处理一些节点信息操作的回调。</span></span><br><span class="line">|- s.raftNode.start(rh) <span class="comment">// 启动raftNode的异步处理流程</span></span><br><span class="line">|- 开启循环，监听 raftNode的 applyC通道 以及租约过期通道 <span class="string">`s.lessor.expiredC`</span>。</span><br><span class="line">    |- 对于 <span class="string">`applyC`</span>，当从其中获取消息时，通过先进先出异步调度器顺序执行 applyAll方法</span><br><span class="line">    |- 对于</span><br></pre></td></tr></table></figure>
<p>展开 <code>raftNode.start(rh)</code>的逻辑如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-r.ticker.C: <span class="comment">// 监听超时通知通道</span></span><br><span class="line">		r.tick()</span><br><span class="line">	<span class="keyword">case</span> rd := &lt;-r.Ready(): <span class="comment">// 监听 raft.node的readyC通道，其为需要发送给其他节点或广播的消息</span></span><br><span class="line">	<span class="comment">// 根据消息更新自身状态</span></span><br><span class="line">	<span class="comment">// 然后应用到状态机中，最后发送给其他节点（非主节点时）或广播给其他节点（主节点）</span></span><br><span class="line">		<span class="keyword">if</span> rd.SoftState != <span class="literal">nil</span> &#123;</span><br><span class="line">		  <span class="comment">// 判断是否需要更新主节点信息</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(rd.ReadStates) != <span class="number">0</span> &#123;</span><br><span class="line">		  <span class="comment">// 对于线性一致性读，进行通知回调</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		notifyc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">      <span class="comment">// 通过rh来更新提交索引号</span></span><br><span class="line">		updateCommittedIndex(&amp;ap, rh)</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> r.applyc &lt;- ap:</span><br><span class="line">		<span class="keyword">case</span> &lt;-r.stopped:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> islead &#123;</span><br><span class="line">			r.transport.Send(r.processMessages(rd.Messages))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := r.storage.Save(rd.HardState, rd.Entries); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		r.raftStorage.Append(rd.Entries)</span><br><span class="line">		<span class="keyword">if</span> !islead &#123;</span><br><span class="line">			msgs := r.processMessages(rd.Messages)</span><br><span class="line">	       <span class="comment">// ...</span></span><br><span class="line">			r.transport.Send(msgs)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			notifyc &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		r.Advance()</span><br><span class="line">	<span class="keyword">case</span> &lt;-r.stopped:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>完成<code>etcdServer</code>的启动后，开始<code>http/grpc</code>服务对外提供服务（<code>peer</code>间的服务以及对<code>client</code>开放的服务）。<br>我们以<code>servePeers()</code>来讲解启动服务过程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">servePeers()</span><br><span class="line">|- etcdhttp.NewPeerHandler <span class="comment">//创建 `http.Handler`，用于处理 节点间 以`raft`、`raft/`、`/leases`、`/leases/internal`为前缀的http请求</span></span><br><span class="line">|- 对于每个 <span class="string">`e.Peers`</span>：执行以下操作</span><br><span class="line">    |- gs := v3rpc.Server(e.Server, peerTLScfg) <span class="comment">// 创建grpcServer，然后注册服务描述信息，如kv、watch、lease、cluster、auth、maintenance。</span></span><br><span class="line">    |- m := cmux.New(p.Listener) <span class="comment">// 创建连接多路转接器，用于转发连接到不同的服务里去处理，其工作原理后续讲解</span></span><br><span class="line">    |- <span class="keyword">go</span> gs.Serve(m.Match(cmux.HTTP2())) <span class="comment">// 筛选出http2的链接，并对其服务</span></span><br><span class="line">    |- <span class="keyword">go</span> srv.Serve(m.Match(cmux.Any())) <span class="comment">//对于剩下的连接，用http服务进行处理</span></span><br><span class="line">|- 对每个 <span class="string">`e.Peers`</span>.serve() 启动监听服务</span><br></pre></td></tr></table></figure>
<p>当新连接到达时，处理流程如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cMux.Server()</span><br><span class="line">|- c, err := m.root.Accept() <span class="comment">// 通过最原始的方式获取到达的连接</span></span><br><span class="line">|- m.serve(c, m.donec, &amp;wg) <span class="comment">// 执行serve进行分发</span></span><br><span class="line">    |- <span class="keyword">for</span> _, sl := <span class="keyword">range</span> m.sls &#123;<span class="comment">// sl包装了 其自身的匹配器列表，和转发通道</span></span><br><span class="line">		<span class="keyword">for</span> _, s := <span class="keyword">range</span> sl.ss &#123;<span class="comment">// s为通过cMux.Match方法创建的匹配器</span></span><br><span class="line">			matched := s(muc.Conn, muc.startSniffing())</span><br><span class="line">			<span class="keyword">if</span> matched &#123; <span class="comment">// 若该连接匹配上了，则将该连接通过连接发送到sl的连接接收通道里</span></span><br><span class="line">				<span class="comment">//...</span></span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> sl.l.connc &lt;- muc:</span><br><span class="line">				<span class="keyword">case</span> &lt;-donec:</span><br><span class="line">					_ = c.Close()</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>到此整个初始化过程就完成了。其后开始进行选举，那么选举是哪里出发的呢？<br>回到创建<code>raftNode</code>的地方 <code>r.ticker = time.NewTicker(r.heartbeat)</code> 开启了ticker。当时间到达时，tickder.C中得到通知。而其正在被 <code>raftNode</code>的<code>start</code>方法中的循环监听着。进一步就触发了<code>raftNoe.tick()</code>方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">raftNoe.tick()</span><br><span class="line">|- node.Tick()方法， 之前介绍过 raftNode与node之间的关系</span><br><span class="line">    |- n.tickc &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; 通知 node.tickc通道</span><br><span class="line">    |- node的run循环中监听此通道，进一步调用 <span class="string">`raft.tick()`</span>方法。此方法在 <span class="string">`becomeFollower`</span>时设置成了 <span class="string">`tickElection`</span></span><br><span class="line">    |- r.Step(pb.Message&#123;From: r.id, Type: pb.MsgHup&#125;) <span class="comment">// 到此开始发起选举</span></span><br><span class="line">    |- r.campaign(campaignElection) <span class="comment">// 开始角逐 主节点角色</span></span><br><span class="line">        |- r.becomeCandidate <span class="comment">// 更改节点角色为 候选者</span></span><br><span class="line">            |- r.step = stepCandidate...</span><br><span class="line">        |- r.send(pb.Message&#123;Term: term, To: id, Type: voteMsg, Index: rL.lastIndex, LogTerm: r.raftLog.lastTerm(), Context: ctx&#125;) <span class="comment">// 对每个节点发送 `pb.MsgVote` 消息 携带本节点的任期，索引</span></span><br></pre></td></tr></table></figure>
<p>当其他接收到该节点的投票请求时：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">peer.<span class="keyword">go</span>/startPeer(<span class="number">180</span>L)</span><br><span class="line">|- etcdServer.Pocess <span class="comment">// 转发到ectdServer进行处理</span></span><br><span class="line">    |- node.Step <span class="comment">// 调用 raftNode，并间接调用 raft.node</span></span><br><span class="line">        |- node.stepWithWaitOption</span><br><span class="line">            |- raft.Step</span><br><span class="line">                |- 首先进行判断是否可投票（是否已经投给了这个需要投票的人|| 没投票，且没有主|| 消息的任期比本节点大）</span><br><span class="line">                |- 判断是否要投票给请求投票的节点（请求节点任期比本节点大，或者任期相等时索引Id是否比本节点大）</span><br><span class="line">                |- 上面条件都满足时，返回<span class="string">`MsgVoteResp`</span>消息，告诉请求者，其同意投票给它</span><br><span class="line">                |- 但上述条件不满足时，则返回 拒绝消息给请求者</span><br></pre></td></tr></table></figure>

<p>当节点收到 其他的投票反馈消息时，最终会调用 <code>raft.go/stepCandidate</code>方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// poll方法传进去本消息的投票，返回已经有多少赞成票</span></span><br><span class="line">gr := r.poll(m.From, m.Type, !m.Reject)</span><br><span class="line"><span class="keyword">switch</span> r.quorum() &#123;<span class="comment">// 当达到quorum个时，进行角色转变</span></span><br><span class="line"><span class="keyword">case</span> gr:</span><br><span class="line">	<span class="keyword">if</span> r.state == StatePreCandidate &#123;</span><br><span class="line">		r.campaign(campaignElection)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	   <span class="comment">// 转换为主节点</span></span><br><span class="line">		r.becomeLeader()</span><br><span class="line">		<span class="comment">// 广播消息</span></span><br><span class="line">		r.bcastAppend()</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="built_in">len</span>(r.votes) - gr:</span><br><span class="line">	r.becomeFollower(r.Term, None)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的逻辑，可以看出，当投票数达到quorum数时，转变角色为主节点。同时向所有其他节点广播本节点状态以及记录信息（MsgApp），其他节点接收到此消息后，自动转变为 follower角色，整个集群初始化完成。</p>
<p>对于<code>etcd</code>的选举，还需要说明的是，<code>etcd</code>为了某些网络分区的问题了设置<code>PreVote</code>流程（只需要启动节点的时候 设置 <code>pre-vote</code> 参数）。即在进行真正的选举之前 先进行<code>PreVote</code>得到大多数节点同意选举之后才进行真正的选举。可以解决如下问题：</p>
<ul>
<li>对于网络分区的节点，在重新加入集群的时候不会中断集群；（因为获取不了大部分节点的许可，索引其<code>Term</code>无法增大，所以赢不了选举主节点）。</li>
</ul>
<p>到此，<strong>etcd</strong>的启动到建立集群、完成选举的整个过程就介绍完了。</p>
<p>附加图：<br>下图为 <code>EtcdServer</code>、<code>raftNode</code>、<code>raft.node</code>、<code>raft</code>间的联系。<br><img src="/media/15512352647387.jpg" alt=""></p>
<p>最后补充说明下<code>etcd</code>的<code>proxy</code>模式：<br><code>etcd</code>可以通过命令<code>./etcd –proxy on  –listen-client-urls</code>的形式启动代理模式。代理模式下，它的作用是一个反向代理，接收客户端请求，然后转发到<code>etcd</code>集群。<br>代理模式有2种运行形式：<code>readwrite</code>和<code>readonly</code>，默认情况下为<code>readwrite</code>，即会将读写请求都进行转发，而<code>readonly</code>形式下，则只转发读请求，写请求将报<code>5xx</code>错误，</p>
<p><strong>IDEA</strong>中启动ETCD方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">debug方式运行三个终端程序 <span class="string">`etcd/main.go`</span> 并设置如下参数：</span><br><span class="line">--name infra1 --listen-client-urls http:<span class="comment">//127.0.0.1:2379 --advertise-client-urls http://127.0.0.1:2379 --listen-peer-urls http://127.0.0.1:12380 --initial-advertise-peer-urls http://127.0.0.1:12380 --initial-cluster-token etcd-cluster-1 --initial-cluster infra1=http://127.0.0.1:12380,infra2=http://127.0.0.1:22380,infra3=http://127.0.0.1:32380 --initial-cluster-state new --enable-pprof --logger=zap --log-outputs=stderr</span></span><br><span class="line">--name infra2 --listen-client-urls http:<span class="comment">//127.0.0.1:22379 --advertise-client-urls http://127.0.0.1:22379 --listen-peer-urls http://127.0.0.1:22380 --initial-advertise-peer-urls http://127.0.0.1:22380 --initial-cluster-token etcd-cluster-1 --initial-cluster infra1=http://127.0.0.1:12380,infra2=http://127.0.0.1:22380,infra3=http://127.0.0.1:32380 --initial-cluster-state new --enable-pprof --logger=zap --log-outputs=stderr</span></span><br><span class="line">--name infra3 --listen-client-urls http:<span class="comment">//127.0.0.1:32379 --advertise-client-urls http://127.0.0.1:32379 --listen-peer-urls http://127.0.0.1:32380 --initial-advertise-peer-urls http://127.0.0.1:32380 --initial-cluster-token etcd-cluster-1 --initial-cluster infra1=http://127.0.0.1:12380,infra2=http://127.0.0.1:22380,infra3=http://127.0.0.1:32380 --initial-cluster-state new --enable-pprof --logger=zap --log-outputs=stderr</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2019/11/19/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/etcd/1.etcd-%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/19/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/etcd/1.etcd-%E7%AE%80%E4%BB%8B/" itemprop="url">ETCD简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-19T00:00:00+08:00">2019-11-19</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/etcd/" itemprop="url" rel="index"><span itemprop="name">etcd</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0-ETCD简介"><a href="#0-ETCD简介" class="headerlink" title="0. ETCD简介"></a>0. ETCD简介</h1><p>本文将从以下几个方面来分析 ETCD （<code>v3.3.12</code>）。</p>
<ol start="0">
<li>整体架构</li>
<li>启动过程</li>
<li>数据存储</li>
<li>通信方式</li>
<li>TTL实现原理</li>
<li>Lease实现原理</li>
<li>单次事务过程</li>
<li>线性一致性读过程</li>
<li>Watch机制</li>
</ol>
<!--9. 运维相关：
    1. 主宕机
    2. 从宕机
    3. 添加新节点-->

<p>在介绍上面所有过程之前，我们先来介绍下 <strong>ETCD</strong>的整体架构以及相关名词术语。</p>
<!--[1.ETCD原理](https://www.cnblogs.com/panpanwelcome/p/8242418.html)-->


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- Node：一个Raft状态机节点；</span><br><span class="line">- Proxy：etcd的一种模式，为etcd集群提供反向代理服务；</span><br><span class="line">- Member： etcd集群中的一个节点。它可以与其他节点进行交互且为客户端提供服务；</span><br><span class="line">- Cluster：由多个Member组成的etcd集群；</span><br><span class="line">- Peer：对处在相同集群中其他节点的称呼；</span><br><span class="line">- Client： 请求客户端；</span><br><span class="line">- Candidate	候选人</span><br><span class="line">- Leader	领导者</span><br><span class="line">- Follower	跟随者</span><br><span class="line">- Term	选举任期，每次选举之后递增1</span><br><span class="line">- Index：索引号，Raft中通过Term和Index来定位数据。</span><br><span class="line">- Vote	选举投票(的ID)</span><br><span class="line">- Commit	提交</span><br><span class="line">- Propose	提议</span><br><span class="line">- WAL：预写式日志</span><br><span class="line">- SoftState：软状态，软状态易变且不需要保存在WAL日志中的状态数据，包括：集群leader、节点的当前状态</span><br><span class="line">- HardState：硬状态，与软状态相反，需要写入持久化存储中，包括：节点当前Term、Vote、Commit</span><br><span class="line">- ReadStates：用于读一致性的数据，后续会详细介绍</span><br><span class="line">- Entries：在向其他集群发送消息之前需要先写入持久化存储的日志数据</span><br><span class="line">- Snapshot：需要写入持久化存储中的快照数据</span><br><span class="line">- CommittedEntries：需要输入到状态机中的数据，这些数据之前已经被保存到持久化存储中了</span><br><span class="line">- Messages：在entries被写入持久化存储中以后，需要发送出去的数据</span><br></pre></td></tr></table></figure>
<p><code>peer</code>间通信消息类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- MsgHup            &#x2F;&#x2F; 不用于节点间通信，仅用于发送给本节点让本节点进行选举</span><br><span class="line">- MsgBeat           &#x2F;&#x2F; 心跳消息</span><br><span class="line">- MsgProp           &#x2F;&#x2F; raft库使用者提议（propose）数据</span><br><span class="line">- MsgApp            &#x2F;&#x2F; 用于leader向集群中其他节点同步数据的消息</span><br><span class="line">- MsgAppResp        &#x2F;&#x2F; 消息同步回复</span><br><span class="line">- MsgVote           &#x2F;&#x2F; 请求投票</span><br><span class="line">- MsgVoteResp       &#x2F;&#x2F; 投票反馈</span><br><span class="line">- MsgSnap           &#x2F;&#x2F; 用于leader向follower同步数据用的快照消息</span><br><span class="line">- MsgHeartbeat      &#x2F;&#x2F; 心跳消息</span><br><span class="line">- MsgHeartbeatResp  &#x2F;&#x2F; 心跳回复消息</span><br><span class="line">- MsgTransferLeader &#x2F;&#x2F; 转移主节点</span><br><span class="line">- MsgReadIndex      &#x2F;&#x2F; 用于线性一致性读</span><br><span class="line">- MsgReadIndexResp  </span><br><span class="line">- MsgPreVote        &#x2F;&#x2F; 请求预先投票</span><br><span class="line">- MsgPreVoteResp</span><br></pre></td></tr></table></figure>

<p><code>Etcd</code>整体架构图如下：<br><img src="/media/15518040419086.jpg" alt=""><br>下面将简单介绍下：</p>
<ol>
<li><code>etcd</code>面向<code>client</code>和<code>peer</code>节点开放<code>http</code>服务以及<code>grpc</code>服务，对于像<code>watch</code>机制就是基于<code>grpc</code>的<code>stream</code>通信模式实现的；</li>
<li><code>EtcdServer</code>是<code>etcd</code>上层结构体，其负责对外提供服务，且负责应用层的实现，比如操作应用层存储器，管理<code>leassor</code>、<code>watch</code>；</li>
<li><code>raftNode</code>负责上层与<code>raft</code>层的衔接。其负责将应用的需求传递到<code>raft</code>中进行处理（通过<code>Step</code>函数）、在消息发送到其他节点前将消息保存到<code>WAL</code>中、调用传输器发送消息；</li>
<li><code>raft</code>是<code>raft</code>协议的承载者；</li>
<li><code>raftLog</code>用于存储状态机信息：<code>memoryStorge</code>保存稳定的记录，<code>unstable</code>保存不稳定的记录。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2019/10/15/istio/3.istio-mcp&galley/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/15/istio/3.istio-mcp&galley/" itemprop="url">Istio MCP&Galley</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T00:00:00+08:00">2019-10-15</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/istio/" itemprop="url" rel="index"><span itemprop="name">istio</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="MCP协议-amp-Galley"><a href="#MCP协议-amp-Galley" class="headerlink" title="MCP协议&amp;Galley"></a>MCP协议&amp;Galley</h1><p>[TOC]</p>
<h2 id="MCP协议"><a href="#MCP协议" class="headerlink" title="MCP协议"></a>MCP协议</h2><ul>
<li><code>MCP</code>协议全称是 <code>Mesh Configuration Protocol</code>。</li>
<li>在<code>Istio</code>历史版本里，基于<code>k8s</code>来存储数据导致其与<code>k8s</code>耦合，限制了<code>Istio</code>的拓展性（非<code>k8s</code>机制则无法使用）。</li>
<li><code>MCP</code>协议的出现即是为了解决与<code>k8s</code>耦合的问题。<code>MCP</code>定义了一套配置订阅与下发的标准协议，<code>Pilot</code>和<code>Mixer</code> 作为<code>MCP client</code>，任何实现了<code>MCP</code>协议的Server(如<code>Galley</code>)通过 <code>MCP协议</code>向<code>Pilot</code>下发配置。</li>
</ul>
<p><code>MCP</code>中对配置生生产者和消费者进行了如下抽象：</p>
<ul>
<li><code>source</code>：配置源，即<code>Istio</code>的<code>Galley</code>(配置中心)，对应的是Grpc中定义的 <strong>Service:</strong> <code>ResourceSource</code>；</li>
<li><code>sink</code>：配置消费者，即<code>Istio</code>中的<code>Pilot</code>、<code>Mixer</code>，对应的Grpc中定义的<code>ResourceSink</code>；</li>
<li><code>resource</code>：配置资源的抽象定义。</li>
</ul>
<hr>
<ol>
<li>通常情况下，<code>source</code>作为Grpc的server，提供<code>ResourceSource</code>服务；<code>sink</code>作为Grpc的client，提供<code>ResourceSink</code>服务，<code>sink</code>主动向<code>source</code>发起连接，请求资源。当有资源更新时<code>source</code>将信息push给<code>sink</code>；</li>
<li>但<code>MCP</code>也支持一些特殊场景，<code>Source</code> 作为<strong>Client</strong> 向<code>Sink</code> <strong>Server</strong>建立新连接，然后<code>Sever</code>向<code>Client</code>发起资源请求（实际还是<code>Sink</code>请求<code>Source</code>，只是<code>Sink</code>作为Server，让<code>Source</code>连上来）。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">participant Sink(Pilot|Mixer) as sink</span><br><span class="line">participant Source(Galley) as source</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">note right of sink: stream established</span><br><span class="line">sink-&gt;source:conn:&#x3D; grpc.Dial</span><br><span class="line">sink-&gt;source: svc:&#x3D;mcp.NewResourceSourceService(conn)</span><br><span class="line">sink-&gt;source: stream:&#x3D;svc.EstablishResourceStream()</span><br><span class="line">sink-&gt;source: stream:&#x3D;stream.Send(RequestResources)</span><br><span class="line">source--&gt;sink: Resources:&#x3D; stream.Recv()</span><br><span class="line"></span><br><span class="line">note right of sink: request Resources</span><br><span class="line">sink-&gt;source: stream:&#x3D; RequestResources&#123;Collection&#x3D;VirtualService,nonce&#x3D;&#125;</span><br><span class="line">source--&gt;sink: Resources&#123;Collection&#x3D;VirtualService, nonce&#x3D;1, reources&#x3D;&#123;&#123;foo,v1&#125;,&#123;bar,v2&#125;&#125;&#125;</span><br><span class="line">sink-&gt;source: stream:&#x3D; RequestResources&#123;Collection&#x3D;VirtualService,nonce&#x3D;1&#125;(ACK)</span><br><span class="line"></span><br><span class="line">note right of sink: push Resources</span><br><span class="line">source--&gt;sink: Resources&#123;Collection&#x3D;VirtualService, nonce&#x3D;2, reources&#x3D;&#123;&#123;foo,v2&#125;,&#123;bar,v3&#125;&#125;&#125;</span><br><span class="line">sink-&gt;source: stream:&#x3D; RequestResources&#123;Collection&#x3D;VirtualService,nonce&#x3D;2&#125;(ACK)</span><br><span class="line"></span><br><span class="line">note right of sink: error Push</span><br><span class="line">source--&gt;sink: Resources&#123;Collection&#x3D;VirtualService, nonce&#x3D;3, reources&#x3D;&#123;&#123;foo,v3&#125;,&#123;bar,v4&#125;&#125;&#125;</span><br><span class="line">sink-&gt;source: stream:&#x3D; RequestResources&#123;Collection&#x3D;VirtualService,nonce&#x3D;3&#125;(NACK)</span><br></pre></td></tr></table></figure>

<p><code>MCP</code>中<code>Sink</code>与<code>Source</code>交互接口定义：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ResourceSource_EstablishResourceStreamClient <span class="keyword">interface</span> &#123;</span><br><span class="line">	Send(*RequestResources) error</span><br><span class="line">	Recv() (*Resources, error)</span><br><span class="line">	grpc.ClientStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Galley"><a href="#Galley" class="headerlink" title="Galley"></a>Galley</h2><p>前面介绍了 <code>MCP</code> 协议，接下来我们先介绍下<code>Galley</code>以及其工作原理，然后再以其与<code>Pilot</code>的交互流程讲解 <code>MCP</code> 的工作原理。</p>
<p><code>Galley</code> 主要负责两方面的功能：<strong>配置验证</strong>（校验配置的正确性）以及<strong>配置管理</strong>（<code>输入、转换、分发</code>）</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><code>Galley</code>启动入口位置：<code>galley/cmd/galley/main.go</code>。<br>首先，创建<code>server.Args</code>，通过参数初始化之后调用<code>server.New</code>创建<code>Galley</code><strong>Server</strong>。然后调用其<code>Start</code>方法开启<code>Galley</code>服务。</p>
<p>创建<code>Server</code>的处理过程如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(a *settings.Args)</span> *<span class="title">Server</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建存活探针</span></span><br><span class="line">	liveness := components.NewProbe(&amp;a.Liveness)</span><br><span class="line">	s.host.Add(liveness)</span><br><span class="line">	 <span class="comment">// 创建可读探针</span></span><br><span class="line">	readiness := components.NewProbe(&amp;a.Readiness)</span><br><span class="line">	s.host.Add(readiness)</span><br><span class="line">	<span class="comment">// 创建配置校验管理器</span></span><br><span class="line">	validation := components.NewValidation(a.KubeConfig, a.ValidationArgs, liveness.Controller(), readiness.Controller())</span><br><span class="line">	s.host.Add(validation)</span><br><span class="line">	<span class="comment">// 创建配置处理器</span></span><br><span class="line">	<span class="keyword">if</span> a.UseOldProcessor &#123;</span><br><span class="line">		s.p = components.NewProcessing(a)</span><br><span class="line">		s.host.Add(s.p)</span><br><span class="line">		t := s.p.ConfigZTopic()</span><br><span class="line">		topics = <span class="built_in">append</span>(topics, t)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		s.p2 = components.NewProcessing2(a)</span><br><span class="line">		s.host.Add(s.p2)</span><br><span class="line">		t := s.p2.ConfigZTopic()</span><br><span class="line">		topics = <span class="built_in">append</span>(topics, t)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建监控接口</span></span><br><span class="line">	mon := components.NewMonitoring(a.MonitoringPort)</span><br><span class="line">	s.host.Add(mon)</span><br><span class="line">	<span class="comment">// 与Pilot一样，ControlZ 运维接口</span></span><br><span class="line">	clz := components.NewCtrlz(a.IntrospectionOptions, topics...)</span><br><span class="line">	s.host.Add(clz)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Galley</code> 让所有组件都实现 <code>Component</code>接口，其定义了<code>Start</code>方法和<code>Stop</code>方法。<code>Server</code>创建所有组件后执行所有组件的<code>Start</code>方法，当<code>Server</code>要退出时执行<code>Stop</code>方法。</p>
<hr>
<h3 id="配置校验器"><a href="#配置校验器" class="headerlink" title="配置校验器"></a>配置校验器</h3><p><code>Istio</code> 中配置非常之多，而 <code>Istio</code> 配置数据的主要来源是 <code>k8s</code>。在 <code>k8s</code> 中创建各种类型的配置 <code>CRD</code> 资源，<code>Istio</code> 通过监听这种类型资源进行处理转换后下发给 <code>Envoy</code>。配置资源如果任意设置可能会导致意想不到的结果，而 <code>k8s</code> 提供了一种叫<code>Admission WebHooks</code>的拓展，用来支持对配置的验证工作。<br>工作原理如下：</p>
<ul>
<li>向<code>k8s</code>中注入用于准入的 <code>WebHookConfiguration</code>（配置校验服务器信息），在<code>k8s</code>中有配置输入时，会向配置的校验服务器发起准入请求；</li>
<li>校验服务器会拿到请求中的资源信息，根据其配置的规则进行校验，若不通过，则返回告诉<code>k8s</code>拒绝，并输入具体信息；否则返回成功。</li>
</ul>
<p><img src="/media/15776177806339.jpg" alt=""></p>
<h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">webhookServerReady := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> params.EnableValidation &#123;</span><br><span class="line">    <span class="comment">//创建与运行校验模块</span></span><br><span class="line">	<span class="keyword">go</span> validation.RunValidation(webhookServerReady, stopCh, params, kubeConfig, liveness, readiness)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> params.EnableReconcileWebhookConfiguration &#123;</span><br><span class="line">    <span class="comment">//创建ValidatingWebhookConfiguration，并向k8s注入此WebhookConfiguration</span></span><br><span class="line">	<span class="keyword">go</span> validation.ReconcileWebhookConfiguration(webhookServerReady, stopCh, params, kubeConfig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其过程分为两步：创建并运行校验模块，当校验模块就绪后向 <code>k8s</code> 注入<code>WebhookConfiguration</code>。<br>首先，先看校验模块的初始化过程：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RunValidation</span><span class="params">(ready <span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125;, stopCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, vc *WebhookParameters, kubeConfig <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	livenessProbeController, readinessProbeController probe.Controller)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建默认的Mixer的校验器</span></span><br><span class="line">	mixerValidator := mixervalidate.NewDefaultValidator(<span class="literal">false</span>)</span><br><span class="line">	<span class="comment">// 创建与k8s交互的客户端</span></span><br><span class="line">	clientset, err := kube.CreateClientset(kubeConfig, <span class="string">""</span>)</span><br><span class="line">	vc.MixerValidator = mixerValidator</span><br><span class="line">	<span class="comment">// 所有Istio的模型</span></span><br><span class="line">	vc.PilotDescriptor = schemas.Istio</span><br><span class="line">	vc.Clientset = clientset</span><br><span class="line">	<span class="comment">// 创建WebHook处理器，并对外输出http操作接口</span></span><br><span class="line">	wh, err := NewWebhook(*vc)</span><br><span class="line">	   |- wh := &amp;Webhook&#123;</span><br><span class="line">    		server: &amp;http.Server&#123;</span><br><span class="line">    			Addr: fmt.Sprintf(<span class="string">":%v"</span>, p.Port),</span><br><span class="line">    		&#125;,</span><br><span class="line">    		descriptor:                    p.PilotDescriptor,</span><br><span class="line">    		validator:                     p.MixerValidator,</span><br><span class="line">    		clientset:                     p.Clientset,</span><br><span class="line">	   |- h.HandleFunc(<span class="string">"/admitpilot"</span>, wh.serveAdmitPilot)</span><br><span class="line">	   |- h.HandleFunc(<span class="string">"/admitmixer"</span>, wh.serveAdmitMixer)</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">go</span> wh.Run(ready, stopCh)</span><br><span class="line">	   |- <span class="keyword">go</span> wh.server.ListenAndServeTLS(<span class="string">""</span>, <span class="string">""</span>) <span class="comment">// 监听端口</span></span><br><span class="line">	   |-	wh.waitForEndpointReady <span class="comment">// 等待资源初始化完成</span></span><br><span class="line">	       |- store, controller := cache.NewInformer(wh.createInformerEndpointSource(wh.clientset, wh.deploymentAndServiceNamespace, wh.serviceName)...</span><br><span class="line">	       |- <span class="comment">// 等待资源同步完成</span></span><br><span class="line">	       |- cache.WaitForCacheSync(stopCh, controller.HasSynced)</span><br><span class="line">	       |- <span class="comment">//检查节点是否准备就绪：</span></span><br><span class="line">	       |- ready := endpointReady(store, queue, wh.deploymentAndServiceNamespace, wh.serviceName)</span><br><span class="line">	   |-	ready &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">//发送信号标识可以向k8s注册此准入检测点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReconcileWebhookConfiguration</span><span class="params">(webhookServerReady, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">	vc *WebhookParameters, kubeConfig <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	clientset, err := kube.CreateClientset(kubeConfig, <span class="string">""</span>)</span><br><span class="line">	<span class="comment">// 创建 WebhookConfigController</span></span><br><span class="line">	whc, err := NewWebhookConfigController(*vc)</span><br><span class="line">	&lt;-webhookServerReady <span class="comment">// 等待检验模块就绪</span></span><br><span class="line">	whc.reconcile(stopCh)</span><br><span class="line">	   |- whc.rebuildWebhookConfig() <span class="comment">// 跟据配置构建Webhook配置</span></span><br><span class="line">	   |- whc.createOrUpdateWebhookConfig() <span class="comment">// 向`k8s`发起创建`webhook`</span></span><br></pre></td></tr></table></figure>
<p>总结其过程：首先创建默认的校验器，其次创建<code>WebHook</code>监听端口并添加指定路径的处理函数，最后通过查询<code>k8s</code>查询到节点可读时告知<code>WebhookController</code>向<code>k8s</code>注册<code>ValidatingWebhookConfiguration</code>。</p>
<h4 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h4><p>接下来，继续跟进具体的校验逻辑，对于<code>Pilot</code>配置逻辑校验入口<code>admitPilot</code>；而对于<code>Mixer</code>配置逻辑校验入口为<code>admitMixer</code>。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wh *Webhook)</span> <span class="title">admitPilot</span><span class="params">(request *AdmissionRequest)</span> *<span class="title">AdmissionResponse</span></span> &#123;</span><br><span class="line">    <span class="comment">// 只校验创建和修改操作</span></span><br><span class="line">    <span class="keyword">switch</span> request.Operation &#123;</span><br><span class="line">	<span class="keyword">case</span> admissionv1beta1.Create, admissionv1beta1.Update:</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> &amp;admissionv1beta1.AdmissionResponse&#123;Allowed: <span class="literal">true</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 解码，并判断是否是Istio关注的类型，若不是则返回无法识别的类型</span></span><br><span class="line">	<span class="keyword">var</span> obj crd.IstioKind</span><br><span class="line">	yaml.Unmarshal(request.Object.Raw, &amp;obj)</span><br><span class="line">	s, exists := wh.descriptor.GetByType(crd.CamelCaseToKebabCase(obj.Kind))</span><br><span class="line">	<span class="comment">// 进行类型转换</span></span><br><span class="line">	out, err := crd.ConvertObject(s, &amp;obj, wh.domainSuffix)</span><br><span class="line">	<span class="comment">// 调用Schema中配置的Validate进行实体校验</span></span><br><span class="line">	s.Validate(out.Name, out.Namespace, out.Spec)</span><br><span class="line">	<span class="comment">// 对属性进行检查，查看必备字段是否无缺失</span></span><br><span class="line">	checkFields(request.Object.Raw, request.Kind.Kind, request.Namespace, obj.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结，<code>Pilot</code>的校验过程较简单，主要检查：</p>
<ul>
<li>解码是否正常；</li>
<li>是否能转换成Istio类型；</li>
<li>是否符合Schema中配置的<code>Validate</code>函数；</li>
<li>必须属性是否无缺失</li>
</ul>
<p><code>Mixer</code>配置校验过程如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> request.Operation &#123;</span><br><span class="line"><span class="keyword">case</span> admissionv1beta1.Create, admissionv1beta1.Update:</span><br><span class="line">	ev.Type = store.Update</span><br><span class="line">	<span class="keyword">var</span> obj unstructured.Unstructured</span><br><span class="line">	<span class="comment">// 解码</span></span><br><span class="line">	yaml.Unmarshal(request.Object.Raw, &amp;obj)</span><br><span class="line">	ev.Value = mixerCrd.ToBackEndResource(&amp;obj)</span><br><span class="line">	ev.Key.Name = ev.Value.Metadata.Name</span><br><span class="line">  <span class="comment">// 检查必备字段是否无缺失</span></span><br><span class="line">	checkFields(request.Object.Raw, request.Kind.Kind, request.Namespace, ev.Key.Name)</span><br><span class="line"><span class="keyword">case</span> <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ev.Type == store.Update &#123;</span><br><span class="line">    <span class="comment">// 执行校验</span></span><br><span class="line">    wh.validator.Validate(ev)</span><br><span class="line">    |- _, ok := v.kinds[bev.Key.Kind] <span class="comment">// 查看是否关注此类型配置</span></span><br><span class="line">    |- ev, err := store.ConvertValue(*bev, v.kinds) <span class="comment">// 根据类型进行转换成mixer定义的对象</span></span><br><span class="line">    |- v.config.ApplyEvent([]*store.Event&#123;&amp;ev&#125;) <span class="comment">// 应用该变化</span></span><br><span class="line">    |- v.config.BuildSnapshot() <span class="comment">// 基于现有所有配置构建一次快照，若成功代表配置无异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结其过程如下：</p>
<ul>
<li>解码，若解码异常则返回失败</li>
<li>必备字段是否无缺失</li>
<li>是否是<code>Mixer</code>关注的类型</li>
<li>是否能转换成<code>Mixer</code>中定义的类型所对应的对象</li>
<li>应用变更</li>
<li>查看是否能成功构建快照成功（之所以这么做的原因是：<code>Mixer</code>中配置之间存在一定的关联性（<code>adapter</code>、<code>template</code>…），只校验单个实体是不够的）</li>
</ul>
<h3 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><p><code>Galley</code>中负责配置管理组件是<code>Processing</code>，它有两个版本<code>Processing</code>和<code>Processing2</code>，下面我们将主要研究<code>Processing2</code>的实现。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 资源快照的缓存</span></span><br><span class="line"><span class="comment">// 索引方法：如果不是SyntheticServiceEntry类型的资源则用默认的快照资源，否则是的话则用为SyntheticServiceEntry单独构建的快照。</span></span><br><span class="line">mcpCache := snapshot.New(groups.IndexFunction)</span><br><span class="line"><span class="keyword">return</span> &amp;Processing2&#123;</span><br><span class="line">	args:         a,</span><br><span class="line">	mcpCache:     mcpCache,</span><br><span class="line">	configzTopic: configz.CreateTopic(mcpCache),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>processing2</code>由以下几个组件组成：</p>
<ul>
<li><code>Source</code>:配置源，如k8s、fs；</li>
<li><code>Runtime</code>:<code>Galley</code>中最复杂的模块，它将<code>Source</code>、<code>Transform</code>、<code>Snapshotter</code>、<code>distributor</code>连接在一起。<ul>
<li><code>runtime</code>中创建带有状态机机制的组件 <strong>session</strong> 来追踪开始、结束事件处理循环<ul>
<li><code>inactive</code>:未激活状态；</li>
<li><code>starting</code>:当会话开始时，即转变为开始状态。为了避免在启动阶段阻塞并可以正确处理所有生命周期事件，其是一个很短暂的状态。当所有数据源初始化完成时，它将会被转换成<code>buffering</code>状态。</li>
<li><code>buffering</code>: 此阶段，所有数据源都已经初始化完成，但还没收到<code>meshconfig</code>时间。所有非<code>meshconfig</code>事件都将会被缓存，直到<code>meshconfig</code>到达；</li>
<li><code>processing</code>: 一旦接收到<code>meshconfig</code>后，<code>runtime</code>将开始做配置转换并开始分发缓存的事件到各转换器。当接收到<code>reset</code>事件或者收到<code>meshconfig</code>的变更时，<code>session</code>将转换成<code>inactive</code>状态或者创建新的<code>session</code>。</li>
</ul>
</li>
</ul>
</li>
<li><code>snapshot.Cache</code>: 配置快照</li>
</ul>
<p><strong>processing2</strong> 初始化流程实现如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Processing2)</span> <span class="title">Start</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建本地文件类型的配置源</span></span><br><span class="line">    mesh = meshcfgNewFS(p.args.MeshConfigFile)</span><br><span class="line">    <span class="comment">// 从本地文件`metadata.yaml`中加载所有元数据信息</span></span><br><span class="line">    m := metadata.MustGet()</span><br><span class="line">    <span class="comment">// 根据元数据中转换配置以及其他配置构建类型转换器提供者逻辑，即告知输入参数类型、输出参数类型，以及转换函数实现</span></span><br><span class="line">    transformProviders := transforms.Providers(m)</span><br><span class="line">    <span class="keyword">var</span> colsInSnapshots collection.Names</span><br><span class="line">    <span class="comment">// 默认输入参数中，Snapshots包含Default和SyntheticServiceEntry。从元数据中获取所有在这些Snapshot中的集合</span></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> m.AllCollectionsInSnapshots(p.args.Snapshots) &#123;</span><br><span class="line">		colsInSnapshots = <span class="built_in">append</span>(colsInSnapshots, collection.NewName(c))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 过滤出所有需要的k8s资源信息（这里有个判断，如果Galley不充当服务发现角色则过滤掉k8s内置的资源信息，如k8s的Service\Node\Endpoint等）</span></span><br><span class="line">	kubeResources := kuberesource.DisableExcludedKubeResources(m.KubeSource().Resources(), transformProviders,</span><br><span class="line">		colsInSnapshots, p.args.ExcludedResourceKinds, p.args.EnableServiceDiscovery)</span><br><span class="line">	<span class="comment">// 创建 k8s来源的数据源，其会对k8s中所有`crd`资源进行watch</span></span><br><span class="line">	src, updater, err = p.createSourceAndStatusUpdater(kubeResources)</span><br><span class="line">	<span class="comment">// 分配器</span></span><br><span class="line">	<span class="keyword">var</span> distributor snapshotter.Distributor = snapshotter.NewMCPDistributor(p.mcpCache)</span><br><span class="line">	<span class="comment">// 创建运行时，进行一些快照以及分类内容的初始化</span></span><br><span class="line">	p.runtime, err = processorInitialize(processorSettings)</span><br><span class="line">	|-	<span class="comment">//... 初始化快照参数（更新策略，是否防抖动）</span></span><br><span class="line">	|- procProvider := <span class="function"><span class="keyword">func</span><span class="params">(o processing.ProcessorOptions)</span> <span class="title">event</span>.<span class="title">Processor</span></span> &#123;</span><br><span class="line">		xforms := settings.TransformProviders.Create(o)</span><br><span class="line">		s, err := snapshotter.NewSnapshotter(xforms, options)</span><br><span class="line">		<span class="keyword">return</span> s</span><br><span class="line">	   &#125;</span><br><span class="line">	|- processing.NewRuntime(rtOpt) <span class="comment">//创建运行时，并向配置源注册事件处理器</span></span><br><span class="line">	   |- r := &amp;Runtime&#123;</span><br><span class="line">		      options: o.Clone(),</span><br><span class="line">	      &#125;</span><br><span class="line">	   |- h := event.HandlerFromFn(r.handle)</span><br><span class="line">	   |- o.Source.Dispatch(h)   </span><br><span class="line">	<span class="comment">// 创建 grpc sever   </span></span><br><span class="line">	p.grpcServer = grpc.NewServer(grpcOptions...)</span><br><span class="line">	<span class="comment">// 向指定地址服务器发起建立连接，并对对方提供配置服务（galley中特别的设计，client_source模式）</span></span><br><span class="line">	p.callOut, err = newCallout(p.args.SinkAddress, p.args.SinkAuthMode, md, options)</span><br><span class="line">	<span class="comment">//创建 MCP Server Source</span></span><br><span class="line">	p.mcpSource = source.NewServer(options, serverOptions)</span><br><span class="line">	<span class="comment">// 将MCP Server注册到grpc server上对外提供服务</span></span><br><span class="line">	mcp.RegisterResourceSourceServer(p.grpcServer, p.mcpSource)</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	p.runtime.Start()</span><br><span class="line">	|- <span class="keyword">go</span> r.run(...) <span class="comment">// 异步运行</span></span><br><span class="line">	   |- se, done := newSession(sid, r.options) <span class="comment">// 创建并初始化配置处理会话</span></span><br><span class="line">		|- r.session.Store(se)</span><br><span class="line">		|- se.start()</span><br><span class="line">		  |- s.transitionTo(starting) <span class="comment">//更改状态</span></span><br><span class="line">		  |- <span class="keyword">go</span> s.startSources()</span><br><span class="line">		    |- s.options.Source.Start() <span class="comment">//开始所有配置源组件</span></span><br><span class="line">		    |- 当Source初始化成功后，会向runtime发送一个<span class="string">`FullSync`</span>事件。</span><br><span class="line">	gs.Serve(l) <span class="comment">// 开启grpc服务</span></span><br><span class="line">	p.callOut.run()</span><br><span class="line">	|- conn, err := c.pt.grpcDial(c.address, c.do...) <span class="comment">// dial</span></span><br><span class="line">	|- client := mcp.NewResourceSinkClient(conn) <span class="comment">// 创建Mcp sink client</span></span><br><span class="line">	|- mcpClient := c.pt.sourceNewClient(client, c.so) <span class="comment">// 创建mcp client</span></span><br><span class="line">	|- mcpClient.Run(ctx) <span class="comment">// 运行 client_source</span></span><br><span class="line">	   |- c.sendTriggerResponse(stream) <span class="comment">// $triggerCollection（特别记号）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结其流程如下：</p>
<ol>
<li>初始化配置源<code>Source</code>: <code>meshSource</code>(文件配置源)、<code>apiServer.Source</code>（k8s crd配置源）；</li>
<li>解析配置文件中的元数据，初始化转换器提供者；</li>
<li>创建并初始化 <code>Runtime</code>；</li>
<li>创建<code>Callout</code>(将<code>galley</code>作为<code>client</code>方式为目标服务提供配置服务)；</li>
<li>创建 <strong>gRpc Service</strong> <code>mcpSource</code>，为配置使用方服务；</li>
<li>启动 <code>Runtime</code>，过程比较复杂，下面将详细介绍；</li>
<li>启动<code>grpc</code>提供服务；</li>
<li>启动<code>callout</code>连接到目标服务，对其提供服务。</li>
</ol>
<p>可以看到<code>Runtime</code>是<code>Galley</code>的核心，对接各种配置源，并进行配置转换。而<code>mcpSource</code>是用来对配置客户端提供服务的，他们之间通过<code>mcpCache</code>进行衔接。<code>Runtime</code>经过一系列处理后构建<code>Snapshot</code>，然后将快照传进<code>mcpCache</code>。<code>mcpSource</code>从<code>mcpCache</code>中获取配置信息，同时监听<code>mcpCache</code>的配置变更并push到客户端。</p>
<p><code>Runtime</code>启动流程大致如下：<br><img src="/media/15780350474622.jpg" alt=""></p>
<p>总结起来，<code>Galley</code>整体架构如下：<br><img src="/media/15780373176301.jpg" alt=""></p>
<h4 id="配置处理流程"><a href="#配置处理流程" class="headerlink" title="配置处理流程"></a>配置处理流程</h4><ol>
<li>当<code>client</code>首次与<strong>gRpcServer</strong>建立连接后，会从<code>stream</code>中获取其节点信息<code>PeerInfo</code>，同时从<code>PeerInfo</code>中截取<code>AuthInfo</code>进行校验；</li>
<li><code>mcpSource</code>调用<code>Processtream</code>方法对<code>Stream</code>进行处理：<ul>
<li>首先为每个客户端创建一个<code>connection</code>对象，用来保存其元信息（节点信息、订阅类型以及订阅类型的监听状态等）</li>
<li>然后会同时监听<code>connection</code>的请求通道<code>reuqestC</code>和向其推送信息的队列<code>queue</code></li>
</ul>
</li>
</ol>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> connection <span class="keyword">struct</span> &#123;</span><br><span class="line">    peerAddr <span class="keyword">string</span></span><br><span class="line">    stream   Stream</span><br><span class="line">    id       <span class="keyword">int64</span></span><br><span class="line">    streamNonce <span class="keyword">int64</span> <span class="comment">// 请求-响应记号 // 只有在server端每次发送数据时才会修改该值</span></span><br><span class="line">    requestC <span class="keyword">chan</span> *mcp.RequestResources</span><br><span class="line">    watches  <span class="keyword">map</span>[<span class="keyword">string</span>]*watch <span class="comment">//每种类型配置的监听状态</span></span><br><span class="line">    watcher  Watcher <span class="comment">// mcpCache</span></span><br><span class="line">    queue *internal.UniqueQueue</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>初次请求处理流程如下：</strong><br><img src="/media/15780405468904.jpg" alt=""></p>
<p><strong>变更下发流程如下：</strong><br>以<code>apiServer</code>为配置源，资源 <code>VirtualService</code> 为例来讲解配置下发流程：<br><img src="/media/15780623306136.jpg" alt=""><br>可以看出其流程非常之长，但概括起来其过程：</p>
<ul>
<li><strong>Source变更</strong> -&gt; <strong>Runtime进行转换</strong> -&gt; <strong>Cache更新快照</strong> -&gt; <strong>connectin连接下发更新</strong></li>
</ul>
<h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><ol>
<li><code>metadata.yaml</code> 元数据配置文件<br><img src="/media/15779491994478.jpg" alt=""></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2019/10/14/istio/2.istio-pilot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/14/istio/2.istio-pilot/" itemprop="url">Istio Pilot</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-14T00:00:00+08:00">2019-10-14</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/istio/" itemprop="url" rel="index"><span itemprop="name">istio</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Pilot"><a href="#Pilot" class="headerlink" title="Pilot"></a>Pilot</h1><p><code>Pilot</code>是Istio的控制中枢，它负责<code>sidecar</code>的生命周期管理并负责向<code>Sidecar</code>下发控制数据。</p>
<p>[TOC]</p>
<p>下面将从以下几个方面来分析<code>Pilot</code>:</p>
<ul>
<li>整体架构</li>
<li>启动过程</li>
<li><code>Sidecar</code> 初始拉取过程 <strong>&amp;</strong> 信息下发过程</li>
<li>拓展性</li>
</ul>
<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><code>Pilot</code> 内部整体架构如下：</p>
<ul>
<li>实现 <strong>Grpc Server</strong> 对<code>Envoy</code>提供查询配置以及服务发现服务；</li>
<li>支持配置控制器、服务控制器</li>
<li>配置控制器支持聚合多种类型配置源，如 K8s、基于文件系统的内存配置源、Galley 以及其他的实现MCP协议的拓展配置中心服务；</li>
<li>服务控制器同样支持多种类型服务注册中心，如 K8s、Consul以及可以拓展MCP协议实现的注册中心服务</li>
<li>另外，通过<code>ControlZ</code>服务对外暴露 <code>Pilot</code> 内部配置&amp;运行时信息的查询和修改接口</li>
</ul>
<p><img src="/media/15769864174743.jpg" alt=""></p>
<h2 id="启动分析"><a href="#启动分析" class="headerlink" title="启动分析"></a>启动分析</h2><p>首先其入口地址为：<code>istio/pilot/cmd/pilot-discovery</code>。<br>启动前，<code>init</code>方法预先执行，其解析出启动参数如：<code>registries</code>(注册中心配置，若未配置，则默认注册中心为<code>k8s</code>)、<code>meshConfig</code>(mesh的配置文件地址)、<code>httpAddr</code>、<code>grpcAddr</code> 服务器启动http、Grpc端口等。<br><code>discoveryCmd.Run</code>方法为启动入口，首先通过<code>bootstrap.NewServer</code>创建<strong>Server</strong>，然后通过<code>Start</code>方法启动 <strong>Server</strong>。<br>首先，看<code>bootstrap.NewServer</code>方法：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">s := &amp;Server&#123;</span><br><span class="line">    <span class="comment">// 文件监听器组件，用于监听文件更新事件</span></span><br><span class="line">	fileWatcher: filewatcher.NewWatcher(),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建k8s client</span></span><br><span class="line">s.initKubeClient(&amp;args)</span><br><span class="line"><span class="comment">// 初始化 mesh配置 根据配置地址从指定位置获取配置，并添加文件监听器监听更新</span></span><br><span class="line">s.initMesh(&amp;args)</span><br><span class="line"><span class="comment">//  初始化Mesh网络配置，根据配置地址从指定位置获取配置，并添加文件监听器监听更新</span></span><br><span class="line">s.initMeshNetworks(&amp;args)</span><br><span class="line"><span class="comment">// 初始化证书控制器</span></span><br><span class="line">s.initCertController(&amp;args)</span><br><span class="line"><span class="comment">// 初始化配置控制器</span></span><br><span class="line">s.initConfigController(&amp;args)</span><br><span class="line"><span class="comment">// 初始化服务控制器</span></span><br><span class="line">s.initServiceControllers(&amp;args)</span><br><span class="line"><span class="comment">// 初始化发现服务</span></span><br><span class="line">s.initDiscoveryService(&amp;args)</span><br><span class="line"><span class="comment">// 初始化监控服务</span></span><br><span class="line">s.initMonitor(&amp;args)</span><br><span class="line"><span class="comment">// 初始化集群注册器，监控远程集群并初始化多集群结构</span></span><br><span class="line">s.initClusterRegistries(&amp;args)</span><br></pre></td></tr></table></figure>
<p>创建完<code>DiscoveryServer</code>后，通过调用<code>Start</code>方法启动各组件。<br>上面执行流程大致过程如下：首先创建与<code>k8s</code>的交互客户端，然后根据初始传入配置路径读取配置文件中<code>mesh</code>以及网络的配置，同时监听、维护配置文件更新；其后创建三个控制器：证书、配置、服务控制器分别管理 Secert、config、service信息；再创建发现服务：聚合上面所有控制器的能力对<strong>Sidecar</strong>提供服务。<br>下面将分别介绍初始化<code>mesh</code>配置以及网络配置过程，初始化证书、配置以及服务控制器，以及初始化发现服务。</p>
<h3 id="初始化Mesh配置"><a href="#初始化Mesh配置" class="headerlink" title="初始化Mesh配置"></a>初始化<code>Mesh</code>配置</h3><p> <strong>initMesh</strong>方法，首先判断是否配置了<code>args.Mesh.ConfigFile</code>。若是，则从文件中读取配置信息，并添加文件监听器当有更新时回调更新方法（下发配置）；若无，则从<code>k8s</code>中获取mesh配置信息。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// args.Mesh.ConfigFile != ""</span></span><br><span class="line">meshConfig, err = cmd.ReadMeshConfig(args.Mesh.ConfigFile)</span><br><span class="line">s.addFileWatcher(args.Mesh.ConfigFile, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	meshConfig, err = cmd.ReadMeshConfig(args.Mesh.ConfigFile)</span><br><span class="line">	<span class="keyword">if</span> !reflect.DeepEqual(meshConfig, s.mesh) &#123;</span><br><span class="line">		s.mesh = meshConfig</span><br><span class="line">		<span class="keyword">if</span> s.EnvoyXdsServer != <span class="literal">nil</span> &#123;</span><br><span class="line">			s.EnvoyXdsServer.Env.Mesh = meshConfig</span><br><span class="line">			<span class="comment">//下发配置</span></span><br><span class="line">			s.EnvoyXdsServer.ConfigUpdate(&amp;model.PushRequest&#123;Full: <span class="literal">true</span>&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 从k8s中获取配置信息 namespace:istio-system, name:istio</span></span><br><span class="line">cfg, err := kube.CoreV1().ConfigMaps(namespace).Get(name, meta_v1.GetOptions&#123;&#125;)</span><br><span class="line">cfgYaml, exists := cfg.Data[ConfigMapKey]</span><br><span class="line">meshConfig, err := mesh.ApplyMeshConfigDefaults(cfgYaml)</span><br></pre></td></tr></table></figure>

<h3 id="初始化配置控制器"><a href="#初始化配置控制器" class="headerlink" title="初始化配置控制器"></a>初始化配置控制器</h3><p><strong>Pilot</strong> 支持对接多配置中心，支持从多个配置中心获取配置值：</p>
<ol>
<li>若设置了配置源<code>mesh.ConfigSources</code>，则初始化<code>MCPConfigController</code>；</li>
<li>若设置了配置文件目录<code>Config.FileDir</code>，则创建一个内存配置控制器。并定时（<code>100ms</code>）同步指定文件目录下的配置到内存配置控制器中；</li>
<li>创建 <strong>k8s</strong> 配置控制器，每种Istio配置类型对应一种<code>CRD</code>资源，并创建每种资源的informer，构成配置更新机制。</li>
</ol>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s.mesh.ConfigSources) &gt; <span class="number">0</span> &#123;</span><br><span class="line">  s.initMCPConfigController(args)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> args.Config.Controller != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="comment">// 正常流程不会走到此处</span></span><br><span class="line">	s.configController = args.Config.Controller</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> args.Config.FileDir != <span class="string">""</span> &#123;</span><br><span class="line">	store := memory.Make(schemas.Istio)</span><br><span class="line">	configController := memory.NewController(store)</span><br><span class="line">	err := s.makeFileMonitor(args.Config.FileDir, configController)</span><br><span class="line">	s.configController = configController</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	cfgController, err := s.makeKubeConfigController(args)</span><br><span class="line">	s.configController = cfgController</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后添加置后 <strong>Start</strong>方法，在所有组件初始化完成执行（Pilot中所有组件都是如此）。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.addStartFunc(<span class="function"><span class="keyword">func</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> s.configController.Run(stop)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>完成基本类型配置控制器创建后，会继续判断是否支持 <code>Ingress</code> 模式的配置；若是则对控制器进行包装：添加一种配置类型<code>Ingress</code>，并按类型进行映射：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   configController, err := configaggregate.MakeCache([]model.ConfigStoreCache&#123;</span><br><span class="line">	s.configController,</span><br><span class="line">	ingress.NewController(s.kubeClient, s.mesh, args.Config.ControllerOptions),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>最后，根据创建的配置控制器创建 <code>IstioConfigStore</code>。其作用就是配置访问层，提供具体配置查询接口，定义如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IstioConfigStore <span class="keyword">interface</span> &#123;</span><br><span class="line">	ConfigStore</span><br><span class="line">	ServiceEntries() []Config</span><br><span class="line">	Gateways(workloadLabels labels.Collection) []Config</span><br><span class="line">	EnvoyFilter(workloadLabels labels.Collection) *Config</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<strong>MCP</strong>协议 是<code>Istio</code>中最近比较火的概念，下文将详细讲解<code>initMCPConfigController</code>：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">initMCPConfigController</span><span class="params">(args *PilotArgs)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> _, configSource := <span class="keyword">range</span> s.mesh.ConfigSources &#123;</span><br><span class="line">        <span class="keyword">if</span> strings.Contains(configSource.Address, fsScheme+<span class="string">"://"</span>) &#123;</span><br><span class="line">        <span class="comment">// ... 若是，则创建文件配置控制器，上文中有提起此种类型控制器</span></span><br><span class="line">            configStores = <span class="built_in">append</span>(configStores, configController)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据配置创建与MCP server的grpc链接</span></span><br><span class="line">        conn, err := grpc.DialContext(</span><br><span class="line">			ctx,<span class="comment">//... 配置</span></span><br><span class="line">			)</span><br><span class="line">			<span class="comment">// 创建MCP控制</span></span><br><span class="line">			s.mcpController(args, conn, reporter, &amp;clients, &amp;configStores)</span><br><span class="line">			|- <span class="comment">// 基于Grpc链接创建grpc资源客户端，其用于与MCP服务端建立Stream通道，</span></span><br><span class="line">			|- cl := mcpapi.NewResourceSourceClient(conn)</span><br><span class="line">			<span class="comment">// 创建MCP客户端</span></span><br><span class="line">			|- mcpClient := sink.NewClient(cl, sinkOptions)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// ！！！这里很有意思即可以 MCP服务端同时当成 注册中心使用</span></span><br><span class="line">			<span class="keyword">if</span> resourceContains(configSource.SubscribedResources, meshconfig.Resource_SERVICE_REGISTRY) &#123;</span><br><span class="line">			    args.Service.Registries = []<span class="keyword">string</span>&#123;<span class="keyword">string</span>(serviceregistry.MCPRegistry)&#125;</span><br><span class="line">    			conn, err := grpc.DialContext(</span><br><span class="line">    				ctx,</span><br><span class="line">    				<span class="comment">//...配置)</span></span><br><span class="line">    			conns = <span class="built_in">append</span>(conns, conn)</span><br><span class="line">    			<span class="comment">// 合成服务注册中心</span></span><br><span class="line">    			s.sseMCPController(args, conn, reporter, &amp;clients, &amp;configStores)</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 添加启动方法</span></span><br><span class="line">	s.addStartFunc(<span class="function"><span class="keyword">func</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> clients &#123;</span><br><span class="line">			client := clients[i]</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				client.Run(ctx)</span><br><span class="line">			&#125;()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将多个配置服务源进行聚合</span></span><br><span class="line">	aggregateMcpController, err := configaggregate.MakeCache(configStores)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续跟进<code>s.mcpController(args, conn, reporter, &amp;clients, &amp;configStores)</code>，逻辑：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">mcpController</span><span class="params">(args *PilotArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">	conn *grpc.ClientConn,</span></span></span><br><span class="line"><span class="function"><span class="params">	reporter monitoring.Reporter,</span></span></span><br><span class="line"><span class="function"><span class="params">	clients *[]*sink.Client,</span></span></span><br><span class="line"><span class="function"><span class="params">	configStores *[]model.ConfigStoreCache)</span></span> &#123;</span><br><span class="line">	<span class="comment">//  CoreDataModel 结构，用于配置临时存储并接收MCP Server下发的变更</span></span><br><span class="line">	mcpController := coredatamodel.NewController(s.mcpOptions)</span><br><span class="line">	sinkOptions := &amp;sink.Options&#123;</span><br><span class="line">		CollectionOptions: collections,</span><br><span class="line">		Updater:           mcpController,</span><br><span class="line">		ID:                clientNodeID,</span><br><span class="line">		Reporter:          reporter,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建资源客户端</span></span><br><span class="line">	cl := mcpapi.NewResourceSourceClient(conn)</span><br><span class="line">	<span class="comment">// 创建Sink客户端，针对MCP而设计的资源信息交互组件，后面我们将分章节讲解MCP整体交互实现。</span></span><br><span class="line">	mcpClient := sink.NewClient(cl, sinkOptions)</span><br><span class="line">	configz.Register(mcpClient)</span><br><span class="line">	*clients = <span class="built_in">append</span>(*clients, mcpClient)</span><br><span class="line">	*configStores = <span class="built_in">append</span>(*configStores, mcpController)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结创建 <strong>MCPConfigController</strong>的执行过程如下：</p>
<ul>
<li>对于每种配置源，根据<code>configSource.Address</code>以及配置创建与<strong>MCP</strong>服务端的grpc链接以及stream client；</li>
<li>创建 <code>mcpController</code> 用于接收 <strong>MCP Server</strong> 的配置变更；</li>
<li>创建 <code>Sink</code>组件，维护与 <strong>MCP Server</strong> 的交互；</li>
<li>别外，如果若配置源同时也维护 <strong>服务资源</strong>（充当注册中心的角色），同时会创建 <code>SyntheticServiceEntryController</code>。</li>
</ul>
<h3 id="初始化服务控制器"><a href="#初始化服务控制器" class="headerlink" title="初始化服务控制器"></a>初始化服务控制器</h3><p>Pilot同时也支持对接多个注册中心，其同时可以从多个注册中心获取服务注册信息。目前Pilot支持三种类型的注册中心：k8s、consul和基于MCP协议实现的注册中心。<br>初始化时，创建指定类型<code>Registry</code>，然后加到<code>aggregate.Controller</code>中，其聚合不同注册中心的数据，对sidecar服务。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">initServiceControllers</span><span class="params">(args *PilotArgs)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> args.Service.Registries &#123;</span><br><span class="line">        <span class="keyword">switch</span> serviceRegistry &#123;</span><br><span class="line">		<span class="keyword">case</span> serviceregistry.KubernetesRegistry:</span><br><span class="line">		  s.createK8sServiceControllers(serviceControllers, args)</span><br><span class="line">		<span class="keyword">case</span> serviceregistry.ConsulRegistry:</span><br><span class="line">			s.initConsulRegistry(serviceControllers, args)</span><br><span class="line">		<span class="keyword">case</span> serviceregistry.MCPRegistry:</span><br><span class="line">			<span class="keyword">if</span> s.mcpDiscovery != <span class="literal">nil</span> &#123;</span><br><span class="line">				serviceControllers.AddRegistry(</span><br><span class="line">					aggregate.Registry&#123;</span><br><span class="line">						Name:             serviceregistry.MCPRegistry,</span><br><span class="line">						<span class="comment">// mcpDiscovery为之前初始化配置服务时创建</span></span><br><span class="line">						ServiceDiscovery: s.mcpDiscovery,</span><br><span class="line">						Controller:       s.mcpDiscovery,</span><br><span class="line">					&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将配置中心包装成注册中心，其会将配置数据转换成Sidecar需要的Sercice\Instance数据。</span></span><br><span class="line">    serviceEntryStore := external.NewServiceDiscovery(s.configController, s.istioConfigStore)</span><br><span class="line">    serviceEntryRegistry := aggregate.Registry&#123;</span><br><span class="line">		Name:             <span class="string">"ServiceEntries"</span>,</span><br><span class="line">		Controller:       serviceEntryStore,</span><br><span class="line">		ServiceDiscovery: serviceEntryStore,</span><br><span class="line">	&#125;</span><br><span class="line">	serviceControllers.AddRegistry(serviceEntryRegistry)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加开启方法</span></span><br><span class="line">s.addStartFunc(<span class="function"><span class="keyword">func</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> s.ServiceController.Run(stop)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>初始化服务发现控制器的过程主要如下：</p>
<ul>
<li>根据注册器配置列表创建相应类型服务发现管理器；</li>
<li>将配置中心包装成发现服务；</li>
<li>将生成的所有发现服务聚合成<code>aggregate.Controller</code></li>
</ul>
<p>再深入<code>Registry</code>服务逻辑，首先看其定义：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Registry <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 服务注册类型</span></span><br><span class="line">	Name serviceregistry.ServiceRegistry</span><br><span class="line">	<span class="comment">// 集群ID，当有多个同种类型注册中心时，用ClusterID来区分它们</span></span><br><span class="line">	ClusterID <span class="keyword">string</span></span><br><span class="line">   <span class="comment">// 控制器：提供接口让依赖方可以加入变更事件处理器</span></span><br><span class="line">	model.Controller</span><br><span class="line">	<span class="comment">// 定义获取资源的接口</span></span><br><span class="line">	model.ServiceDiscovery</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Controller <span class="keyword">interface</span> &#123;</span><br><span class="line">	AppendServiceHandler(f <span class="function"><span class="keyword">func</span><span class="params">(*Service, Event)</span>) <span class="title">error</span></span></span><br><span class="line">	AppendInstanceHandler(f <span class="function"><span class="keyword">func</span><span class="params">(*ServiceInstance, Event)</span>) <span class="title">error</span></span></span><br><span class="line">	Run(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ServiceDiscovery <span class="keyword">interface</span> &#123;</span><br><span class="line">	Services() ([]*Service, error)</span><br><span class="line">	GetService(hostname host.Name) (*Service, error)</span><br><span class="line">	InstancesByPort(svc *Service, servicePort <span class="keyword">int</span>, labels labels.Collection) ([]*ServiceInstance, error)</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面将以<code>k8s</code>为具体发现服务来讲解其工作原理。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">createK8sServiceControllers</span><span class="params">(serviceControllers *aggregate.Controller, args *PilotArgs)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	clusterID := <span class="keyword">string</span>(serviceregistry.KubernetesRegistry)</span><br><span class="line">	args.Config.ControllerOptions.ClusterID = clusterID</span><br><span class="line">	<span class="comment">// 构建k8s服务发现控制器</span></span><br><span class="line">	kubectl := controller2.NewController(s.kubeClient, args.Config.ControllerOptions)</span><br><span class="line">	s.kubeRegistry = kubectl</span><br><span class="line">	serviceControllers.AddRegistry(</span><br><span class="line">		aggregate.Registry&#123;</span><br><span class="line">			Name:             serviceregistry.KubernetesRegistry,</span><br><span class="line">			ClusterID:        clusterID,</span><br><span class="line">			ServiceDiscovery: kubectl,</span><br><span class="line">			Controller:       kubectl,</span><br><span class="line">		&#125;)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上文可以看出<code>controller2.NewController</code>是 <strong>k8sRegistry</strong> 的核心部分。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewController</span><span class="params">(client kubernetes.Interface, options Options)</span> *<span class="title">Controller</span></span> &#123;</span><br><span class="line">	<span class="comment">// Queue requires a time duration for a retry delay after a handler error</span></span><br><span class="line">	out := &amp;Controller&#123;</span><br><span class="line">		domainSuffix:               options.DomainSuffix,</span><br><span class="line">		client:                     client,</span><br><span class="line">		queue:                      kube.NewQueue(<span class="number">1</span> * time.Second),</span><br><span class="line">		ClusterID:                  options.ClusterID,</span><br><span class="line">		XDSUpdater:                 options.XDSUpdater,</span><br><span class="line">		servicesMap:                <span class="built_in">make</span>(<span class="keyword">map</span>[host.Name]*model.Service),</span><br><span class="line">		externalNameSvcInstanceMap: <span class="built_in">make</span>(<span class="keyword">map</span>[host.Name][]*model.ServiceInstance),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 基于k8s的client创建Informer(与k8s apiserver的交互组件)</span></span><br><span class="line">	sharedInformers := informers.NewSharedInformerFactoryWithOptions(client, options.ResyncPeriod, informers.WithNamespace(options.WatchedNamespace))</span><br><span class="line">	<span class="comment">// 创建 Service、Endpoint、Node、Pod 的 Informer，并向每个informer中添加事件监听器，监听每种类型的变更事件。当有变更时会通知controller的queue，Queue中会定时`1s`捞事件执行回调，回调什么将从下文中介绍</span></span><br><span class="line">	svcInformer := sharedInformers.Core().V1().Services().Informer()</span><br><span class="line">	out.services = out.createCacheHandler(svcInformer, <span class="string">"Services"</span>)</span><br><span class="line"></span><br><span class="line">	epInformer := sharedInformers.Core().V1().Endpoints().Informer()</span><br><span class="line">	out.endpoints = out.createEDSCacheHandler(epInformer, <span class="string">"Endpoints"</span>)</span><br><span class="line"></span><br><span class="line">	nodeInformer := sharedInformers.Core().V1().Nodes().Informer()</span><br><span class="line">	out.nodes = out.createCacheHandler(nodeInformer, <span class="string">"Nodes"</span>)</span><br><span class="line"></span><br><span class="line">	podInformer := sharedInformers.Core().V1().Pods().Informer()</span><br><span class="line">	out.pods = newPodCache(out.createCacheHandler(podInformer, <span class="string">"Pod"</span>), out)</span><br><span class="line">	<span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先基于 <code>k8s</code> client创建 <code>Service</code>、<code>Endpoint</code>、<code>Node</code>、<code>Pod</code>（<code>k8s</code>中的服务角色） 的 Informer（k8s为了简化各组件之间交互而构建的工具，其即具有缓存的功能同时也有查询与实时变更通知的功能）。</li>
<li>向每种 <code>Informer</code> 添加变更事件回调方法，回调方法会往<code>controller</code>的<code>queue</code>中Push变更task</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">handler := &amp;kube.ChainHandler&#123;Funcs: []kube.Handler&#123;c.notify&#125;&#125;</span><br><span class="line">informer.AddEventHandler(</span><br><span class="line">		cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">			AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    			<span class="comment">// ...</span></span><br><span class="line">    			c.queue.Push(kube.Task&#123;Handler: handler.Apply, Obj: obj, Event: model.EventAdd&#125;)</span><br><span class="line">			&#125;,</span><br><span class="line">			UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, cur <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    			<span class="comment">// ...</span></span><br><span class="line">			&#125;,</span><br><span class="line">			DeleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		      <span class="comment">// ...</span></span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;)</span><br><span class="line">handler := &amp;kube.ChainHandler&#123;Funcs: []kube.Handler&#123;c.notify&#125;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>queue</code>是一个防抖动的设计，其会缓存一秒的变更对象，然后集中执行<code>Handler</code>方法，而<code>Handler</code>则是一个调用链。其允许添加多个处理器</li>
<li>再看对<code>Controller</code>接口的实现方法，其实就是往<code>queue</code>的调用链中添加处理方法：</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">AppendServiceHandler</span><span class="params">(f <span class="keyword">func</span>(*model.Service, model.Event)</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">	c.services.handler.Append(<span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;, event model.Event)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		svc, ok := obj.(*v1.Service)</span><br><span class="line">		hostname := svc.Name + <span class="string">"."</span> + svc.Namespace</span><br><span class="line">		ports := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">uint32</span>&#123;&#125;</span><br><span class="line">		portsByNum := <span class="keyword">map</span>[<span class="keyword">uint32</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> _, port := <span class="keyword">range</span> svc.Spec.Ports &#123;</span><br><span class="line">			ports[port.Name] = <span class="keyword">uint32</span>(port.Port)</span><br><span class="line">			portsByNum[<span class="keyword">uint32</span>(port.Port)] = port.Name</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将</span></span><br><span class="line">		svcConv := kube.ConvertService(*svc, c.domainSuffix, c.ClusterID)</span><br><span class="line">		instances := kube.ExternalNameServiceInstances(*svc, svcConv)</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="comment">// EDS needs the port mapping.</span></span><br><span class="line">		c.XDSUpdater.SvcUpdate(c.ClusterID, hostname, ports, portsByNum)</span><br><span class="line">     <span class="comment">// 回调</span></span><br><span class="line">		f(svcConv, event)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化发现服务"><a href="#初始化发现服务" class="headerlink" title="初始化发现服务"></a>初始化发现服务</h3><p><code>EnvoyXdsServer</code> 的作用是聚合服务控制器、配置控制器、mesh配置、meshNetworks配置信息，为<code>Sidecar</code>提供服务。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">initDiscoveryService</span><span class="params">(args *PilotArgs)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    environment := &amp;model.Environment&#123;</span><br><span class="line">		Mesh:             s.mesh,</span><br><span class="line">		MeshNetworks:     s.meshNetworks,</span><br><span class="line">		IstioConfigStore: s.istioConfigStore,</span><br><span class="line">		ServiceDiscovery: s.ServiceController,</span><br><span class="line">		PushContext:      model.NewPushContext(),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 添加 `/v1/registration`路径处理函数，查询所有Service和Endpoint</span></span><br><span class="line">	discovery, err := envoy.NewDiscoveryService(</span><br><span class="line">		environment,</span><br><span class="line">		args.DiscoveryOptions,</span><br><span class="line">	)</span><br><span class="line">	s.mux = discovery.RestContainer.ServeMux</span><br><span class="line">	<span class="comment">// 1. 聚合配置中心、注册中心，并往其中添加各种类型的事件处理器</span></span><br><span class="line">	<span class="comment">// 2. 创建配置生成器</span></span><br><span class="line">	s.EnvoyXdsServer = envoyv2.NewDiscoveryServer(environment,</span><br><span class="line">		istio_networking.NewConfigGenerator(args.Plugins),</span><br><span class="line">		s.ServiceController, s.kubeRegistry, s.configController)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">if</span> s.kubeRegistry != <span class="literal">nil</span> &#123;</span><br><span class="line">		s.kubeRegistry.Env = environment</span><br><span class="line">		s.kubeRegistry.InitNetworkLookup(s.meshNetworks)</span><br><span class="line">		<span class="comment">// 设置k8s注册器的更新回调</span></span><br><span class="line">		s.kubeRegistry.XDSUpdater = s.EnvoyXdsServer</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> s.mcpOptions != <span class="literal">nil</span> &#123;</span><br><span class="line">	   <span class="comment">// 设置mcp配置更新回调</span></span><br><span class="line">		s.mcpOptions.XDSUpdater = s.EnvoyXdsServer</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> s.incrementalMcpOptions != <span class="literal">nil</span> &#123;</span><br><span class="line">		clusterID := args.Config.ControllerOptions.ClusterID</span><br><span class="line">		s.incrementalMcpOptions.XDSUpdater = s.EnvoyXdsServer</span><br><span class="line">		s.incrementalMcpOptions.ClusterID = clusterID</span><br><span class="line">		<span class="comment">// 设置服务发现配置更新回调</span></span><br><span class="line">		s.discoveryOptions.XDSUpdater = s.EnvoyXdsServer</span><br><span class="line">		s.discoveryOptions.Env = environment</span><br><span class="line">		s.discoveryOptions.ClusterID = clusterID</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s.addStartFunc(<span class="function"><span class="keyword">func</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		s.EnvoyXdsServer.Start(stop)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// 创建GrpServer，并将 EnvoyXdsServer 服务注册到GrpcServer中</span></span><br><span class="line">	s.initGrpcServer(args.KeepaliveOptions)</span><br><span class="line">	<span class="comment">// 创建安全端口服务</span></span><br><span class="line">	<span class="keyword">if</span> args.DiscoveryOptions.SecureGrpcAddr != <span class="string">""</span> &#123;</span><br><span class="line">    	s.initSecureGrpcServer(args.KeepaliveOptions)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>其中，最重要的是创建<code>EnvoyXdsServer</code>，构建参数分别是 <code>Environment</code> 所有数据源、<code>ConfigGenerator</code>配置生成器（其作用是根据已有信息生成<code>Sidecar</code>需要的 <code>Cluster</code>、<code>Route</code>、<code>Listener</code>，并且会构建相应的filter链）。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">s.EnvoyXdsServer = envoyv2.NewDiscoveryServer(environment,</span><br><span class="line">		istio_networking.NewConfigGenerator(args.Plugins),</span><br><span class="line">		s.ServiceController, s.kubeRegistry, s.configController)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDiscoveryServer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	env *model.Environment,</span></span></span><br><span class="line"><span class="function"><span class="params">	generator core.ConfigGenerator,</span></span></span><br><span class="line"><span class="function"><span class="params">	ctl model.Controller,</span></span></span><br><span class="line"><span class="function"><span class="params">	kubeController *controller.Controller,</span></span></span><br><span class="line"><span class="function"><span class="params">	configCache model.ConfigStoreCache)</span> *<span class="title">DiscoveryServer</span></span> &#123;</span><br><span class="line">	serviceHandler := <span class="function"><span class="keyword">func</span><span class="params">(svc *model.Service, _ model.Event)</span></span> &#123;</span><br><span class="line">		pushReq := &amp;model.PushRequest&#123;</span><br><span class="line">			Full:               <span class="literal">true</span>,</span><br><span class="line">			NamespacesUpdated:  <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;&#123;svc.Attributes.Namespace: &#123;&#125;&#125;,</span><br><span class="line">			ConfigTypesUpdated: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;&#123;schemas.ServiceEntry.Type: &#123;&#125;&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">		out.ConfigUpdate(pushReq)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 往注册中心添加Service变更处理器</span></span><br><span class="line">	ctl.AppendServiceHandler(serviceHandler)</span><br><span class="line">	instanceHandler := <span class="function"><span class="keyword">func</span><span class="params">(si *model.ServiceInstance, _ model.Event)</span></span> &#123;</span><br><span class="line">		out.ConfigUpdate(&amp;model.PushRequest&#123;</span><br><span class="line">			Full:              <span class="literal">true</span>,</span><br><span class="line">			NamespacesUpdated: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;&#123;si.Service.Attributes.Namespace: &#123;&#125;&#125;,</span><br><span class="line">			ConfigTypesUpdated: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;&#123;schemas.ServiceEntry.Type: &#123;&#125;&#125;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	ctl.AppendInstanceHandler(instanceHandler)</span><br><span class="line">	configHandler := <span class="function"><span class="keyword">func</span><span class="params">(c model.Config, _ model.Event)</span></span> &#123;</span><br><span class="line">		pushReq := &amp;model.PushRequest&#123;</span><br><span class="line">			Full:               <span class="literal">true</span>,</span><br><span class="line">			ConfigTypesUpdated: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;&#123;c.Type: &#123;&#125;&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">		out.ConfigUpdate(pushReq)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 往配置中心添加配置变更处理器</span></span><br><span class="line">	<span class="keyword">for</span> _, descriptor := <span class="keyword">range</span> schemas.Istio &#123;</span><br><span class="line">		configCache.RegisterEventHandler(descriptor.Type, configHandler)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="初始化更新下发流程"><a href="#初始化更新下发流程" class="headerlink" title="初始化更新下发流程"></a>初始化更新下发流程</h4><p>创建完 <code>EnvoyXdsServer</code>后，执行其<code>Start</code>方法，开启<code>push</code>通道处理流程：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">Start</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 接收 配置中心、注册中心的配置变更</span></span><br><span class="line">	<span class="keyword">go</span> s.handleUpdates(stopCh)</span><br><span class="line">	<span class="comment">// 周期性刷新Metrics信息</span></span><br><span class="line">	<span class="keyword">go</span> s.periodicRefreshMetrics(stopCh)</span><br><span class="line">	<span class="comment">// 往下发送变更</span></span><br><span class="line">	<span class="keyword">go</span> s.sendPushes(stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，先来看处理变更流程：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">handleUpdates</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// pushChannel接收上层配置中心、注册中心的更新</span></span><br><span class="line">	debounce(s.pushChannel, stopCh, s.Push)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">debounce</span><span class="params">(ch <span class="keyword">chan</span> *model.PushRequest, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, pushFn <span class="keyword">func</span>(req *model.PushRequest)</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">var</span> req *model.PushRequest</span><br><span class="line">	free := <span class="literal">true</span></span><br><span class="line">	freeCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	push := <span class="function"><span class="keyword">func</span><span class="params">(req *model.PushRequest)</span></span> &#123;</span><br><span class="line">		pushFn(req)</span><br><span class="line">		freeCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pushWorker := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	   <span class="comment">// 距离上一次开始防抖动时间开始</span></span><br><span class="line">		eventDelay := time.Since(startDebounce)</span><br><span class="line">		<span class="comment">// 距离上次配置更新间隔时间</span></span><br><span class="line">		quietTime := time.Since(lastConfigUpdateTime)</span><br><span class="line">      <span class="comment">// 大于 10s，100ms</span></span><br><span class="line">		<span class="keyword">if</span> eventDelay &gt;= DebounceMax || quietTime &gt;= DebounceAfter &#123;</span><br><span class="line">			<span class="keyword">if</span> req != <span class="literal">nil</span> &#123;</span><br><span class="line">			   <span class="comment">// ... 打印下发信息</span></span><br><span class="line">				free = <span class="literal">false</span></span><br><span class="line">				<span class="keyword">go</span> push(req)</span><br><span class="line">				req = <span class="literal">nil</span></span><br><span class="line">				debouncedEvents = <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			timeChan = time.After(DebounceAfter - quietTime)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-freeCh:</span><br><span class="line">			free = <span class="literal">true</span></span><br><span class="line">			pushWorker()</span><br><span class="line">		<span class="keyword">case</span> r := &lt;-ch:</span><br><span class="line">			<span class="comment">// ... 对于EDS而言，如果未配置防抖动，且不是全局更新，则立即下发     </span></span><br><span class="line">			lastConfigUpdateTime = time.Now()</span><br><span class="line">			<span class="comment">// 第一次更新事件</span></span><br><span class="line">			<span class="keyword">if</span> debouncedEvents == <span class="number">0</span> &#123;</span><br><span class="line">				timeChan = time.After(DebounceAfter)</span><br><span class="line">				startDebounce = lastConfigUpdateTime</span><br><span class="line">			&#125;</span><br><span class="line">			debouncedEvents++</span><br><span class="line">            <span class="comment">// 合并变更</span></span><br><span class="line">			req = req.Merge(r)</span><br><span class="line">		<span class="keyword">case</span> &lt;-timeChan:</span><br><span class="line">		   <span class="comment">// 时间窗口到来时，下发更新</span></span><br><span class="line">			<span class="keyword">if</span> free &#123;</span><br><span class="line">				pushWorker()</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理变更处理流程是一个<strong>防抖动</strong>的设计，处理流程大致如下：</p>
<ol>
<li>当 <code>配置中心</code> 或者 <code>注册中心</code> 有变更时 会发送到 <strong>pushChannel</strong>；</li>
<li>每个抖动窗口（默认 100ms，<strong>DebounceAfter</strong>）第一次接收更新，设置到期 <code>timer</code>，后续不断接收更新，并合并更新；</li>
<li>当抖动窗口期到期时则调用<code>pushWorker</code>下发更新；</li>
<li>另外通过 变量<code>free</code>和<code>freeCh</code>来防止上一次没下发完后一次就开始了。</li>
</ol>
<p>合并请求主要内容如下（<code>push_context.go/L201</code>）：</p>
<ul>
<li>如果任意一个更新是全局 <strong>Push</strong>，则合并更新即为全局 <strong>Push</strong>；</li>
<li>如果不是全局 <strong>Push</strong>，则合并 <strong>EdsUpdates</strong>信息，标识哪些 <strong>Service</strong> 需要更新；</li>
<li>合并需要更新的目标命名空间；</li>
<li>合并需要更新的配置类型。</li>
</ul>
<p><code>pushWorker</code>最后调用的是 <code>EnvoyXdsServer</code>的<code>Push</code>方法：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">Push</span><span class="params">(req *model.PushRequest)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !req.Full &#123;</span><br><span class="line">	   <span class="comment">// 部分下发，只下发EDS</span></span><br><span class="line">		req.Push = s.globalPushContext()</span><br><span class="line">		<span class="keyword">go</span> s.AdsPushAll(versionInfo(), req)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	oldPushContext := s.globalPushContext()</span><br><span class="line">	<span class="keyword">if</span> oldPushContext != <span class="literal">nil</span> &#123;</span><br><span class="line">		oldPushContext.OnConfigChange()</span><br><span class="line">	&#125;</span><br><span class="line">	t0 := time.Now()</span><br><span class="line">	<span class="comment">// 创建新的PushContext，并基于已有PushContext和请求以及环境初始化新的PushContext</span></span><br><span class="line">	push := model.NewPushContext()</span><br><span class="line">	push.InitContext(s.Env, oldPushContext, req)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据最新的push信息，更新本地缓存</span></span><br><span class="line">	<span class="keyword">if</span> err := s.updateServiceShards(push); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s.updateMutex.Lock()</span><br><span class="line">	s.Env.PushContext = push</span><br><span class="line">	s.updateMutex.Unlock()</span><br><span class="line">  <span class="comment">// 生成版本号</span></span><br><span class="line">	versionLocal := time.Now().Format(time.RFC3339) + <span class="string">"/"</span> + strconv.FormatUint(versionNum.Load(), <span class="number">10</span>)</span><br><span class="line">	versionNum.Inc()</span><br><span class="line">	initContextTime := time.Since(t0)</span><br><span class="line">	versionMutex.Lock()</span><br><span class="line">	version = versionLocal</span><br><span class="line">	versionMutex.Unlock()</span><br><span class="line">	req.Push = push</span><br><span class="line">	<span class="keyword">go</span> s.AdsPushAll(versionLocal, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结其执行流程如下：</p>
<ol>
<li>若部分更新即只有EDS更新，则异步调用<code>AdsPushAll</code>下发；</li>
<li>若全局更新，首先创建出初始化新的Push上下文 <code>PushContext</code>（包含全局信息）；</li>
<li>根据最新的Push上下文更新本地的<code>IstioEndpoint</code>缓存；</li>
<li>生成新的版本号；</li>
<li>最后异步执行 <code>AdsPushAl</code> 下发。</li>
</ol>
<p>继续跟进<code>AdsPushAll</code>方法中：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">AdsPushAll</span><span class="params">(version <span class="keyword">string</span>, req *model.PushRequest)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !req.Full &#123;</span><br><span class="line">	   <span class="comment">// 增量eds更新下发，更新本地缓存。</span></span><br><span class="line">		s.edsIncremental(version, req.Push, req)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	cMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*EdsCluster, <span class="built_in">len</span>(edsClusters))</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> edsClusters &#123;</span><br><span class="line">		cMap[k] = v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> clusterName, edsCluster := <span class="keyword">range</span> cMap &#123;</span><br><span class="line">	   <span class="comment">// 更新本地缓存</span></span><br><span class="line">		s.updateCluster(req.Push, clusterName, edsCluster)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 下发将所有与DiscoveryServer建立的链接XdsConnection和下发请求组队，放入 pushQueue。s.pushQueue.Enqueue(p, req)</span></span><br><span class="line">	s.startPush(req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AdsPushAll</code>首先会根据下发请求更新本地缓存，然后再执行 <code>startPush</code> 进行下发。<code>startPush</code>将所有与DiscoveryServer建立的链接XdsConnection和下发请求组队，放入 pushQueue</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">startPush</span><span class="params">(req *model.PushRequest)</span></span> &#123;</span><br><span class="line">    pending := []*XdsConnection&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> adsClients &#123;</span><br><span class="line">		pending = <span class="built_in">append</span>(pending, v)</span><br><span class="line">	&#125;</span><br><span class="line">	req.Start = time.Now()</span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> pending &#123;</span><br><span class="line">		s.pushQueue.Enqueue(p, req)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>discovery.go/doSendPushes</code>方法会阻塞等待pushQueue的内容：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSendPushes</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, semaphore <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, queue *PushQueue)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		     <span class="comment">// 控制下发的并发度</span></span><br><span class="line">			semaphore &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">             <span class="comment">// 阻塞等待下发			</span></span><br><span class="line">			client, info := queue.Dequeue()</span><br><span class="line">			doneFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				queue.MarkDone(client)</span><br><span class="line">				&lt;-semaphore</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			   <span class="comment">// ...</span></span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="comment">// 向每个链接的下发通道中发送事件</span></span><br><span class="line">				<span class="keyword">case</span> client.pushChannel &lt;- &amp;XdsEvent&#123;</span><br><span class="line">					push:               info.Push,</span><br><span class="line">					edsUpdatedServices: edsUpdates,</span><br><span class="line">					done:               doneFunc,</span><br><span class="line">					start:              info.Start,</span><br><span class="line">					namespacesUpdated:  info.NamespacesUpdated,</span><br><span class="line">					configTypesUpdated: info.ConfigTypesUpdated,</span><br><span class="line">					noncePrefix:        info.Push.Version,</span><br><span class="line">				&#125;:</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				<span class="keyword">case</span> &lt;-client.stream.Context().Done(): <span class="comment">// 连接断开					doneFunc()</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="初始化集群注册器"><a href="#初始化集群注册器" class="headerlink" title="初始化集群注册器"></a>初始化集群注册器</h3><p><code>Pilot</code> 支持创建多集群注册中心，通过配置<code>istio/multiCluster=true</code> <strong>Secrets</strong> 类型，可以<code>Pilot</code>对接多<code>k8s</code>集群。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartSecretController</span><span class="params">(k8s kubernetes.Interface,</span></span></span><br><span class="line"><span class="function"><span class="params">    // ...</span></span></span><br><span class="line"><span class="function"><span class="params">	namespace <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	clusterStore := newClustersStore()</span><br><span class="line">	controller := NewController(k8s, namespace, clusterStore, addCallback, removeCallback)</span><br><span class="line">	<span class="keyword">go</span> controller.Run(stopCh)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewController</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	kubeclientset kubernetes.Interface,</span></span></span><br><span class="line"><span class="function"><span class="params">	namespace <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	cs *ClusterStore,</span></span></span><br><span class="line"><span class="function"><span class="params">	addCallback addSecretCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">	removeCallback removeSecretCallback)</span> *<span class="title">Controller</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Secret的Informer，监听 带`istio/multiCluster=true`d的Secret资源</span></span><br><span class="line">	secretsInformer := cache.NewSharedIndexInformer(</span><br><span class="line">		&amp;cache.ListWatch&#123;</span><br><span class="line">			ListFunc: <span class="function"><span class="keyword">func</span><span class="params">(opts meta_v1.ListOptions)</span> <span class="params">(runtime.Object, error)</span></span> &#123;</span><br><span class="line">				opts.LabelSelector = MultiClusterSecretLabel + <span class="string">"=true"</span></span><br><span class="line">				<span class="keyword">return</span> kubeclientset.CoreV1().Secrets(namespace).List(opts)</span><br><span class="line">			&#125;,</span><br><span class="line">			WatchFunc: <span class="function"><span class="keyword">func</span><span class="params">(opts meta_v1.ListOptions)</span> <span class="params">(watch.Interface, error)</span></span> &#123;</span><br><span class="line">				opts.LabelSelector = MultiClusterSecretLabel + <span class="string">"=true"</span></span><br><span class="line">				<span class="keyword">return</span> kubeclientset.CoreV1().Secrets(namespace).Watch(opts)</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		&amp;corev1.Secret&#123;&#125;, <span class="number">0</span>, cache.Indexers&#123;&#125;,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	controller := &amp;Controller&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		queue:          queue,</span><br><span class="line">		addCallback:    addCallback,</span><br><span class="line">		removeCallback: removeCallback,</span><br><span class="line">	&#125;</span><br><span class="line">	secretsInformer.AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">		AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			key, err := cache.MetaNamespaceKeyFunc(obj)</span><br><span class="line">			queue.Add(key)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> controller</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> c.informer.Run(stopCh)</span><br><span class="line">	wait.Until(c.runWorker, <span class="number">5</span>*time.Second, stopCh)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建集群</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">addMemberCluster</span><span class="params">(secretName <span class="keyword">string</span>, s *corev1.Secret)</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建跨集群注册服务流程如下：</p>
<ol>
<li>向当前对接k8s集群添加 带有<code>istio/multiCluster=true</code>的<strong>Secret</strong>资源；</li>
<li><strong>Pilot</strong> 获取此配置后，解析配置，并根据配置创建对应<code>k8s</code>集群的<code>client</code>，并基于此创建相应的注册器。</li>
</ol>
<p>初始化完所有组件后，调用<code>Server.Start</code>方法执行之前注入的<code>StartFunc</code>。<br>到此，<strong>Pilot</strong> 的初始化过程就结束了。</p>
<h3 id="初始化-ControlZ"><a href="#初始化-ControlZ" class="headerlink" title="初始化 ControlZ"></a>初始化 <code>ControlZ</code></h3><p><code>Pilot</code> 里挺有意思的一个设计。作用是开启一个端口向外暴露运维查询界面：<a href="https://istio.io/docs/ops/diagnostic-tools/controlz/" target="_blank" rel="noopener">官方介绍</a>。<br>目前支持：</p>
<ul>
<li><strong>ScopeTopic：</strong> 查询和修改日志级别</li>
<li><strong>MemTopic：</strong> 查询内存统计、强制GC</li>
<li><strong>ProcTopic：</strong>查询进程执行情况：进程ID、协程数、hostName等</li>
<li><strong>ArgsTopic：</strong>启动参数</li>
<li><strong>MetricsTopic：</strong> metric信息</li>
<li>…</li>
</ul>
<p>同时该机制支持组件拓展，比如配置服务可以通过该机制对外暴露接口查询信息。目前，<code>McpController</code>以及<code>sseMcpController</code>（组合服务MCP控制器）也是通过它来暴露查询信息接口的：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *configzTopic)</span> <span class="title">Activate</span><span class="params">(context fw.TopicContext)</span></span> &#123;</span><br><span class="line">	l := template.Must(context.Layout().Clone())</span><br><span class="line">	c.tmpl = template.Must(l.Parse(<span class="keyword">string</span>(assets.MustAsset(<span class="string">"templates/config.html"</span>))))</span><br><span class="line">	_ = context.HTMLRouter().StrictSlash(<span class="literal">true</span>).NewRoute().Path(<span class="string">"/"</span>).HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		d := c.collectData()</span><br><span class="line">		fw.RenderHTML(w, c.tmpl, d)</span><br><span class="line">	&#125;)</span><br><span class="line">	_ = context.JSONRouter().StrictSlash(<span class="literal">true</span>).NewRoute().Methods(<span class="string">"GET"</span>).Path(<span class="string">"/"</span>).HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		d := c.collectData()</span><br><span class="line">		fw.RenderJSON(w, http.StatusOK, d)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *configzTopic)</span> <span class="title">collectData</span><span class="params">()</span> *<span class="title">data</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;data&#123;</span><br><span class="line">		ID:             c.topic.ID(),</span><br><span class="line">		Metadata:       c.topic.Metadata(), <span class="comment">// mcp元数据</span></span><br><span class="line">		Collections:    c.topic.Collections(), <span class="comment">// mcp请求的资源集合包含版本信息</span></span><br><span class="line">		LatestRequests: c.topic.SnapshotRequestInfo(), <span class="comment">// 最近一组已知请求结果的快照信息</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CtrolZ</code>提供 接口<code>ctrlz.RegisterTopic(CreateTopic(topic)</code>来拓展信息暴露</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结启动过程大致如下：<br><img src="/media/15766110366375.jpg" alt=""></p>
<ol>
<li>根据参数创建 <code>k8s</code> Client；</li>
<li>从配置地址中获取 <strong>mesh</strong> 配置，并监听文件变更；</li>
<li>从配置地址获取 <strong>mesh</strong> 网络配置，并监听变更；</li>
<li>初始化配置控制器，支持文件配置、k8s配置、MCP协议配置服务；</li>
<li>初始化注册服务控制器，支持k8s、consul、实现MCP协议的拓展注册中心并且将配置控制器也包装成注册中心；</li>
<li>初始化发现服务，聚合之前初始化的控制器对外提供服务，包括http查询服务以及对<code>sidecar</code>服务的grpc服务；</li>
<li>初始化集群注册服务，使得pilot可以对接多k8s集群；</li>
<li></li>
<li>初始化所有组件后，调用初始化过程中添加的<code>StartFunc</code>开启所有组件的执行流程。</li>
</ol>
<h2 id="信息拉取与下发"><a href="#信息拉取与下发" class="headerlink" title="信息拉取与下发"></a>信息拉取与下发</h2><p>上一节介绍过，<code>DiscoveryServer.StreamAggregatedResources</code>用来接收客户端请求。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">StreamAggregatedResources</span><span class="params">(stream ads.AggregatedDiscoveryService_StreamAggregatedResourcesServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 从grpc stream上下文中获取 连接信</span></span><br><span class="line">    peerInfo, ok := peer.FromContext(stream.Context())</span><br><span class="line">    <span class="comment">//  初始化Push上下文，若是第一次，则会根据之前构建的Enviroment属性里面的 注册服务和配置服务 的内容初始化下全局的缓存信息</span></span><br><span class="line">    err := s.globalPushContext().InitContext(s.Env, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// 将每个sidecar对应stream、节点地址包装成XdsConnection，其会在下发时被使用</span></span><br><span class="line">    con := newXdsConnection(peerAddr, stream)</span><br><span class="line">    <span class="comment">// 开启 异步接收代理（sidecar、gateray）通过Stream发送过来的信息</span></span><br><span class="line">    <span class="keyword">go</span> receiveThread(con, reqChannel, &amp;receiveError)</span><br><span class="line">    <span class="comment">// 处理流程的核心部分：</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="comment">// 对于来自于 Sidecar的请求</span></span><br><span class="line">		<span class="keyword">case</span> discReq, ok := &lt;-reqChannel:</span><br><span class="line">		   <span class="comment">// 如果是第一次，代理会带上其自身节点信息 Node属性</span></span><br><span class="line">		  <span class="comment">// 使用解析出来的信息填充 XdsConnection</span></span><br><span class="line">			<span class="keyword">if</span> discReq.Node != <span class="literal">nil</span> &amp;&amp; discReq.Node.Id != <span class="string">""</span> &#123;</span><br><span class="line">				err = s.initConnectionNode(discReq.Node, con)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">switch</span> discReq.TypeUrl &#123;</span><br><span class="line">    			<span class="keyword">case</span> ClusterType:</span><br><span class="line">    				con.CDSWatch = <span class="literal">true</span></span><br><span class="line">    				<span class="comment">// 首先，跟据节点信息 构建envoy.Cluster信息</span></span><br><span class="line">    				<span class="comment">// 跟据Cluster构建DiscoveryResponse通过Stream返回代理</span></span><br><span class="line">    				s.pushCds(con, s.globalPushContext(), versionInfo())</span><br><span class="line">    			<span class="keyword">case</span> ListenerType:</span><br><span class="line">        			con.LDSWatch = <span class="literal">true</span></span><br><span class="line">        			<span class="comment">// 构建Listener信息</span></span><br><span class="line">        			<span class="comment">// 构建DiscoveryResponse通过Stream返回代理</span></span><br><span class="line">        			err := s.pushLds(con, s.globalPushContext(), versionInfo())</span><br><span class="line">        		<span class="keyword">case</span> RouteType:</span><br><span class="line">        		  <span class="comment">//...</span></span><br><span class="line">        		  err := s.pushRoute(con, s.globalPushContext(), versionInfo())</span><br><span class="line">        		<span class="keyword">case</span> EndpointType:</span><br><span class="line">        		  clusters := discReq.GetResourceNames()</span><br><span class="line">        		  <span class="keyword">for</span> _, cn := <span class="keyword">range</span> con.Clusters &#123;</span><br><span class="line">        		      s.removeEdsCon(cn, con.ConID)</span><br><span class="line">        		  &#125;</span><br><span class="line">        		  <span class="keyword">for</span> _, cn := <span class="keyword">range</span> clusters &#123;</span><br><span class="line">        		      s.getOrAddEdsCluster(cn, con.ConID, con)</span><br><span class="line">        		  &#125;</span><br><span class="line">        		  err := s.pushEds(s.globalPushContext(), con, versionInfo(), <span class="literal">nil</span>)</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">if</span> !con.added &#123;</span><br><span class="line">				con.added = <span class="literal">true</span></span><br><span class="line">				s.addCon(con.ConID, con)</span><br><span class="line">				<span class="keyword">defer</span> s.removeCon(con.ConID, con)</span><br><span class="line">			&#125;</span><br><span class="line">        <span class="keyword">case</span> pushEv := &lt;-con.pushChannel:</span><br><span class="line">            <span class="comment">// 接收更新下发</span></span><br><span class="line">            err := s.pushConnection(con, pushEv)</span><br><span class="line">            pushEv.done()</span><br></pre></td></tr></table></figure>
<p>总结其实现流程如下：</p>
<ol>
<li>首先 <code>StreamAggregatedResources</code> 是代理（Envoy， 可以是Sidecar角色也可以是Gateway角色）的入口，接收代理的Grpc Stream；</li>
<li>如果全局PushContext未初始化好，则进行一次初始化；</li>
<li>根据Stream信息构建 <code>XdsConnection</code></li>
<li>构建一个协程用于接收代理的请求，当请求到达时，丢进reqChannel中；</li>
<li>构建一个循环，同时接收代理的请求和要下发给代理的XdsEvent；</li>
<li><strong>对于请求：</strong><ul>
<li>当是首次接收代理的请求时，代理请求中会携带<code>Node</code>信息，Pilot会解析此信息并根据<code>Controller</code>查询相关信息来填充 <code>XdsConnection</code> 信息(代理的类型（sidecar\gateway）、ip地址、版本号、节点标签、关联的<code>ServiceInstance</code>)；</li>
<li>其后根据请求的<code>TypeUrl</code>判断请求类型进行相应处理；</li>
<li>对于每种类型请求<ul>
<li>会将对应的<code>XdsConnection.XXXWatch</code>置为True，表示代理对这种类型数据敏感，当有这种类型数据变更时，下发给它；</li>
<li>同时需要注意的是，下发的时候会带上版本号（<code>VersionInfo</code>）；</li>
<li>根据 <code>XdsConnection</code> 信息构建相应类型数据；（<code>pushXds</code>）</li>
<li>根据数据构建 <code>DiscoveryResponse</code>进行下发。</li>
</ul>
</li>
<li>最后会将<code>XdsConnection</code> 添加到<code>DiscoveryServer</code>中。</li>
</ul>
</li>
<li><strong>数据下发</strong>（之前提到：当信息变更时会捞出<code>DiscoveryServer</code>中保存的所有<code>XdsConnection</code>，然后往其<code>pushChannel</code>中发送<code>XdsEvent</code>）<ul>
<li>数据下发接口最终会调用<code>pushConnection</code>方法，其处理流程大致如下：<ul>
<li>如果只是Eds信息更新，则只下发<code>pushEds</code>；</li>
<li>如不是，则会依次下发 <code>CDS</code>、<code>EDS</code>、<code>LDS</code>、<code>Route</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="拓展性"><a href="#拓展性" class="headerlink" title="拓展性"></a>拓展性</h2><p>提到<code>Pilot</code>的拓展性，首先想到其支持对接实现<code>MCP</code>协议的配置中心和注册中心。下一章将首先介绍<code>MCP</code>协议，然后再结合<code>Galley</code>实例来讲解<code>MCP</code>的工作原理。<a href="https://github.com/istio/api/tree/master/mcp?spm=a2c4e.10696291.0.0.3b0419a4nAPVr2" target="_blank" rel="noopener">官方文档</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2019/10/12/istio/1.istio-%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/12/istio/1.istio-%E7%AE%80%E4%BB%8B/" itemprop="url">Istio 简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-12T00:00:00+08:00">2019-10-12</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/istio/" itemprop="url" rel="index"><span itemprop="name">istio</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a><a href="https://github.com/istio/istio" target="_blank" rel="noopener">Istio</a></h1><p>  <strong>Istio</strong> 是<code>An open platform to connect, manage, and secure microservices.</code>（用于连接、管理、保护微服务的开发平台)。由Google|Lyft|IBM联合开发，是当下开源社区最火的ServiceMesh项目。<br>  由于作者从事ServiceMesh相关研发工作，因此决定抽出时间来细致研究<code>Istio</code>核心原理，并落地本系列文章。<br>  本系列文章将详细讲解如下内容：<br>    1. <code>Istio</code> 整体架构&amp;核心工作流程<br>    2. <code>Pilot</code> 控制中枢源码解析<br>    2. <code>Galley</code><strong>&amp;</strong><code>MCP</code>源码解析<br>    3. <code>Mixer</code> 原理解析<br>    4. <code>Envoy</code> 原理解析<br>    5. 总结&amp;讨论</p>
<p>特别说明，本文内容基于<code>Istio@1.4.2</code>进行的源码分析。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2019/08/18/k8s/7.k8s-kubetl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/18/k8s/7.k8s-kubetl/" itemprop="url">k8s/7.k8s-kubetl</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-18T21:32:36+08:00">2019-08-18</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2019/01/03/database/zbera/zebra/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/03/database/zbera/zebra/" itemprop="url">数据库中间件Zebra</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-03T14:51:53+08:00">2019-01-03</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/database/" itemprop="url" rel="index"><span itemprop="name">database</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Zebra"><a href="#Zebra" class="headerlink" title="Zebra"></a>Zebra</h1><p>[TOC]</p>
<h2 id="Zebra是什么？能干甚么？"><a href="#Zebra是什么？能干甚么？" class="headerlink" title="Zebra是什么？能干甚么？"></a>Zebra是什么？能干甚么？</h2><p><code>Zebra</code>是一个在JDBC协议上开发的<strong>数据库连接池中间件</strong>，它不是真连接池(与DB直接交互的连接池)，而是对连接池做了一层包装。<br><img src="/media/15117842144905.jpg" alt=""><br><strong>功能：</strong></p>
<ol>
<li>支持适配目前主流的数据库连接池（如上图）</li>
<li>读写分离、分库分表</li>
<li>支持配置动态修改生效(连接池的配置、用户密码、数据库节点访问路由负载均衡配置)</li>
<li>CAT全方位监控（SQL执行情况、数据库连接数、端到端监控）</li>
<li>支持压测(改写表名)、SQL限流、黑白名单、SQL改写、<a href="https://wiki-in.sankuai.com/pages/viewpage.action?pageId=1169090716" target="_blank" rel="noopener">SQL审计</a>(日志审计，SQL安全监控)…</li>
</ol>
<h2 id="同类产品有哪些，以及比较？"><a href="#同类产品有哪些，以及比较？" class="headerlink" title="同类产品有哪些，以及比较？"></a>同类产品有哪些，以及比较？</h2><table>
<thead>
<tr>
<th>类别</th>
<th>案例</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>基于代理</td>
<td>mycat、cobor、atlas、jed</td>
<td>多语言支持、节省数据库连接</td>
<td>风险大(链路长)、实现难度大、共享连接时有风险</td>
</tr>
<tr>
<td>基于客户端(jdbc层)</td>
<td>tddl</td>
<td>直连数据库(风险较小)、更灵活</td>
<td>对于每种语言都需要重写sdk、富客户端的常见缺点</td>
</tr>
</tbody></table>
<p><strong>基于代理：</strong><br><img src="/media/15117932686716.jpg" alt=""></p>
<p><strong>基于客户端：</strong><br><img src="/media/15117932921029.jpg" alt="set up-w500"></p>
<blockquote>
<p>公司目前：北京侧 <code>Altas</code>居多，也有<code>Atlas</code>与<code>zebra</code>搭配使用（使用其压测处理、SQL监控特性），上海侧统一使用<code>zebra</code>。趋势是转向<strong>Zebra</strong>。<a href="https://wiki-ini.sankuai.com/pages/viewpage.action?pageId=686244717" target="_blank" rel="noopener">Atlas与Zebra的对比</a>。<strong>zebra秒杀Atlas?</strong><br><a href="https://wiki-ini.sankuai.com/pages/viewpage.action?pageId=1114400138" target="_blank" rel="noopener">数据库中间件比较</a></p>
</blockquote>
<p><strong><em>为什么美团一开始没有选择基于sdk的方式，而是基于代理的方式来做的？</em></strong></p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="/media/15117945912786.jpg" alt=""></p>
<ul>
<li>Zebra客户端做读写分离、分库分表、打点、监控</li>
<li>RDS、DBA管理平台维护配置信息</li>
<li>Lion监听配置更新，通知客户端生效变更</li>
<li>MHA保障主库的高可用性</li>
<li>zebra-monitor(<strong>自研</strong>)保障丛库的高可用性</li>
</ul>
<blockquote>
<p>MHA（Master High Availability）是作为MySQL高可用环境下，操作故障切换、主从提升的一套解决方案。MHA（Master High Availability）目前在MySQL高可用方面是一个相对成熟的解决方案。能做到30内完成故障切换。 <a href="http://ronaldbradford.com/#introduction" target="_blank" rel="noopener">官网</a>。<br>PS: <strong>Atlas</strong>维护主的高可用性也是MHA，且和Zebra是同一个MHA。</p>
</blockquote>
<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><h3 id="主库的高可用"><a href="#主库的高可用" class="headerlink" title="主库的高可用"></a>主库的高可用</h3><p>利用MHA进行master节点的可用性监控，在发生故障，master节点不可用时，<strong>MHA进行mysql层的主从切换</strong>，切换成功后通知zebra新master节点的IP，由zebra客户端负责应用访问层的切换。<a href="https://wiki-in.sankuai.com/pages/viewpage.action?pageId=614561285" target="_blank" rel="noopener">官方文档</a><br>切换流程如下：</p>
<p><img src="/media/15117954829456.jpg" alt=""></p>
<ol>
<li>MHA对MySQL集群进行监控管理</li>
<li>当主库发生故障时，MHA通知zebra对主库的写进行关闭，并进行MySQL集群的主从切换（切换期间应用无法写数据）</li>
<li>zebra禁止掉对故障集群的写操作</li>
<li>MHA切换成功，通知zebra新的写数据IP</li>
<li>zebra用新的写IP替换老IP，开放应用访问。</li>
</ol>
<h3 id="丛库的高可用"><a href="#丛库的高可用" class="headerlink" title="丛库的高可用"></a>丛库的高可用</h3><p>由<code>zebra-monitor</code>的监控服务负责，实时监控线上MySQL从库的健康状况，如果出现从库“故障”，将会通知zebra将读流量转移到其他可读节点，实现从库的“故障”转移。<br><img src="/media/15117960397314.jpg" alt=""></p>
<p><strong>丛库状态判断</strong>： zebra-monitor监控首先使用<code>select 1</code> 测试是否可以连通数据库，连接没有问题则使用 <code>show slave status</code> 获取到<code>second_behind_master</code>字段来得到该从库上的延迟，从而做出判断：</p>
<ul>
<li><p>markdown（故障）</p>
<ol>
<li>30s内从库连续ping不通； (从库宕机)</li>
<li>30s内 second_behind_master取到的延迟为null。 (主从同步中断)</li>
<li>延迟超过阈值。（可根据每个库的敏感程度进行个性化配置，需要进行另外配置）</li>
</ol>
<p><strong>故障处理：</strong>从库markdown，zebra客户端会收到通知动态刷新连接池配置，重建本地数据源配置，流量不会再走到故障丛库，老的数据源会在全部sql执行完成后被close。</p>
</li>
<li><p>markup(恢复)</p>
<ul>
<li>30s内能够连续ping通并且主从延迟为0.</li>
</ul>
</li>
</ul>
<p><strong>故障恢复：</strong>丛库恢复时，会通知客户端进行动态刷新数据源。</p>
<h1 id="Zebra-client"><a href="#Zebra-client" class="headerlink" title="Zebra-client"></a>Zebra-client</h1><p>##总览<br><img src="/media/15120548762216.jpg" alt=""></p>
<h3 id="推荐使用包搭配"><a href="#推荐使用包搭配" class="headerlink" title="推荐使用包搭配"></a>推荐使用包搭配</h3><p><strong>zebra-api</strong>、<strong>zebra-ds-monitor</strong>、<strong>mtrace-zebra</strong></p>
<h2 id="zebra-api"><a href="#zebra-api" class="headerlink" title="zebra-api"></a>zebra-api</h2><p><strong>ShardDataSource + m x GroupDataSource(Master + n x Slave)</strong><br><img src="/media/15118032253780.png" alt="set up-w600"></p>
<h3 id="SingleDataSource"><a href="#SingleDataSource" class="headerlink" title="SingleDataSource"></a>SingleDataSource</h3><ul>
<li>屏蔽底层DataSource的差异，通过<strong>C3p0DataSourceAdapter</strong>适配具体连接池配置，并根据配置创建指定类型的连接池。</li>
</ul>
<p><img src="/media/15118603297936.jpg" alt=""></p>
<h3 id="GroupDataSource"><a href="#GroupDataSource" class="headerlink" title="GroupDataSource"></a>GroupDataSource</h3><p><strong>GroupDataSource</strong>主要职能 <strong>读写分离、负载均衡与路由</strong>。但还有一个好处就是不需要写死配置(jdbcUrl、user|pwd、连接池配置，且配置修改可实时生效)。</p>
<p><img src="/media/15120563275340.jpg" alt=""></p>
<p><img src="/media/15120563707402.jpg" alt=""></p>
<p><img src="/media/15120564127233.jpg" alt=""></p>
<p><strong>读写分离策略：</strong> <a href="https://wiki-in.sankuai.com/pages/viewpage.action?pageId=735464033" target="_blank" rel="noopener">官方文档</a>：<br><img src="/media/15118644696383.jpg" alt="set up-w460"></p>
<p><strong>路由策略：</strong> <a href="https://wiki-in.sankuai.com/pages/viewpage.action?pageId=943490395" target="_blank" rel="noopener">官方文档</a>，见代码片段<br><img src="/media/15120566448649.jpg" alt="set up-w500"></p>
<h3 id="ShardDataSource"><a href="#ShardDataSource" class="headerlink" title="ShardDataSource"></a>ShardDataSource</h3><p><code>ShardDataSource</code>的职责是支持<strong>分库分表路由</strong>，除此之外还有并发执行等。<br><img src="/media/15118830559654.jpg" alt="set up-w600"></p>
<h4 id="分片规则："><a href="#分片规则：" class="headerlink" title="分片规则："></a>分片规则：</h4><p>利用脚本语言的灵活性，支持任意维度的分片：支持HASH、时间等，同时也可以使用Groovy内置的函数</p>
<p>示例脚本：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;shard-dimension dbRule=<span class="string">"(#id#.intValue() % 8).intdiv(2)"</span></span><br><span class="line">	dbIndexes=<span class="string">"id[0-3]"</span></span><br><span class="line">	tbRule=<span class="string">"#id#.intValue() % 2"</span></span><br><span class="line">	tbSuffix=<span class="string">"alldb:[0,7]"</span></span><br><span class="line">	isMaster=<span class="string">"true"</span>&gt;</span><br><span class="line">&lt;/shard-dimension&gt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RuleEngineBaseImpl</span> <span class="keyword">extends</span> <span class="title">com</span>.<span class="title">dianping</span>.<span class="title">zebra</span>.<span class="title">shard</span>.<span class="title">router</span>.<span class="title">rule</span>.<span class="title">engine</span>.<span class="title">RuleEngineBase</span> &#123;</span></span><br><span class="line">  Object execute(Map context) &#123;</span><br><span class="line">  (context.get(<span class="string">"id"</span>).intValue() % <span class="number">8</span>).intdiv(<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RuleEngineBaseImpl</span> <span class="keyword">extends</span> <span class="title">com</span>.<span class="title">dianping</span>.<span class="title">zebra</span>.<span class="title">shard</span>.<span class="title">router</span>.<span class="title">rule</span>.<span class="title">engine</span>.<span class="title">RuleEngineBase</span>&#123;</span></span><br><span class="line">  Object execute(Map context) &#123;</span><br><span class="line">    context.get(<span class="string">"id"</span>).intValue() % <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>SQL解析:</strong>利用<code>Druid</code>的<code>SqlParser</code>解析SQL成语法树，能从中直接获取SQL类型、SQL表名、参数名、Hint等…，以此为基础进行路由分库分表<br><strong>SQL路由:</strong> 根据SQL解析的结果以及配置的规则，通过运行规则运算脚本可以获得应该路由到哪个库的哪个表去执行。<br><strong>SQL改写:</strong>结合SQL解析器解析的结果、SQL路由的结果改写SQL语句(重设表名)<br><strong>并行执行:</strong>当路由结果需要到多个库的多张表中执行，则会使用线程池去并行执行结果并合并结果<br><strong>结果合并:</strong> 客户端将多库返回的所有结果加载到内存，进行合并操作</p>
</blockquote>
<h3 id="Filter链-Filter-Chain模式、责任链模式"><a href="#Filter链-Filter-Chain模式、责任链模式" class="headerlink" title="Filter链(Filter-Chain模式、责任链模式)"></a>Filter链(Filter-Chain模式、责任链模式)</h3><p><strong>Filter链</strong>是zebra实现可扩展性的机制。其作用相当于Spring AOP的<code>Interceptor</code>。<br>每个<strong>Filter</strong>可以在SQL执行的各个阶段起作用。比如<code>getConnection</code>、<code>prepareStatement</code>、<code>executeSingleStatement</code>。可以在<strong>Filter</strong>中实现监控连接池状态、SQL执行情况；改写SQL语句；改写SQL表名；SQL流控。</p>
<p><img src="/media/15118055319657.jpg" alt="set up-w600"><br><img src="/media/15118052735409.jpg" alt="set up-w600"></p>
<p>另外，业务方可以完全自行拓展<code>Filter</code>实现SQL执行统计、改写SQL等。（这里的<code>MtraceFilter</code>就是Mtrace的人员开发的。）</p>
<h4 id="怎么拓展？"><a href="#怎么拓展？" class="headerlink" title="怎么拓展？"></a>怎么拓展？</h4><ol>
<li>覆盖<strong>DefaultJdbcFilter</strong>，覆盖关注的SQL执行阶段对应的方法。</li>
<li>在META-INF中添加一个<code>zebra-filter.properties</code>中记录需要加入到<code>Filter链</code>中的自定义<code>Filter</code>:</li>
</ol>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">zebra.filter.mtrace</span>=<span class="string">com.meituan.mtrace.zebra.filter.MtraceFilter</span></span><br></pre></td></tr></table></figure>
<h2 id="zebra-dao"><a href="#zebra-dao" class="headerlink" title="zebra-dao"></a>zebra-dao</h2><p><strong>zebra-dao</strong>职责是<strong>异步化</strong>和<strong>物理分页</strong>。是在ORM框架<strong>MyBatis</strong>上做的一层封装（<a href="https://wiki-in.sankuai.com/pages/viewpage.action?pageId=507134914" target="_blank" rel="noopener">接入指南</a>）。</p>
<p><strong>异步化：</strong><br><code>MyBatis</code>中对每个访问层接口，都会生成一个代理对象，每个代理对象对应的<code>InvocationHandler</code>为<code>MapperProxy</code>。<br>而<code>zebra-dao</code>是在<code>MyBatis.MapperProxy</code>的代理对象上加了又加了一层代理<code>AsyncMapperProxy</code>。在<code>AsyncMapperProxy</code>中实现异步化。</p>
<blockquote>
<p>值得注意的是，这里异步化将请求放到线程池去执行，然后通过future.get()的形式，从IO模式上来说也只是阻塞模式，而不是NIO的方式；<br>另外，这里一个进程会共用一个线程池。</p>
</blockquote>
<p><strong>分页：</strong></p>
<ul>
<li><p>逻辑分页: 先从DB中拿出查询出来的所有的数据，而后再在内存中进行分页；</p>
</li>
<li><p>物理分页: 改写SQL，在SQL中加入分页部分的逻辑<code>limit 10,10</code>。</p>
</li>
<li><p>高级物理分页：不仅返回分页数据，同时也返回总数</p>
</li>
</ul>
<p><code>zebra-dao</code>实现分页的方式是实现MyBatis的<code>Interceptor</code>(<strong>PageInterceptor</strong>)。<code>Interceptor</code>是MyBatis的插件(另一种拓展性方式)，通过它可以在MyBatis的执行过程中插入一些额外的逻辑。这里<code>PageInterceptor</code>主要是作用针对<code>query</code>方法。具体做法是：    </p>
<ul>
<li>改写SQL在尾部添加 limit x,x；</li>
<li>如果是高级物理分页，则会再进行一次<code>select count(*)</code>查询，然后返回。<br><a href="">见源码片段</a></li>
</ul>
<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><h2 id="zebra-api-1"><a href="#zebra-api-1" class="headerlink" title="zebra-api"></a>zebra-api</h2><h3 id="GroupDataSource-1"><a href="#GroupDataSource-1" class="headerlink" title="GroupDataSource"></a>GroupDataSource</h3><p><code>GroupDataSource</code>初始化时，会从配置平台读取所有数据库节点的配置信息。然后依据这些信息来创建两种类型的代理数据源d <strong>FailOverDataSource</strong>和<strong>LoadBalancedDataSource</strong>。其中，<code>FailOverDataSource</code>用来连接和管理主节点故障的拒绝写等。<code>LoadBalancedDataSource</code>则是用来连接所有从节点，并负责从节点读流量的路由。</p>
<h4 id="读写策略"><a href="#读写策略" class="headerlink" title="读写策略"></a>读写策略</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">LoadBalancedDataSource readDataSource;</span><br><span class="line"></span><br><span class="line">FailOverDataSource writeDataSource;</span><br><span class="line"></span><br><span class="line"><span class="function">Connection <span class="title">getRealConnection</span><span class="params">(boolen forceWrite)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//是否进行了强行配置</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.routerType == RouterType.SLAVE_ONLY) &#123;</span><br><span class="line">    	<span class="keyword">return</span> getReadConnection();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.routerType == RouterType.MASTER_ONLY) &#123;</span><br><span class="line">    	<span class="keyword">return</span> getWriteConnection();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//主制度</span></span><br><span class="line">    <span class="keyword">if</span> (forceWrite) &#123;</span><br><span class="line">    	<span class="keyword">return</span> getWriteConnection();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!autoCommit ||</span><br><span class="line">    <span class="comment">// SQL中带有HINT</span></span><br><span class="line">    StringUtils.trimToEmpty(sql).contains(<span class="string">"/*+zebra:w*/"</span>)</span><br><span class="line">          || StringUtils.trimToEmpty(sql).contains(<span class="string">"/*master*/"</span>)) &#123;</span><br><span class="line">    	<span class="keyword">return</span> getWriteConnection();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readWriteStrategy != <span class="keyword">null</span> &amp;&amp; readWriteStrategy.shouldReadFromMaster()) &#123;</span><br><span class="line">    <span class="comment">//即设置了ZebraForceMasterHelper.forceMasterInLocalContext()</span></span><br><span class="line">    	<span class="keyword">return</span> getWriteConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过Druid parser解析出SQL的类型</span></span><br><span class="line">    SqlType sqlType = SqlUtils.getSqlType(sql);</span><br><span class="line">    <span class="keyword">if</span> (sqlType.isRead()) &#123;</span><br><span class="line">    	<span class="keyword">return</span> getReadConnection();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> getWriteConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Connection <span class="title">getReadConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readDataSource.getConnection();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Connection getWriteConnection &#123;</span><br><span class="line">    <span class="keyword">return</span> writeDataSource.getConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="路由策略-针对读流量-："><a href="#路由策略-针对读流量-：" class="headerlink" title="路由策略(针对读流量)："></a>路由策略(针对读流量)：</h4><p><strong>LoadBalanceDataSource</strong>中的<code>router</code>负责物理库和表的路由。</p>
<p>初始化时，会根据用户设置的配置信息(<code>idcAware</code>、..)，创建路由</p>
<ul>
<li>先将所有的数据库节点信息按是否与本地机器在同一个区域，分为两个集合 <code>localRegionRouter</code>、<code>remoteRegionRouter</code>；</li>
<li>跟据配置的路由策略（<code>IdcAwareRouter</code>、<code>CenterWeightRouter</code>、<code>RegionAwareRouter</code>）选择不同的实际路由器。</li>
<li>(1) 如果设置的只是区域感知的话，则直接按权重路由<code>WeightDataSourceRouter</code></li>
<li>(2) 如果设置的是<code>CenterAware</code>，则将选择的是<code>CenterAwareRouter</code></li>
<li>(3) 如果设置的是<code>IdcAware</code>，也是<code>CenterAwareRouter</code>，只是<code>CenterAwareRouter</code>中还有一个<code>IdcAwareRouter</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RegionAwareRouter</span><span class="params">(Map&lt;String, DataSourceConfig&gt; dataSourceConfigs, String configManagerType,</span></span></span><br><span class="line"><span class="function"><span class="params">			String routerStrategy)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.regionManager = ZebraRegionManagerLoader.getRegionManager(configManagerType);</span><br><span class="line"></span><br><span class="line">	Map&lt;String, DataSourceConfig&gt; localRegionDataSourceConfigs = <span class="keyword">new</span> HashMap&lt;String, DataSourceConfig&gt;();</span><br><span class="line">	Map&lt;String, DataSourceConfig&gt; remoteRegionDataSourceConfigs = <span class="keyword">new</span> HashMap&lt;String, DataSourceConfig&gt;();</span><br><span class="line">  <span class="comment">//将所有的数据库节点分为同区域节点、和不同区域节点</span></span><br><span class="line">	<span class="keyword">for</span> (Map.Entry&lt;String, DataSourceConfig&gt; entry : dataSourceConfigs.entrySet()) &#123;</span><br><span class="line">		String dsId = entry.getKey();</span><br><span class="line">		DataSourceConfig config = entry.getValue();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Matcher matcher = JDBC_URL_PATTERN.matcher(config.getJdbcUrl());</span><br><span class="line">			<span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">				String url = matcher.group(<span class="number">1</span>);</span><br><span class="line">				String[] urlAndPort = url.split(<span class="string">":"</span>);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (urlAndPort != <span class="keyword">null</span> &amp;&amp; urlAndPort.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (<span class="keyword">this</span>.regionManager.isInLocalRegion(urlAndPort[<span class="number">0</span>])) &#123;</span><br><span class="line">						localRegionDataSourceConfigs.put(dsId, config);</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						remoteRegionDataSourceConfigs.put(dsId, config);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				remoteRegionDataSourceConfigs.put(dsId, config);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">			logger.warn(String.format(</span><br><span class="line">					<span class="string">"Cannot recognize the idc for jdbcUrl(%s), so put this datasource in the other region by default."</span>,</span><br><span class="line">					config.getJdbcUrl()));</span><br><span class="line">			remoteRegionDataSourceConfigs.put(dsId, config);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//如果路由策略配置的只是同区域优先，则同区域内部走权重路由</span></span><br><span class="line">	<span class="keyword">if</span> (Constants.ROUTER_STRATEGY_REGION_AWARE_ROUTER.equals(routerStrategy)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (localRegionDataSourceConfigs.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.localRegionRouter = <span class="keyword">new</span> WeightDataSourceRouter(localRegionDataSourceConfigs);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (remoteRegionDataSourceConfigs.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.remoteRegionRouter = <span class="keyword">new</span> WeightDataSourceRouter(remoteRegionDataSourceConfigs);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 如果设置的是中心感知或机房感知</span></span><br><span class="line">		<span class="keyword">boolean</span> idcAware = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (Constants.ROUTER_STRATEGY_IDC_AWARE_ROUTER.equals(routerStrategy)) &#123;</span><br><span class="line">			idcAware = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (localRegionDataSourceConfigs.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.localRegionRouter = <span class="keyword">new</span> CenterAwareRouter(localRegionDataSourceConfigs, configManagerType,</span><br><span class="line">					idcAware);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (remoteRegionDataSourceConfigs.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.remoteRegionRouter = <span class="keyword">new</span> CenterAwareRouter(remoteRegionDataSourceConfigs, configManagerType,</span><br><span class="line">					idcAware);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CenterAwareRouter</span> <span class="keyword">implements</span> <span class="title">DataSourceRouter</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> DataSourceRouter localCenterRouter;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">CenterAwareRouter</span><span class="params">(Map&lt;String, DataSourceConfig&gt; dataSourceConfigs, String configManagerType,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">boolean</span> idcAware)</span> </span>&#123;</span><br><span class="line">			...</span><br><span class="line">    	<span class="keyword">if</span> (idcAware) &#123;</span><br><span class="line">    		localCenterSourceConfigs.putAll(localIdcSourceConfigs);</span><br><span class="line">    		<span class="keyword">if</span> (localCenterSourceConfigs.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    		<span class="comment">//IdcAwareRouter的节点必定在同中心</span></span><br><span class="line">    			<span class="keyword">this</span>.localCenterRouter = <span class="keyword">new</span> IdcAwareRouter(localCenterSourceConfigs, configManagerType);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouterTarget <span class="title">select</span><span class="params">(RouterContext routerContext)</span> </span>&#123;</span><br><span class="line">    	RouterTarget routerTarget = <span class="keyword">null</span>;</span><br><span class="line">    	<span class="comment">//存在同机房路由，则有同机房路由</span></span><br><span class="line">    	<span class="keyword">if</span> (localCenterRouter != <span class="keyword">null</span>) &#123;</span><br><span class="line">    		routerTarget = localCenterRouter.select(routerContext);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span> (routerTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">    		<span class="keyword">for</span> (WeightDataSourceRouter weightDataSourceRouter : priorityCenterIdcAwareRouters) &#123;</span><br><span class="line">    			routerTarget = weightDataSourceRouter.select(routerContext);</span><br><span class="line">    			<span class="keyword">if</span> (routerTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">    				<span class="keyword">return</span> routerTarget;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> routerTarget;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ShardDataSource-1"><a href="#ShardDataSource-1" class="headerlink" title="ShardDataSource"></a>ShardDataSource</h3><h4 id="分库分表原理"><a href="#分库分表原理" class="headerlink" title="分库分表原理"></a>分库分表原理</h4><p><code>ShardDataSource</code>中的<strong>DefaultShardRouter</strong>负责分库分表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//路由规则：根据分库分表规则和运行时参数，计算出应该到的库名和表名</span></span><br><span class="line">RouterRule routerRule;</span><br><span class="line"><span class="comment">//负责RouterRule计算的结果改写SQL，形成带有物理表名的SQL</span></span><br><span class="line">SQLRewrite sqlRewrite = <span class="keyword">new</span> DefaultSQLRewrite();</span><br></pre></td></tr></table></figure>
<p>执行路由的逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RouterResult <span class="title">router</span><span class="params">(<span class="keyword">final</span> String sql, List&lt;Object&gt; params)</span> <span class="keyword">throws</span> ShardRouterException, ShardParseException </span>&#123;</span><br><span class="line">	RouterResult routerResult = <span class="keyword">new</span> RouterResult();</span><br><span class="line">	<span class="comment">//解析SQL得出表名等信息</span></span><br><span class="line">	SQLParsedResult parsedResult = SQLParser.parseWithCache(sql);</span><br><span class="line">    <span class="comment">//根据SQL解析结果找出对应表逻辑名的分片规则。</span></span><br><span class="line">	List&lt;TableShardRule&gt; findShardRules = findShardRules(parsedResult.getRouterContext(), params);</span><br><span class="line">	<span class="keyword">if</span> (findShardRules.size() == <span class="number">1</span>) &#123;</span><br><span class="line">		TableShardRule tableShardRule = findShardRules.get(<span class="number">0</span>);</span><br><span class="line">		<span class="comment">//执行逻辑表的分片规则获得物理库和表名</span></span><br><span class="line">		ShardEvalResult shardResult = tableShardRule.eval(<span class="keyword">new</span> ShardEvalContext(parsedResult, params));</span><br><span class="line">		routerResult.setMergeContext(<span class="keyword">new</span> MergeContext(parsedResult.getMergeContext()));</span><br><span class="line">		routerResult.setSqls(buildSqls(shardResult.getDbAndTables(), parsedResult, tableShardRule.getTableName()));</span><br><span class="line">		routerResult.setParams(buildParams(params, routerResult));</span><br><span class="line">		<span class="keyword">return</span> routerResult;</span><br><span class="line">	&#125;...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ShardEvalResult <span class="title">eval</span><span class="params">(ShardEvalContext matchContext)</span> </span>&#123;</span><br><span class="line">	ShardEvalResult result = <span class="keyword">new</span> ShardEvalResult(matchContext.getTableName());</span><br><span class="line">	<span class="keyword">for</span> (ColumnValue evalContext : matchContext.getColumnValues()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!evalContext.isUsed()) &#123;</span><br><span class="line">			evalContext.setUsed(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//通过库规则，获得在库的索引号</span></span><br><span class="line">			Object dbObj = dbRuleEngine.eval(evalContext.getValue());</span><br><span class="line">			Number dbPos = (Number)dbObj;</span><br><span class="line">			TableSets tableSet = tablesMappingManager.getTableSetsByPos(dbPos.intValue());</span><br><span class="line">			<span class="comment">//通过表规则，获得表的索引号</span></span><br><span class="line">			Number tablePos = (Number) tableRuleEngine.eval(evalContext.getValue());</span><br><span class="line">			String table = tableSet.getTableSets().get(tablePos.intValue());</span><br><span class="line">			result.addDbAndTable(tableSet.getDbIndex(), table);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="zebra-dao-1"><a href="#zebra-dao-1" class="headerlink" title="zebra-dao"></a>zebra-dao</h2><h3 id="异步化"><a href="#异步化" class="headerlink" title="异步化"></a>异步化</h3><p><strong>MyBatis</strong>中每个DAO都对应一个<code>MapperProxy</code>，zebra-dao中则是<code>AsyncMapperProxy</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncMapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否是带有回调的方法</span></span><br><span class="line">        <span class="keyword">if</span> (isCallbackMethod(method, args)) &#123;</span><br><span class="line">        	Method _method = getAnnotationMethod(method);</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        	Object[] newArgs = <span class="keyword">new</span> Object[args.length - <span class="number">1</span>];</span><br><span class="line">        	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        	AsyncDaoCallback callback = <span class="keyword">null</span>;</span><br><span class="line">        	<span class="keyword">for</span> (Object arg : args) &#123;</span><br><span class="line">        		<span class="keyword">if</span> (arg != <span class="keyword">null</span>) &#123;</span><br><span class="line">        			<span class="keyword">if</span> (!AsyncDaoCallback<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">arg</span>.<span class="title">getClass</span>())) </span>&#123;</span><br><span class="line">        				newArgs[i++] = arg;</span><br><span class="line">        			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        				callback = (AsyncDaoCallback) arg;</span><br><span class="line">        			&#125;</span><br><span class="line">        		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        			newArgs[i++] = arg;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">            <span class="comment">//异步执行，并设置回调</span></span><br><span class="line">        	AsyncMapperExecutor.executeRunnable(mapper, _method, newArgs, callback);</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Future<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">method</span>.<span class="title">getReturnType</span>())) </span>&#123;</span><br><span class="line">        <span class="comment">//返回值是Future，则也异步发起请求</span></span><br><span class="line">        	Method _method = getAnnotationMethod(method);       </span><br><span class="line">        	<span class="keyword">if</span> (_method != <span class="keyword">null</span>) &#123;</span><br><span class="line">        		<span class="keyword">return</span> AsyncMapperExecutor.submitCallback(mapper, _method, args);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//直接调用</span></span><br><span class="line">        	<span class="keyword">return</span> method.invoke(mapper, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分页-PageInterceptor"><a href="#分页-PageInterceptor" class="headerlink" title="分页 - PageInterceptor"></a>分页 - PageInterceptor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">Object[] args = invocation.getArgs();</span><br><span class="line">		Object rowBound = args[<span class="number">2</span>];</span><br><span class="line">MappedStatement ms = (MappedStatement) args[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (rowBound != <span class="keyword">null</span>) &#123;</span><br><span class="line">	RowBounds rb = (RowBounds) rowBound;</span><br><span class="line">	<span class="comment">// 无分页信息</span></span><br><span class="line">	<span class="keyword">if</span> (rb.getOffset() == RowBounds.NO_ROW_OFFSET &amp;&amp; rb.getLimit() == RowBounds.NO_ROW_LIMIT) &#123;</span><br><span class="line">		<span class="keyword">return</span> invocation.proceed();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		BoundSql boundSql = ms.getBoundSql(args[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">if</span> (rowBound <span class="keyword">instanceof</span> PageModel) &#123;</span><br><span class="line">			<span class="comment">// 高级物理分页</span></span><br><span class="line">			PageModel pageModel = (PageModel) rowBound;</span><br><span class="line">			<span class="comment">//首先获得次数</span></span><br><span class="line">			Object count = queryCount(invocation, args, ms, boundSql);</span><br><span class="line">			<span class="comment">//获取结果</span></span><br><span class="line">			Object records = queryLimit(invocation, args, ms, boundSql, pageModel);</span><br><span class="line">			pageModel.setRecordCount((Integer) ((List&lt;?&gt;) count).get(<span class="number">0</span>));</span><br><span class="line">			pageModel.setRecords((List&lt;?&gt;) records);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 物理分页</span></span><br><span class="line">			<span class="keyword">return</span> queryLimit(invocation, args, ms, boundSql, rb);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// without pagination</span></span><br><span class="line">	<span class="keyword">return</span> invocation.proceed();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">queryCount</span><span class="params">(Invocation invocation, Object[] args, MappedStatement ms, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过原始SQL生成select count(*)语句，通过SQL Parser解析SQL，再拼接SQL</span></span><br><span class="line">    String countSql = dialect.getCountSql(boundSql.getSql());</span><br><span class="line">	<span class="comment">//生成新的SQL</span></span><br><span class="line">	BoundSql newBoundSql = <span class="keyword">new</span> BoundSql(ms.getConfiguration(), countSql, boundSql.getParameterMappings(),</span><br><span class="line">			boundSql.getParameterObject());</span><br><span class="line">	<span class="comment">//生成新的Statement 去执行select count(*)</span></span><br><span class="line">	countRowStatement = buildMappedStatement(ms, <span class="keyword">new</span> SqlSqlSourceWrapper(newBoundSql), ms.getId() + <span class="string">"_COUNT"</span>,</span><br><span class="line">			resultMaps);</span><br><span class="line"></span><br><span class="line">	args[<span class="number">0</span>] = countRowStatement;</span><br><span class="line">	args[<span class="number">2</span>] = <span class="keyword">new</span> RowBounds();</span><br><span class="line">	args[<span class="number">3</span>] = <span class="keyword">null</span>;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">queryLimit</span><span class="params">(Invocation invocation, Object[] args, MappedStatement ms, BoundSql boundSql, RowBounds rb)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//生成带有limit的SQL</span></span><br><span class="line">	String limitSql = dialect.getLimitSql(boundSql.getSql(), rb.getOffset(), rb.getLimit());</span><br><span class="line">	BoundSql newBoundSql = <span class="keyword">new</span> BoundSql(ms.getConfiguration(), limitSql, boundSql.getParameterMappings(),</span><br><span class="line">			boundSql.getParameterObject());</span><br><span class="line">	<span class="comment">//构造新的Statement去执行分页语句</span></span><br><span class="line">	args[<span class="number">0</span>] = buildMappedStatement(ms, <span class="keyword">new</span> SqlSqlSourceWrapper(newBoundSql), ms.getId() + <span class="string">"_LIMIT"</span>,</span><br><span class="line">			ms.getResultMaps());</span><br><span class="line">	args[<span class="number">2</span>] = <span class="keyword">new</span> RowBounds();</span><br><span class="line">	args[<span class="number">3</span>] = <span class="keyword">null</span>;</span><br><span class="line">  	<span class="keyword">return</span> invocation.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SQL解析与改写"><a href="#SQL解析与改写" class="headerlink" title="SQL解析与改写"></a>SQL解析与改写</h2><p>Zebra在之前的版本中使用Antlr解析SQL，后来的版本替换成了Druid的 <strong>Sql Parser</strong>。<strong>Druid</strong>是个非常强大的工具，它支持达9种数据库类型SQL(db2|h2|mysql|hive|oracle…)。<br>这里我们以<strong>MySQL</strong>为例来介绍其SQL解析过程。<br><img src="/media/15119598460937.jpg" alt=""></p>
<p>SQL的解析过程，分为<strong>词法分析</strong>和<strong>语法分析</strong>：</p>
<ul>
<li><strong>词法分析</strong>用来识别词汇，如关键字等。<code>Lexer</code>就是用于词法分析的词法分析器。每个词法器都有自己的词汇库，<code>KeyWords</code>就是词汇库，且是所有数据库共用的词汇库。<code>MySQLLexer</code>是<code>Lexer</code>的子类。是用来专门解析<code>MySQL</code>的SQL语句。它的词汇库也在<code>KeyWords</code>加上了<code>MySQL</code>特有的关键字<code>LIMIT</code>、<code>IDENTIFIED</code>等；</li>
<li><strong>语法分析</strong>是在词法分析的基础上进行语法分析。生成一颗AST(<code>abstract syntax tree</code><strong>抽象语法树</strong>)。且其过程中也会判断用户的输入是否符合语法逻辑；</li>
</ul>
<p>先来看一个词法分析的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"select * from order where cinema_id = 11 order by id, user_id"</span>;</span><br><span class="line">Lexer lexer = <span class="keyword">new</span> Lexer(sql);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  <span class="comment">//触发下一个词识别，识别过程即在其中。(各种if|switch，有限状态机)</span></span><br><span class="line">  lexer.nextToken();</span><br><span class="line">  <span class="comment">//获取识别的词</span></span><br><span class="line">  Token tok = lexer.token();</span><br><span class="line">  <span class="comment">//标识符</span></span><br><span class="line">  <span class="keyword">if</span> (tok == Token.IDENTIFIER) &#123;</span><br><span class="line">      System.out.println(tok.name() + <span class="string">"\t\t"</span> + lexer.stringVal());</span><br><span class="line">  <span class="comment">//数字</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tok == Token.LITERAL_INT) &#123;</span><br><span class="line">      System.out.println(tok.name() + <span class="string">"\t\t"</span> + lexer.numberString());</span><br><span class="line">  <span class="comment">//其他类型</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(tok.name() + <span class="string">"\t\t\t"</span> + tok.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//条件判断，以及其在SQL中的位置</span></span><br><span class="line">  <span class="keyword">if</span> (tok == Token.WHERE) &#123;</span><br><span class="line">      System.out.println(<span class="string">"where pos : "</span> + lexer.pos());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//结束标记</span></span><br><span class="line">  <span class="keyword">if</span> (tok == Token.EOF) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其输出结果是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT			SELECT</span><br><span class="line">STAR			*</span><br><span class="line">FROM			FROM</span><br><span class="line">ORDER			ORDER</span><br><span class="line">WHERE			WHERE</span><br><span class="line">where pos : <span class="number">25</span></span><br><span class="line">IDENTIFIER		cinema_id</span><br><span class="line">EQ			=</span><br><span class="line">LITERAL_INT		<span class="number">11</span></span><br><span class="line">ORDER			ORDER</span><br><span class="line">BY			BY</span><br><span class="line">IDENTIFIER		id</span><br><span class="line">COMMA			,</span><br><span class="line">IDENTIFIER		user_id</span><br><span class="line">EOF			<span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p><strong>语法分析器</strong>在进行语法分析时，会根据词法分析器分析出的TOKEN、值来创建不同类型的节点，加到AST树中。<br>例如：</p>
<blockquote>
<p><code>SELECT</code> -&gt; <code>SQLSelect</code><br><code>Order by</code> -&gt; <code>SQLOrderBy</code><br><code>*</code> -&gt; <code>SQLSelectItem</code>(每个结果集字段一个SQLSelectItem)<br><code>FROM</code> -&gt; <code>SQLTableSource</code>，SQLExprTableSource或者<code>SQLSelect</code>(嵌套查询)</p>
</blockquote>
<p>以下面的例子来说明语法分析生成的结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>, movie_id <span class="keyword">from</span> <span class="keyword">order</span> <span class="keyword">where</span> cinema_id = <span class="number">11</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span>, user_id</span><br></pre></td></tr></table></figure>

<p>生成的语法树如下：<br><img src="/media/15119747197151.jpg" alt=""></p>
<p>对AST树信息的访问，<code>Druid</code>定义一套接口<code>SQLASTVisitor</code>。业务方可以实现接口加入特定信息收集逻辑。调用<code>SQLStatement.accept(visitor)</code>，<code>visitor</code>就会以类先序的顺序访问树上的所有节点。<br>下面给出一个自定义查找SQL中出现了哪些表名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableNameASTVisitor</span> <span class="keyword">implements</span> <span class="title">MySqlASTVisitor</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; tableNames = Lists.newArrayList();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">visit</span><span class="params">(SQLExprTableSource x)</span> </span>&#123;</span><br><span class="line">        SQLName name = x.getName();</span><br><span class="line">        <span class="keyword">if</span> (name!= <span class="keyword">null</span>) &#123;</span><br><span class="line">            tableNames.add(name.getSimpleName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">visit</span><span class="params">(SQLSelect x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">visit</span><span class="params">(SQLSelectStatement astNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getTableNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tableNames;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">String sql = <span class="string">"select id, name, movie_id from order where cinema_id = 11 order by id, user_id"</span>;</span><br><span class="line">SQLStatementParser parser = <span class="keyword">new</span> MySqlStatementParser(sql);</span><br><span class="line">SQLStatement statement = parser.parseStatement();</span><br><span class="line">TableNameASTVisitor visitor = <span class="keyword">new</span> TableNameASTVisitor();</span><br><span class="line">statement.accept(visitor);</span><br><span class="line">System.out.println(visitor.getTableNames());</span><br><span class="line"><span class="comment">//输出结果为 [order]</span></span><br></pre></td></tr></table></figure>
<p><strong>ShardRouter</strong>实现SQL改写的方式就是实现了一个<strong>Visitor</strong>-<strong>SimpleRewriteTableOutputVisitor</strong>，在其内部，将逻辑表名改写为路由后的物理表名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleRewriteTableOutputVisitor</span> <span class="keyword">extends</span> <span class="title">MySqlOutputVisitor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; tableMapping;</span><br><span class="line">    <span class="comment">//访问保存表信息的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">visit</span><span class="params">(SQLExprTableSource x)</span> </span>&#123;</span><br><span class="line">		SQLName name = (SQLName) x.getExpr();</span><br><span class="line">		String simpleName = name.getSimpleName();</span><br><span class="line">		<span class="keyword">boolean</span> hasQuote = simpleName.charAt(<span class="number">0</span>) == <span class="string">'`'</span>;</span><br><span class="line">		<span class="comment">//逻辑表名</span></span><br><span class="line">		String tableName = hasQuote ? parseTableName(simpleName) : simpleName;</span><br><span class="line">		<span class="comment">//物理表名</span></span><br><span class="line">		String finalTable = tableMapping.get(tableName);</span><br><span class="line">		...</span><br><span class="line">		print0(<span class="string">"`"</span> + finalTable + <span class="string">"`"</span>);</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avator.jpeg"
                alt="Zamperini" />
            
              <p class="site-author-name" itemprop="name">Zamperini</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/%7C%7C%20archive">
                
                    <span class="site-state-item-count">55</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/DorgenJones" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:dblpfilter@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/1938368215" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zamperini</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.0.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.3"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
