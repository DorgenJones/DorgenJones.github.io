<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.3">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.3" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="etcd,apiserver," />


<meta name="description" content="0. ETCD简介本文将从以下几个方面来分析 ETCD （v3.3.12）。  整体架构 启动过程 数据存储 通信方式 TTL实现原理 Lease实现原理 单次事务过程 线性一致性读过程 Watch机制    在介绍上面所有过程之前，我们先来介绍下 ETCD的整体架构以及相关名词术语。    12345678910111213141516171819202122- Node：一个Raft状态机节点">
<meta property="og:type" content="article">
<meta property="og:title" content="ETCD汇总">
<meta property="og:url" content="https://dorgenjones.github.io/2019/12/01/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/etcd/2020-02-25/index.html">
<meta property="og:site_name" content="Zamperini">
<meta property="og:description" content="0. ETCD简介本文将从以下几个方面来分析 ETCD （v3.3.12）。  整体架构 启动过程 数据存储 通信方式 TTL实现原理 Lease实现原理 单次事务过程 线性一致性读过程 Watch机制    在介绍上面所有过程之前，我们先来介绍下 ETCD的整体架构以及相关名词术语。    12345678910111213141516171819202122- Node：一个Raft状态机节点">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://dorgenjones.github.io/media/15518040419086.jpg">
<meta property="og:image" content="https://dorgenjones.github.io/media/15512352647387.jpg">
<meta property="og:image" content="https://dorgenjones.github.io/media/15516348174091.jpg">
<meta property="og:image" content="https://dorgenjones.github.io/media/15516311446785.jpg">
<meta property="article:published_time" content="2019-11-30T16:00:00.000Z">
<meta property="article:modified_time" content="2020-02-25T09:56:01.101Z">
<meta property="article:author" content="Zamperini">
<meta property="article:tag" content="etcd">
<meta property="article:tag" content="apiserver">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dorgenjones.github.io/media/15518040419086.jpg">






  <link rel="canonical" href="https://dorgenjones.github.io/2019/12/01/分布式存储/etcd/2020-02-25/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>ETCD汇总 | Zamperini</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Zamperini</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2019/12/01/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/etcd/2020-02-25/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ETCD汇总</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-01T00:00:00+08:00">2019-12-01</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/etcd/" itemprop="url" rel="index"><span itemprop="name">etcd</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="0-ETCD简介"><a href="#0-ETCD简介" class="headerlink" title="0. ETCD简介"></a>0. ETCD简介</h1><p>本文将从以下几个方面来分析 ETCD （<code>v3.3.12</code>）。</p>
<ol start="0">
<li>整体架构</li>
<li>启动过程</li>
<li>数据存储</li>
<li>通信方式</li>
<li>TTL实现原理</li>
<li>Lease实现原理</li>
<li>单次事务过程</li>
<li>线性一致性读过程</li>
<li>Watch机制</li>
</ol>
<!--9. 运维相关：
    1. 主宕机
    2. 从宕机
    3. 添加新节点-->

<p>在介绍上面所有过程之前，我们先来介绍下 <strong>ETCD</strong>的整体架构以及相关名词术语。</p>
<!--[1.ETCD原理](https://www.cnblogs.com/panpanwelcome/p/8242418.html)-->


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- Node：一个Raft状态机节点；</span><br><span class="line">- Proxy：etcd的一种模式，为etcd集群提供反向代理服务；</span><br><span class="line">- Member： etcd集群中的一个节点。它可以与其他节点进行交互且为客户端提供服务；</span><br><span class="line">- Cluster：由多个Member组成的etcd集群；</span><br><span class="line">- Peer：对处在相同集群中其他节点的称呼；</span><br><span class="line">- Client： 请求客户端；</span><br><span class="line">- Candidate	候选人</span><br><span class="line">- Leader	领导者</span><br><span class="line">- Follower	跟随者</span><br><span class="line">- Term	选举任期，每次选举之后递增1</span><br><span class="line">- Index：索引号，Raft中通过Term和Index来定位数据。</span><br><span class="line">- Vote	选举投票(的ID)</span><br><span class="line">- Commit	提交</span><br><span class="line">- Propose	提议</span><br><span class="line">- WAL：预写式日志</span><br><span class="line">- SoftState：软状态，软状态易变且不需要保存在WAL日志中的状态数据，包括：集群leader、节点的当前状态</span><br><span class="line">- HardState：硬状态，与软状态相反，需要写入持久化存储中，包括：节点当前Term、Vote、Commit</span><br><span class="line">- ReadStates：用于读一致性的数据，后续会详细介绍</span><br><span class="line">- Entries：在向其他集群发送消息之前需要先写入持久化存储的日志数据</span><br><span class="line">- Snapshot：需要写入持久化存储中的快照数据</span><br><span class="line">- CommittedEntries：需要输入到状态机中的数据，这些数据之前已经被保存到持久化存储中了</span><br><span class="line">- Messages：在entries被写入持久化存储中以后，需要发送出去的数据</span><br></pre></td></tr></table></figure>
<p><code>peer</code>间通信消息类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- MsgHup            &#x2F;&#x2F; 不用于节点间通信，仅用于发送给本节点让本节点进行选举</span><br><span class="line">- MsgBeat           &#x2F;&#x2F; 心跳消息</span><br><span class="line">- MsgProp           &#x2F;&#x2F; raft库使用者提议（propose）数据</span><br><span class="line">- MsgApp            &#x2F;&#x2F; 用于leader向集群中其他节点同步数据的消息</span><br><span class="line">- MsgAppResp        &#x2F;&#x2F; 消息同步回复</span><br><span class="line">- MsgVote           &#x2F;&#x2F; 请求投票</span><br><span class="line">- MsgVoteResp       &#x2F;&#x2F; 投票反馈</span><br><span class="line">- MsgSnap           &#x2F;&#x2F; 用于leader向follower同步数据用的快照消息</span><br><span class="line">- MsgHeartbeat      &#x2F;&#x2F; 心跳消息</span><br><span class="line">- MsgHeartbeatResp  &#x2F;&#x2F; 心跳回复消息</span><br><span class="line">- MsgTransferLeader &#x2F;&#x2F; 转移主节点</span><br><span class="line">- MsgReadIndex      &#x2F;&#x2F; 用于线性一致性读</span><br><span class="line">- MsgReadIndexResp  </span><br><span class="line">- MsgPreVote        &#x2F;&#x2F; 请求预先投票</span><br><span class="line">- MsgPreVoteResp</span><br></pre></td></tr></table></figure>

<p><code>Etcd</code>整体架构图如下：<br><img src="/media/15518040419086.jpg" alt=""><br>下面将简单介绍下：</p>
<ol>
<li><code>etcd</code>面向<code>client</code>和<code>peer</code>节点开放<code>http</code>服务以及<code>grpc</code>服务，对于像<code>watch</code>机制就是基于<code>grpc</code>的<code>stream</code>通信模式实现的；</li>
<li><code>EtcdServer</code>是<code>etcd</code>上层结构体，其负责对外提供服务，且负责应用层的实现，比如操作应用层存储器，管理<code>leassor</code>、<code>watch</code>；</li>
<li><code>raftNode</code>负责上层与<code>raft</code>层的衔接。其负责将应用的需求传递到<code>raft</code>中进行处理（通过<code>Step</code>函数）、在消息发送到其他节点前将消息保存到<code>WAL</code>中、调用传输器发送消息；</li>
<li><code>raft</code>是<code>raft</code>协议的承载者；</li>
<li><code>raftLog</code>用于存储状态机信息：<code>memoryStorge</code>保存稳定的记录，<code>unstable</code>保存不稳定的记录。</li>
</ol>
<h1 id="1-Etcd初始化流程解析"><a href="#1-Etcd初始化流程解析" class="headerlink" title="1. Etcd初始化流程解析"></a>1. Etcd初始化流程解析</h1><p><code>Etcd</code>的启动类为 父目录的<code>main.go</code>文件。其启动过程调用如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main.<span class="keyword">go</span></span><br><span class="line">|- etcdmain/main.<span class="keyword">go</span>(暂且忽略<span class="string">`gateway`</span>和<span class="string">`proxy`</span>模式启动)</span><br><span class="line">    |- checkSupportArch <span class="comment">// 检查是否是支持的处理器架构</span></span><br><span class="line">    |- startEtcdOrProxyV2 <span class="comment">// 解析参数并根据参数决定启动etcd节点还是按Proxy模式启动（这里按etcd节点形式启动）</span></span><br><span class="line">        |- 生成默认参数<span class="string">`newConfig()`</span>解析参数 <span class="string">`cfg.parse(os.Args[1:])`</span>解析命令行启动参数</span><br><span class="line">        |- startEtcd(&amp;cfg.ec)<span class="comment">// 启动过程最核心的地方</span></span><br></pre></td></tr></table></figure>
<p><code>startEtcd</code>中执行<code>etcd</code>启动的主要过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">embed.startEtcd(inCfg *Config)</span><br><span class="line">|- inCfg.Validate() <span class="comment">//校验配置，检查url是否是以ip地址开头的，否则报错终止流程</span></span><br><span class="line">|- configurePeerListeners(cfg) <span class="comment">// 根据配置初始化peerListener结构体（为`peer`服务的服务器配置）</span></span><br><span class="line">|- configureClientListeners(cfg) <span class="comment">// 根据配置初始化clientListener结构体，（为`client`服务的服务器配置）</span></span><br><span class="line">|- 通过判断是否有 <span class="string">`wal`</span>文件来判断是否已经有其他节点信息</span><br><span class="line">    |- cfg.PeerURLsMapAndToken(<span class="string">"etcd"</span>)方法，其用于解析出其他节点的信息。</span><br><span class="line">    |- etcd集群模式有三种启动方式，其具体实现即实现在其内部。（<span class="string">`后续我们将详细分析`</span>）</span><br><span class="line">|- etcdserver.NewServer(srvcfg) <span class="comment">// 执行etcdServer初始化</span></span><br><span class="line">|- e.Server.Start() <span class="comment">// 启动 etcdServer</span></span><br><span class="line">|- e.servePeers() <span class="comment">// 启动 监听etcd节点间请求的GRPC服务</span></span><br><span class="line">|- e.serveClients() <span class="comment">// 启动监听客户端请求的GRPC服务</span></span><br><span class="line">|- e.serveMetrics() <span class="comment">// 启动Metrics Http服务，供外部查询Metrics信息</span></span><br></pre></td></tr></table></figure>
<p>通过 <strong>cfg.PeerURLsMapAndToken(“etcd”)</strong> 逻辑，了解到<code>etcd</code>有三种方式来获取集群中其他节点信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> cfg.Durl != <span class="string">""</span>:<span class="comment">// etcd自发现模式：配置 “discovery”参数设置。这里没有真正获取集群所有节点。比较trick的作用，等后面来处理。</span></span><br><span class="line">	<span class="keyword">case</span> cfg.DNSCluster != <span class="string">""</span>:<span class="comment">// 通过DNS自发现模式，配置”discovery-srv“</span></span><br><span class="line">  <span class="keyword">default</span>:<span class="comment">// 默认的静态配置方式，通过参数 "initial-cluster"进行设置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>准备好创建<code>etcd</code>节点后开始初始化节点信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">etcdserver/NewServer(srvcfg)</span><br><span class="line">|- fileutil.TouchDirAll(cfg.DataDir) <span class="comment">//检查是否可以获取目录权限：DataDir:"集群名.etcd"</span></span><br><span class="line">|- fileutil.TouchDirAll(cfg.SnapDir()) <span class="comment">// 检查是佛偶可以获取快照目录权限 ”集群名.etcd/member/snap“</span></span><br><span class="line">|- snap.New(cfg.Logger, cfg.SnapDir()) <span class="comment">//创建快照管理器</span></span><br><span class="line">|- be := openBackend(cfg) <span class="comment">// 创建数据库后端，其底层使用boltDB存储数据，然后在其之上进行了一次封装：包括批量提交事务。（关于存储的内容，我们后面讲单独讲解）</span></span><br><span class="line">|- rafthttp.NewRoundTripper(cfg.PeerTLSInfo, cfg.peerDialTimeout()) <span class="comment">// 创建一个RoundTripper，其作用是封装一个具有执行一次http事务，为一个http request获取response的对象</span></span><br></pre></td></tr></table></figure>
<p>初始化快照管理器和数据库后端后，就会根据一系列条件来决定怎样启动节点：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> !haveWAL &amp;&amp; !cfg.NewCluster:<span class="comment">// 非新集群且也没有WAL文件</span></span><br><span class="line">	<span class="comment">// 首先进行一些校验工作：比如判断本地集群成员列表是否与远程其他节点的成本列表配置是否相同</span></span><br><span class="line">	<span class="comment">// 判断集群每个节点的版本是否兼容</span></span><br><span class="line">	id, n, s, w = startNode(cfg, cl, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">case</span> !haveWAL &amp;&amp; cfg.NewCluster: <span class="comment">// 新集群，且没有WAL文件</span></span><br><span class="line">	<span class="comment">// 此处就是接着 PeerURLsMapAndToken的处理，如果配置`Discovery`参数，etcd则进行自发现流程 `v2discovery.JoinCluster`</span></span><br><span class="line">	id, n, s, w = startNode(cfg, cl, cl.MemberIDs())</span><br><span class="line">	<span class="keyword">case</span> haveWAL:                  <span class="comment">// 非新集群，且有WAL文件</span></span><br><span class="line">	<span class="comment">// 首先读取快照文件</span></span><br><span class="line">	<span class="comment">// 从快照文件中恢复数据库后端</span></span><br><span class="line">	snapshot, err = ss.Load()</span><br><span class="line">	<span class="comment">// 调用restartNode方法重启节点</span></span><br><span class="line">	id, cl, n, s, w = restartNode(cfg, snapshot)</span><br><span class="line">	<span class="comment">// 其再从wal内进一步恢复内容</span></span><br><span class="line">	<span class="keyword">default</span>:   <span class="comment">//异常情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建完<code>raft.Node</code>并绑定相应<strong>raft</strong>后，继续初始化:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">|- stats.NewServerStats <span class="comment">// 初始化统计计数</span></span><br><span class="line">|- stats.NewLeaderStats</span><br><span class="line">|- heartbeat := time.Duration(cfg.TickMs) * time.Millisecond <span class="comment">// 初始化心跳参数</span></span><br><span class="line">|- 创建 <span class="string">`EtcdServer`</span>：同时创建 <span class="string">`RaftNode`</span>、初始化ID生成器</span><br><span class="line">    |- newRaftNode  </span><br><span class="line">|- lease.NewLessor <span class="comment">//创建或恢复租约管理器</span></span><br><span class="line">|- srv.kv = mvcc.New(srv.getLogger(), srv.be, srv.lessor, &amp;srv.consistIndex) <span class="comment">// 创建KV存储器，其封装了backend、TreeIndex、Lessor，另外其内部也运行着 Watch 机制。（后续独立章节详细解析）</span></span><br><span class="line">|- srv.applyV3Base = srv.newApplierV3Backend() <span class="comment">// 创建 ApplierV3 接口实现，其用于处理v3 raft消息，为应用层的操作。</span></span><br><span class="line">|- restoreAlarms <span class="comment">// 恢复报警，如要是节点存储的报警：如空间不足、崩溃时替换`applyV3`做配置限制或拒绝请求</span></span><br><span class="line">|- tr := &amp;rafthttp.Transport&#123;...&#125; <span class="comment">// 创建Transporter，其用于向其他节点发送raft消息，并从其他节点获取raft消息。</span></span><br><span class="line">|- 每个remotes执行：tr.AddRemote(m.ID, m.PeerURLs) <span class="comment">// 初始化与每个Learner的通信</span></span><br><span class="line">|- 每个Members执行：tr.AddPeer(m.ID, m.PeerURLs) <span class="comment">// 初始化与每个Member节点的通信</span></span><br></pre></td></tr></table></figure>
<p>下面来看<code>raftNode</code>的详细创建过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">newRaftNode(</span><br><span class="line">	raftNodeConfig&#123;</span><br><span class="line">		Node:        n,</span><br><span class="line">		heartbeat:   heartbeat,</span><br><span class="line">		raftStorage: s,</span><br><span class="line">		storage:     NewStorage(w, ss),</span><br><span class="line">	&#125;,</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newRaftNode</span><span class="params">(cfg raftNodeConfig)</span> *<span class="title">raftNode</span></span> &#123;</span><br><span class="line">	r := &amp;raftNode&#123;</span><br><span class="line">		lg:             cfg.lg,</span><br><span class="line">		tickMu:         <span class="built_in">new</span>(sync.Mutex),</span><br><span class="line">		raftNodeConfig: cfg,</span><br><span class="line">		td:         contention.NewTimeoutDetector(<span class="number">2</span> * cfg.heartbeat),</span><br><span class="line">		readStateC: <span class="built_in">make</span>(<span class="keyword">chan</span> raft.ReadState, <span class="number">1</span>),</span><br><span class="line">		msgSnapC:   <span class="built_in">make</span>(<span class="keyword">chan</span> raftpb.Message, maxInFlightMsgSnap),</span><br><span class="line">		applyc:     <span class="built_in">make</span>(<span class="keyword">chan</span> apply),</span><br><span class="line">		stopped:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		done:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 开始心跳 Ticker</span></span><br><span class="line">	r.ticker = time.NewTicker(r.heartbeat)</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出<code>raftNode</code>和<code>raft.node</code>之间的关系。通过<code>raftNode</code>可以直接访问<code>raft.node</code>的所有公有方法。</p>
<p>回到 <code>startNode</code> 方法，我们以新集群且没有<code>WAL</code>文件的场景来了解下<code>startNode</code>的处理过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">etcdserver/raft.<span class="keyword">go</span>/startNode</span><br><span class="line">|- wal.Create() <span class="comment">// 创建 WAL文件</span></span><br><span class="line">|- raft.NewMemoryStorage()  <span class="comment">// 创建raft的数据存储器，这里为内存储存</span></span><br><span class="line">|- n = raft/node.<span class="keyword">go</span>/StartNode(c, peers) <span class="comment">// 开始节点</span></span><br><span class="line">    |- r := newRaft(c) <span class="comment">// 为当前节点创建raft对象</span></span><br><span class="line">    |- r.becomeFollower(<span class="number">1</span>, None) <span class="comment">//初始化当前节点成为 follower角色</span></span><br><span class="line">    |- 对每个节点，追加一条<span class="string">`ConfChangeAddNode`</span>配置更改记录到 raftLog中</span><br><span class="line">    |- r.raftLog.committed = r.raftLog.lastIndex() <span class="comment">// 更新raftLog的提交索引</span></span><br><span class="line">    |-  <span class="keyword">for</span> each peer r.addNode(peer.ID) <span class="comment">//为每个peer在Raft中创建一个Progress结构体（没有创建时，若创建了则设置状态）来，来保存该peer的数据复制状态</span></span><br><span class="line">    |- 创建一个raft/node节点 <span class="comment">// 创建node结构体，初始化各种通道</span></span><br><span class="line">    |- 异步执行 node.run(r *raft)方法<span class="comment">// 其内部主要执行事项包括：轮训raft内需要周知其他节点的信息进行发送，监听node的各种通道（请求和响应）作相应处理，和任务超时通知通道</span></span><br></pre></td></tr></table></figure>
<p>下面我们来详细了解下<strong>newRaft</strong>的内容：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">newRaft(c *Config) *raft</span><br><span class="line">|- c.validate() <span class="comment">// 相关参数的校验，比如选举超时时间设置必须大于心跳超时时间设置</span></span><br><span class="line">|- raftlog := newLogWithSize(c.Storage, c.Logger, c.MaxCommittedSizePerReady) <span class="comment">// 创建raftLog结构体，其用于保存raft状态机信息，比如当前节点事务提交的最大log位置、已经应用到应用的最大索引位置、所有未提交不稳定的记录</span></span><br><span class="line">|- <span class="string">`创建raft结构体`</span></span><br><span class="line">|- 对于每个决策节点 <span class="string">`peers`</span>，设置复制初始<span class="string">`Next`</span>位置、复制滑动串口器</span><br><span class="line">|- 对于非决策节点 <span class="string">`learnerPrs`</span>，也进行初始化</span><br><span class="line">|- r.becomeFollower(r.Term, None) <span class="comment">// 将自身设置为 Follower角色，对于一个刚启动的节点，这里Term为0</span></span><br><span class="line">|-</span><br></pre></td></tr></table></figure>
<p>接下来，再来看 <code>becomeFollower</code> 方法，其设置了 <strong>step</strong> 方法和 <strong>tick</strong> 方法、设置了 <code>raft</code>所在任期以及<code>raft</code>的角色状态。我们都知道<code>raft</code>协议中共有三个角色<code>Follower</code>、<code>Candidates</code>、<code>Leader</code>。<code>etcd</code>中通过不同角色设置不同的<code>step</code>来区分开每个角色的处理逻辑，设置不同<code>tick</code>方法来设置超时任务（对于<code>Follower</code>角色，其超时后会发起新一轮选举，而对于<code>Leader</code>角色，则广播一次心跳消息… ）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *raft)</span> <span class="title">becomeFollower</span><span class="params">(term <span class="keyword">uint64</span>, lead <span class="keyword">uint64</span>)</span></span> &#123;</span><br><span class="line">	r.step = stepFollower</span><br><span class="line">	r.reset(term)</span><br><span class="line">	r.tick = r.tickElection</span><br><span class="line">	r.lead = lead</span><br><span class="line">	r.state = StateFollower</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *raft)</span> <span class="title">becomeCandidate</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r.step = stepCandidate</span><br><span class="line">	r.reset(r.Term + <span class="number">1</span>)</span><br><span class="line">	r.tick = r.tickElection</span><br><span class="line">	r.Vote = r.id</span><br><span class="line">	r.state = StateCandidate</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *raft)</span> <span class="title">becomeLeader</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r.step = stepLeader</span><br><span class="line">	r.reset(r.Term)</span><br><span class="line">	r.tick = r.tickHeartbeat</span><br><span class="line">	r.lead = r.id</span><br><span class="line">	r.state = StateLeader</span><br><span class="line">	r.prs[r.id].becomeReplicate()</span><br><span class="line">	r.pendingConfIndex = r.raftLog.lastIndex()</span><br><span class="line">	emptyEnt := pb.Entry&#123;Data: <span class="literal">nil</span>&#125;</span><br><span class="line">	r.reduceUncommittedSize([]pb.Entry&#123;emptyEnt&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，就完成了 <strong>EtcdServer</strong>的创建。</p>
<p>接下来，再来看<code>EtcdServer</code>的开始方法<code>Start</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EtcdServer/Start</span><br><span class="line">    s.start() <span class="comment">// 启动</span></span><br><span class="line">	s.goAttach(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; s.adjustTicks() &#125;) <span class="comment">// 调整频率，启动时加快选举</span></span><br><span class="line">	s.goAttach(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; s.publish(s.Cfg.ReqTimeout()) &#125;) <span class="comment">// 发布节点属性信息，以遍其他节点可查询</span></span><br><span class="line">	s.goAttach(s.purgeFile) <span class="comment">// 启动异步任务做文件的合并操作：db文件\snap文件\WAL文件</span></span><br><span class="line">	s.goAttach(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; monitorFileDescriptor(s.getLogger(), s.stopping) &#125;) <span class="comment">// 监控文件句柄数不能超过系统限制的80%</span></span><br><span class="line">	s.goAttach(s.monitorVersions)</span><br><span class="line">	s.goAttach(s.linearizableReadLoop) <span class="comment">// 线性一致性读异步任务（后续详细讲解）</span></span><br><span class="line">	s.goAttach(s.monitorKVHash)</span><br></pre></td></tr></table></figure>
<p><code>EtcdServer.start()</code>方法，首先进行一系列通道的初始化，然后异步执行<code>EtcdServer.run()</code>方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EtcdServer.run</span><br><span class="line">|- sched := schedule.NewFIFOScheduler() <span class="comment">//首先创建一个先进先出的异步调度器</span></span><br><span class="line">|- rh := &amp;raftReadyHandler&#123;...&#125; <span class="comment">// 创建一个raftReadHanlder用于处理一些节点信息操作的回调。</span></span><br><span class="line">|- s.raftNode.start(rh) <span class="comment">// 启动raftNode的异步处理流程</span></span><br><span class="line">|- 开启循环，监听 raftNode的 applyC通道 以及租约过期通道 <span class="string">`s.lessor.expiredC`</span>。</span><br><span class="line">    |- 对于 <span class="string">`applyC`</span>，当从其中获取消息时，通过先进先出异步调度器顺序执行 applyAll方法</span><br><span class="line">    |- 对于</span><br></pre></td></tr></table></figure>
<p>展开 <code>raftNode.start(rh)</code>的逻辑如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-r.ticker.C: <span class="comment">// 监听超时通知通道</span></span><br><span class="line">		r.tick()</span><br><span class="line">	<span class="keyword">case</span> rd := &lt;-r.Ready(): <span class="comment">// 监听 raft.node的readyC通道，其为需要发送给其他节点或广播的消息</span></span><br><span class="line">	<span class="comment">// 根据消息更新自身状态</span></span><br><span class="line">	<span class="comment">// 然后应用到状态机中，最后发送给其他节点（非主节点时）或广播给其他节点（主节点）</span></span><br><span class="line">		<span class="keyword">if</span> rd.SoftState != <span class="literal">nil</span> &#123;</span><br><span class="line">		  <span class="comment">// 判断是否需要更新主节点信息</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(rd.ReadStates) != <span class="number">0</span> &#123;</span><br><span class="line">		  <span class="comment">// 对于线性一致性读，进行通知回调</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		notifyc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">      <span class="comment">// 通过rh来更新提交索引号</span></span><br><span class="line">		updateCommittedIndex(&amp;ap, rh)</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> r.applyc &lt;- ap:</span><br><span class="line">		<span class="keyword">case</span> &lt;-r.stopped:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> islead &#123;</span><br><span class="line">			r.transport.Send(r.processMessages(rd.Messages))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := r.storage.Save(rd.HardState, rd.Entries); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		r.raftStorage.Append(rd.Entries)</span><br><span class="line">		<span class="keyword">if</span> !islead &#123;</span><br><span class="line">			msgs := r.processMessages(rd.Messages)</span><br><span class="line">	       <span class="comment">// ...</span></span><br><span class="line">			r.transport.Send(msgs)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			notifyc &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		r.Advance()</span><br><span class="line">	<span class="keyword">case</span> &lt;-r.stopped:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>完成<code>etcdServer</code>的启动后，开始<code>http/grpc</code>服务对外提供服务（<code>peer</code>间的服务以及对<code>client</code>开放的服务）。<br>我们以<code>servePeers()</code>来讲解启动服务过程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">servePeers()</span><br><span class="line">|- etcdhttp.NewPeerHandler <span class="comment">//创建 `http.Handler`，用于处理 节点间 以`raft`、`raft/`、`/leases`、`/leases/internal`为前缀的http请求</span></span><br><span class="line">|- 对于每个 <span class="string">`e.Peers`</span>：执行以下操作</span><br><span class="line">    |- gs := v3rpc.Server(e.Server, peerTLScfg) <span class="comment">// 创建grpcServer，然后注册服务描述信息，如kv、watch、lease、cluster、auth、maintenance。</span></span><br><span class="line">    |- m := cmux.New(p.Listener) <span class="comment">// 创建连接多路转接器，用于转发连接到不同的服务里去处理，其工作原理后续讲解</span></span><br><span class="line">    |- <span class="keyword">go</span> gs.Serve(m.Match(cmux.HTTP2())) <span class="comment">// 筛选出http2的链接，并对其服务</span></span><br><span class="line">    |- <span class="keyword">go</span> srv.Serve(m.Match(cmux.Any())) <span class="comment">//对于剩下的连接，用http服务进行处理</span></span><br><span class="line">|- 对每个 <span class="string">`e.Peers`</span>.serve() 启动监听服务</span><br></pre></td></tr></table></figure>
<p>当新连接到达时，处理流程如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cMux.Server()</span><br><span class="line">|- c, err := m.root.Accept() <span class="comment">// 通过最原始的方式获取到达的连接</span></span><br><span class="line">|- m.serve(c, m.donec, &amp;wg) <span class="comment">// 执行serve进行分发</span></span><br><span class="line">    |- <span class="keyword">for</span> _, sl := <span class="keyword">range</span> m.sls &#123;<span class="comment">// sl包装了 其自身的匹配器列表，和转发通道</span></span><br><span class="line">		<span class="keyword">for</span> _, s := <span class="keyword">range</span> sl.ss &#123;<span class="comment">// s为通过cMux.Match方法创建的匹配器</span></span><br><span class="line">			matched := s(muc.Conn, muc.startSniffing())</span><br><span class="line">			<span class="keyword">if</span> matched &#123; <span class="comment">// 若该连接匹配上了，则将该连接通过连接发送到sl的连接接收通道里</span></span><br><span class="line">				<span class="comment">//...</span></span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> sl.l.connc &lt;- muc:</span><br><span class="line">				<span class="keyword">case</span> &lt;-donec:</span><br><span class="line">					_ = c.Close()</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>到此整个初始化过程就完成了。其后开始进行选举，那么选举是哪里出发的呢？<br>回到创建<code>raftNode</code>的地方 <code>r.ticker = time.NewTicker(r.heartbeat)</code> 开启了ticker。当时间到达时，tickder.C中得到通知。而其正在被 <code>raftNode</code>的<code>start</code>方法中的循环监听着。进一步就触发了<code>raftNoe.tick()</code>方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">raftNoe.tick()</span><br><span class="line">|- node.Tick()方法， 之前介绍过 raftNode与node之间的关系</span><br><span class="line">    |- n.tickc &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; 通知 node.tickc通道</span><br><span class="line">    |- node的run循环中监听此通道，进一步调用 <span class="string">`raft.tick()`</span>方法。此方法在 <span class="string">`becomeFollower`</span>时设置成了 <span class="string">`tickElection`</span></span><br><span class="line">    |- r.Step(pb.Message&#123;From: r.id, Type: pb.MsgHup&#125;) <span class="comment">// 到此开始发起选举</span></span><br><span class="line">    |- r.campaign(campaignElection) <span class="comment">// 开始角逐 主节点角色</span></span><br><span class="line">        |- r.becomeCandidate <span class="comment">// 更改节点角色为 候选者</span></span><br><span class="line">            |- r.step = stepCandidate...</span><br><span class="line">        |- r.send(pb.Message&#123;Term: term, To: id, Type: voteMsg, Index: rL.lastIndex, LogTerm: r.raftLog.lastTerm(), Context: ctx&#125;) <span class="comment">// 对每个节点发送 `pb.MsgVote` 消息 携带本节点的任期，索引</span></span><br></pre></td></tr></table></figure>
<p>当其他接收到该节点的投票请求时：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">peer.<span class="keyword">go</span>/startPeer(<span class="number">180</span>L)</span><br><span class="line">|- etcdServer.Pocess <span class="comment">// 转发到ectdServer进行处理</span></span><br><span class="line">    |- node.Step <span class="comment">// 调用 raftNode，并间接调用 raft.node</span></span><br><span class="line">        |- node.stepWithWaitOption</span><br><span class="line">            |- raft.Step</span><br><span class="line">                |- 首先进行判断是否可投票（是否已经投给了这个需要投票的人|| 没投票，且没有主|| 消息的任期比本节点大）</span><br><span class="line">                |- 判断是否要投票给请求投票的节点（请求节点任期比本节点大，或者任期相等时索引Id是否比本节点大）</span><br><span class="line">                |- 上面条件都满足时，返回<span class="string">`MsgVoteResp`</span>消息，告诉请求者，其同意投票给它</span><br><span class="line">                |- 但上述条件不满足时，则返回 拒绝消息给请求者</span><br></pre></td></tr></table></figure>

<p>当节点收到 其他的投票反馈消息时，最终会调用 <code>raft.go/stepCandidate</code>方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// poll方法传进去本消息的投票，返回已经有多少赞成票</span></span><br><span class="line">gr := r.poll(m.From, m.Type, !m.Reject)</span><br><span class="line"><span class="keyword">switch</span> r.quorum() &#123;<span class="comment">// 当达到quorum个时，进行角色转变</span></span><br><span class="line"><span class="keyword">case</span> gr:</span><br><span class="line">	<span class="keyword">if</span> r.state == StatePreCandidate &#123;</span><br><span class="line">		r.campaign(campaignElection)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	   <span class="comment">// 转换为主节点</span></span><br><span class="line">		r.becomeLeader()</span><br><span class="line">		<span class="comment">// 广播消息</span></span><br><span class="line">		r.bcastAppend()</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="built_in">len</span>(r.votes) - gr:</span><br><span class="line">	r.becomeFollower(r.Term, None)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的逻辑，可以看出，当投票数达到quorum数时，转变角色为主节点。同时向所有其他节点广播本节点状态以及记录信息（MsgApp），其他节点接收到此消息后，自动转变为 follower角色，整个集群初始化完成。</p>
<p>对于<code>etcd</code>的选举，还需要说明的是，<code>etcd</code>为了某些网络分区的问题了设置<code>PreVote</code>流程（只需要启动节点的时候 设置 <code>pre-vote</code> 参数）。即在进行真正的选举之前 先进行<code>PreVote</code>得到大多数节点同意选举之后才进行真正的选举。可以解决如下问题：</p>
<ul>
<li>对于网络分区的节点，在重新加入集群的时候不会中断集群；（因为获取不了大部分节点的许可，索引其<code>Term</code>无法增大，所以赢不了选举主节点）。</li>
</ul>
<p>到此，<strong>etcd</strong>的启动到建立集群、完成选举的整个过程就介绍完了。</p>
<p>附加图：<br>下图为 <code>EtcdServer</code>、<code>raftNode</code>、<code>raft.node</code>、<code>raft</code>间的联系。<br><img src="/media/15512352647387.jpg" alt=""></p>
<p>最后补充说明下<code>etcd</code>的<code>proxy</code>模式：<br><code>etcd</code>可以通过命令<code>./etcd –proxy on  –listen-client-urls</code>的形式启动代理模式。代理模式下，它的作用是一个反向代理，接收客户端请求，然后转发到<code>etcd</code>集群。<br>代理模式有2种运行形式：<code>readwrite</code>和<code>readonly</code>，默认情况下为<code>readwrite</code>，即会将读写请求都进行转发，而<code>readonly</code>形式下，则只转发读请求，写请求将报<code>5xx</code>错误，</p>
<p><strong>IDEA</strong>中启动ETCD方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">debug方式运行三个终端程序 <span class="string">`etcd/main.go`</span> 并设置如下参数：</span><br><span class="line">--name infra1 --listen-client-urls http:<span class="comment">//127.0.0.1:2379 --advertise-client-urls http://127.0.0.1:2379 --listen-peer-urls http://127.0.0.1:12380 --initial-advertise-peer-urls http://127.0.0.1:12380 --initial-cluster-token etcd-cluster-1 --initial-cluster infra1=http://127.0.0.1:12380,infra2=http://127.0.0.1:22380,infra3=http://127.0.0.1:32380 --initial-cluster-state new --enable-pprof --logger=zap --log-outputs=stderr</span></span><br><span class="line">--name infra2 --listen-client-urls http:<span class="comment">//127.0.0.1:22379 --advertise-client-urls http://127.0.0.1:22379 --listen-peer-urls http://127.0.0.1:22380 --initial-advertise-peer-urls http://127.0.0.1:22380 --initial-cluster-token etcd-cluster-1 --initial-cluster infra1=http://127.0.0.1:12380,infra2=http://127.0.0.1:22380,infra3=http://127.0.0.1:32380 --initial-cluster-state new --enable-pprof --logger=zap --log-outputs=stderr</span></span><br><span class="line">--name infra3 --listen-client-urls http:<span class="comment">//127.0.0.1:32379 --advertise-client-urls http://127.0.0.1:32379 --listen-peer-urls http://127.0.0.1:32380 --initial-advertise-peer-urls http://127.0.0.1:32380 --initial-cluster-token etcd-cluster-1 --initial-cluster infra1=http://127.0.0.1:12380,infra2=http://127.0.0.1:22380,infra3=http://127.0.0.1:32380 --initial-cluster-state new --enable-pprof --logger=zap --log-outputs=stderr</span></span><br></pre></td></tr></table></figure>

<h1 id="3-数据存储"><a href="#3-数据存储" class="headerlink" title="3. 数据存储"></a>3. 数据存储</h1><p><code>Etcd</code>的存储部分，可以分两部分来讲解。一部分是其应用层的数据存储方式，另一部分是<code>raft</code>相关数据的存储。<code>Etcd</code>应用层的数据存储从<code>v3</code>版本开始就延用<code>boltDB</code>，其也是<code>CoreOS</code>的产品<a href="https://github.com/etcd-io/bbolt" target="_blank" rel="noopener">boltDB</a>。PS:本文主要聚焦于v3版本，对于v2版本不作解读。</p>
<p>下面将分别介绍这两部分内容：</p>
<h2 id="3-1-raft数据存储"><a href="#3-1-raft数据存储" class="headerlink" title="3.1 raft数据存储"></a>3.1 raft数据存储</h2><p>首先我们来介绍下<code>raft</code>相关的数据存储：<br><code>raft</code>中有两个比较重要的组件：</p>
<ul>
<li><code>raftLog</code>：用来保存状态机相关信息的，包括当前任期、索引号、不稳定记录项等；</li>
<li><code>WAL</code>：预写日志器，用于以顺序形式写入操作记录，以便故障时数据恢复；</li>
<li><code>Snapshot</code>：数据快照，一般用于启动时快速恢复数据。</li>
</ul>
<p>首先来看<code>raftLog</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> raftLog <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 包含所有稳定的记录 MemeoryStorge</span></span><br><span class="line">	storage Storage</span><br><span class="line"> <span class="comment">// 包含所有不稳定的记录</span></span><br><span class="line">	unstable unstable</span><br><span class="line"> <span class="comment">// 提交记录索引</span></span><br><span class="line">	committed <span class="keyword">uint64</span></span><br><span class="line"><span class="comment">// 应用记录索引</span></span><br><span class="line">	applied <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> MemoryStorage <span class="keyword">struct</span> &#123;</span><br><span class="line">	hardState pb.HardState</span><br><span class="line">	<span class="comment">// 快照信息（保存 v2版存储中的保存的数据快照、任期、索引、ConfState[集群节点信息]）。快照生成一般有个条件：距上次提交的次数大于`SnapshotCount`（默认10000）</span></span><br><span class="line">	snapshot  pb.Snapshot</span><br><span class="line">	ents []pb.Entry</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从名字也可以看出其用途</span></span><br><span class="line"><span class="keyword">type</span> unstable <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 快照信息，这里只会在节点加入集群，主节点向其发送`MsgSnap`消息的时候才会有</span></span><br><span class="line">	snapshot *pb.Snapshot</span><br><span class="line">	entries []pb.Entry</span><br><span class="line">	offset  <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图描述了数据从客户端请求到落地各个阶段与以前存储结构的关系：<br><img src="/media/15516348174091.jpg" alt=""></p>
<p>其中，8’、9、11 是涉及 <strong>I/O</strong> 的操作，其他均为内存操作。<br>对<code>WAL</code>的操作在每次写事务操作中都会存在，因此其是制约<code>etcd</code>写性能的一个重要因素。接下来，将重点介绍<code>WAL</code>的工作原理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WAL <span class="keyword">struct</span> &#123;</span><br><span class="line">	dir <span class="keyword">string</span>       <span class="comment">// WAL文件所在目录</span></span><br><span class="line">	dirFile *os.File <span class="comment">// 目录文件句柄</span></span><br><span class="line">	metadata []<span class="keyword">byte</span>  <span class="comment">// 元数据，记录在每个wal文件头</span></span><br><span class="line">	state    raftpb.HardState <span class="comment">// 硬状态（任期、索引号），记录在每个文件头</span></span><br><span class="line">	start     walpb.Snapshot <span class="comment">// snapshot to start reading</span></span><br><span class="line">	decoder   *decoder       <span class="comment">// 解码器</span></span><br><span class="line">	enti    <span class="keyword">uint64</span>   <span class="comment">// 保存到WAL的最大索引号</span></span><br><span class="line">	encoder *encoder <span class="comment">// 编码器</span></span><br><span class="line">	locks []*fileutil.LockedFile <span class="comment">// 文件锁</span></span><br><span class="line">	fp    *filePipeline    <span class="comment">// 文件创建工具，预先创建文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，来看其创建过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">wal.Create</span><br><span class="line">|- tmpdirpath := filepath.Clean(dirpath) + <span class="string">".tmp"</span></span><br><span class="line">|- os.RemoveAll(tmpdirpath)</span><br><span class="line">|-	fileutil.CreateDirAll(tmpdirpath)</span><br><span class="line">|- p := filepath.Join(tmpdirpath, walName(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">|- f, err := fileutil.LockFile(p, os.O_WRONLY|os.O_CREATE, fileutil.PrivateFileMode)</span><br><span class="line">|- f.Seek(<span class="number">0</span>, io.SeekEnd)</span><br><span class="line">|- fileutil.Preallocate(f.File, SegmentSizeBytes, <span class="literal">true</span>)  <span class="comment">// 预分配空间</span></span><br><span class="line">|- w := &amp;WAL&#123;</span><br><span class="line">    	lg:       lg,</span><br><span class="line">    	dir:      dirpath,</span><br><span class="line">    	metadata: metadata,</span><br><span class="line">    &#125;</span><br><span class="line">|- w.encoder, err = newFileEncoder(f.File, <span class="number">0</span>)	<span class="comment">// 编码器，编码器编码的同时会将结果写到文件中</span></span><br><span class="line">|- w.locks = <span class="built_in">append</span>(w.locks, f)</span><br><span class="line">|-	w.saveCrc(<span class="number">0</span>) w.encoder.encode(&amp;walpb.Record&#123;Type: metadataType, Data: metadata&#125;)<span class="comment">// 写文件头</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">|- w.SaveSnapshot(walpb.Snapshot&#123;&#125;)</span><br><span class="line">|- w.renameWAL(tmpdirpath)  <span class="comment">// 更改零时文件名称为waldir，创建FilePipeline（用于预先创建文件）</span></span><br><span class="line">|-pdir, perr := fileutil.OpenDir(filepath.Dir(w.dir))</span><br><span class="line">|- fileutil.Fsync(pdir)</span><br></pre></td></tr></table></figure>
<p>创建<code>WAL</code>时，会初始化编码器以及<code>FilePipeline</code>。下面再以其<code>Save</code>方法来介绍保存记录的过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">WAL.Save</span><br><span class="line">|- mustSync := raft.MustSync(st, w.state, <span class="built_in">len</span>(ents)) <span class="comment">// 判断是否需要文件同步，写入磁盘</span></span><br><span class="line">|- <span class="keyword">for</span> each ents: saveEntry</span><br><span class="line">    |- b := pbutil.MustMarshal(e) rec := &amp;walpb.Record&#123;Type: entryType, Data: b&#125;</span><br><span class="line">    |- w.encoder.encode(rec) <span class="comment">// 编码后写入文件</span></span><br><span class="line">|- w.saveState(&amp;st) <span class="comment">// 保存状态</span></span><br><span class="line">|- curOff, err := w.tail().Seek(<span class="number">0</span>, io.SeekCurrent)</span><br><span class="line">|- <span class="keyword">if</span> curOff &lt; SegmentSizeBytes &amp; mustSync w.sync() 如果文件还没大于SegmentSizeBytes，且需要同步，则进行文件同步</span><br><span class="line">|- 如果大于，则进行切割文件 <span class="string">`w.cut`</span></span><br><span class="line">    |- fpath := filepath.Join(w.dir, walName(w.seq()+<span class="number">1</span>, w.enti+<span class="number">1</span>))</span><br><span class="line">    |- newTail, err := w.fp.Open() <span class="comment">// 通过filePipeline获取一个新的零时文件</span></span><br><span class="line">    |- 进行初始化 w.encoder, err = newFileEncoder(w.tail().File, prevCrc) ...</span><br><span class="line">    |- os.Rename(newTail.Name(), fpath) <span class="comment">// 重命名</span></span><br><span class="line">    |- w.sync()</span><br></pre></td></tr></table></figure>
<p>随着记录的增加，<code>wal</code>文件会越来越多，入股不做处理的话会导致磁盘被占满。那么<code>etcd</code>是怎么做的呢？<br>其实是由两步构成的：</p>
<ol>
<li>当<code>etcd</code>每次进行执行快照的实时，会进行<code>wal.ReleaseLockTo(snap.Metadata.Index)</code>释放文件锁的操作。（释放快照对应索引号之前的所有WAL文件句柄）</li>
<li>之前在<code>EtcdServer</code>启动章节介绍过，其启动后会启动一个定时任务<code>purgeFile</code>。其会针对<code>snap.db</code>、<code>snap</code>、<code>wal</code>文件做30秒一次的<code>fileutil.PurgeFile</code>任务：<ol>
<li>任务带有参数 <code>MaxWalFiles</code>，获取指定<code>wal.dir</code>下所有文件，然后按文件名排序，从小到大进行遍历：尝试锁文件。如果成功，则进行删除，否则的话说明依然被<code>etcd</code>锁占用。</li>
</ol>
</li>
</ol>
<h2 id="3-2-应用数据存储"><a href="#3-2-应用数据存储" class="headerlink" title="3.2 应用数据存储"></a>3.2 应用数据存储</h2><p>在解析<code>etcd</code>应用层数据存储结构前，先来介绍下<code>etcd</code>的数据存储形式。<code>etcd</code>对数据的存储并不是直接存储<code>key-value</code>对，而是引入了一种带版本号<code>revision</code>的存储方式：以数据的<code>revison</code>为<code>key</code>，键值对为值。<br><code>revision</code>由两部分组成：<code>main-revision</code>.<code>sub-revision</code>。<code>main-revision</code>为事务ID，<code>sub-revision</code>为事务中一次操作ID。</p>
<p>举例来说：<br>系统刚启动后，在一个事务中执行<code>put ty dj \n put dj ty</code>两个操作，实际存储的是</p>
<ol>
<li>{1,0} key=ty val=dj</li>
<li>{1,1} key=dj val=ty</li>
</ol>
<p>紧接着执行第二次操作：<code>put ty dj90 \n put dj ty92</code>，那么存储中会追加如下信息：</p>
<ol>
<li>{2,0} key=ty val=dj90</li>
<li>{2,1} key=dj val=ty92</li>
</ol>
<p>而为了支持这种存储形式快速查询，<code>etcd</code>建立了<code>treeIndex</code>结构，用于建立<code>key</code>与<code>revision</code>间的关系。随之，通过<code>key</code>查询<code>val</code>的过程如下：<br><img src="/media/15516311446785.jpg" alt=""></p>
<p><strong>treeIndex</strong>是一个<code>b-ree</code>，其存储这<code>keyIndex</code>信息。<code>KeyIndex</code>的结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">key         []<span class="keyword">byte</span></span><br><span class="line">modified    revision <span class="comment">// 最后一次更改版本信息</span></span><br><span class="line">generations []generation <span class="comment">// 代：每一代记录着键值对从创建到删除的过程</span></span><br><span class="line">|- ver     <span class="keyword">int64</span> <span class="comment">// 存放了多少次修改</span></span><br><span class="line">	created revision <span class="comment">// 创建此generation的第一个版本</span></span><br><span class="line">	revs    []revision</span><br></pre></td></tr></table></figure>
<p><code>keyIndex</code>中，需要特别说明的是<code>generation</code>数据内部，保存的<code>revs</code>，如果最后一项为<code>tombstone</code>，则表示在这个代中被删除了。被<code>tombstone</code>的<code>generation</code>是可以被删除的。针对此，<code>keyIndex</code>有个专门的函数<code>compact</code>，<code>compact(n)</code>可以将主版本小于n的数据。</p>
<p>将完了其存储结构和存储格式，下面将从启动和执行一次操作两个流程来讲解其的工作原理。对<code>boltDB</code>不了解的读者建议先去了解下 <a href="https://github.com/etcd-io/bbolt" target="_blank" rel="noopener"><code>boltDB</code></a>、<a href="https://segmentfault.com/a/1190000010098668" target="_blank" rel="noopener"><code>boltDB学习</code></a>。</p>
<h3 id="3-2-1-启动过程"><a href="#3-2-1-启动过程" class="headerlink" title="3.2.1 启动过程"></a>3.2.1 启动过程</h3><p><code>etcd</code>应用层存储创建过程如下：<br>首先创建<code>backend</code>，其是对<code>boltDB</code>的封装，加入一些批量提交逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bepath := cfg.backendPath()</span><br><span class="line">beExist := fileutil.Exist(bepath)</span><br><span class="line">be := openBackend(cfg) <span class="comment">// 创建</span></span><br><span class="line">|- newBackend</span><br><span class="line">    |- bolt.Open(bcfg.Path, <span class="number">0600</span>, bopts)</span><br><span class="line">    |- b := &amp;backend&#123;</span><br><span class="line">		db: db,</span><br><span class="line">		batchInterval: bcfg.BatchInterval,</span><br><span class="line">		batchLimit:    bcfg.BatchLimit ...</span><br><span class="line">		&#125;</span><br><span class="line">	 |- b.run() <span class="comment">// 定时任务，批量周期进行提交</span></span><br><span class="line">	   |- t := time.NewTimer(b.batchInterval)</span><br><span class="line">	   |- <span class="keyword">select</span> &#123;</span><br><span class="line">    		<span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">    			b.batchTx.CommitAndStop()</span><br><span class="line">    			<span class="keyword">return</span></span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">if</span> b.batchTx.safePending() != <span class="number">0</span> &#123;</span><br><span class="line">    			b.batchTx.Commit()</span><br><span class="line">    		&#125;</span><br></pre></td></tr></table></figure>
<p>有了<code>backend</code>后，会再基于此作一层封装：<code>mvcc.New(srv.getLogger(), srv.be, srv.lessor, &amp;srv.consistIndex)</code>，其内部包含<code>watcher</code>处理机制：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mvcc.New</span><br><span class="line">|- s := &amp;watchableStore&#123;</span><br><span class="line">    store:    NewStore(lg, b, le, ig),</span><br><span class="line">    victimc:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>),</span><br><span class="line">    unsynced: newWatcherGroup(),</span><br><span class="line">    synced:   newWatcherGroup(),</span><br><span class="line">    &#125;</span><br><span class="line">|- s.store.ReadView = &amp;readView&#123;s&#125;</span><br><span class="line">	s.store.WriteView = &amp;writeView&#123;s&#125;</span><br><span class="line">	<span class="keyword">if</span> s.le != <span class="literal">nil</span> &#123;</span><br><span class="line">		s.le.SetRangeDeleter(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">lease</span>.<span class="title">TxnDelete</span></span> &#123; <span class="keyword">return</span> s.Write() &#125;)</span><br><span class="line">	&#125;    </span><br><span class="line">|- <span class="keyword">go</span> s.syncWatchersLoop() <span class="comment">// 用于watch机制的异步任务</span></span><br><span class="line">|- <span class="keyword">go</span> s.syncVictimsLoop()</span><br></pre></td></tr></table></figure>
<p>这里我们比较关注的是<code>NewStore</code>逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">mvcc.NewStore</span><br><span class="line">|- s := &amp;store&#123;</span><br><span class="line">		b:       b,</span><br><span class="line">		kvindex: newTreeIndex(lg), <span class="comment">// 创建 treeIndex</span></span><br><span class="line">		le: le,</span><br><span class="line">		currentRev:     <span class="number">1</span>, <span class="comment">// 最近一次事务的版次</span></span><br><span class="line">		compactMainRev: <span class="number">-1</span>,<span class="comment">//最近一次事务的主版次</span></span><br><span class="line">		bytesBuf8: <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">8</span>),</span><br><span class="line">		fifoSched: schedule.NewFIFOScheduler(),</span><br><span class="line">		stopc: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">	&#125;</span><br><span class="line">|- s.ReadView = &amp;readView&#123;s&#125;</span><br><span class="line">	s.WriteView = &amp;writeView&#123;s&#125;</span><br><span class="line">	<span class="keyword">if</span> s.le != <span class="literal">nil</span> &#123;</span><br><span class="line">		s.le.SetRangeDeleter(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">lease</span>.<span class="title">TxnDelete</span></span> &#123; <span class="keyword">return</span> s.Write() &#125;)</span><br><span class="line">	&#125;</span><br><span class="line">|- tx.UnsafeCreateBucket(keyBucketName) <span class="comment">// 创建bucket-"key"用来存储kv数据，</span></span><br><span class="line">|- tx.UnsafeCreateBucket(metaBucketName) <span class="comment">//创建Bucket-”meta“用来存储元数据</span></span><br><span class="line">|- s.restore() <span class="comment">// 恢复存储</span></span><br><span class="line"><span class="comment">// TreeIndex 是b树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTreeIndex</span><span class="params">(lg *zap.Logger)</span> <span class="title">index</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;treeIndex&#123;</span><br><span class="line">		tree: btree.New(<span class="number">32</span>),</span><br><span class="line">		lg:   lg,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">s.restore</span><br><span class="line">|- rkvc, revc := restoreIntoIndex(s.lg, s.kvindex)<span class="comment">// 构建tree-index方法，返回两个通道，用于向内传入数据</span></span><br><span class="line">|- <span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 分页提取key-val</span></span><br><span class="line">		keys, vals := tx.UnsafeRange(keyBucketName, min, max, <span class="keyword">int64</span>(restoreChunkKeys))</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(keys) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将key-val进行解码，然后传递给`rkvc`通道，在restoreIntoIndex中监听`rkvc`通道，进行构建`treeIndex`</span></span><br><span class="line">		restoreChunk(s.lg, rkvc, keys, vals, keyToLease)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(keys) &lt; restoreChunkKeys &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		newMin := bytesToRev(keys[<span class="built_in">len</span>(keys)<span class="number">-1</span>][:revBytesLen])</span><br><span class="line">		newMin.sub++</span><br><span class="line">		revToBytes(newMin, min)</span><br><span class="line">	&#125;</span><br><span class="line">|- ...</span><br></pre></td></tr></table></figure>
<p>由此就完成了<code>treeIndex</code>和<code>boltDB</code>的初始化。<br>最后，<code>etcd</code>又对<code>mvcc.watchableStore</code>进行了一次封装<code>srv.newApplierV3Backend()</code>，其用于衔接存储和<code>raft</code>消息请求。</p>
<h3 id="3-2-2-请求应用到存储"><a href="#3-2-2-请求应用到存储" class="headerlink" title="3.2.2 请求应用到存储"></a>3.2.2 请求应用到存储</h3><p><code>put ty dj</code>请求通过<code>raft</code>协议提交决策后，最终会调用到<code>applierV3backend.put</code>方法进行应用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">applierV3backend.put</span><br><span class="line">|- txn = a.s.KV().Write()</span><br><span class="line">|- txn.Put(p.Key, val, leaseID)</span><br><span class="line">    |- storeTxnWrite.put</span><br><span class="line">        |- rev := tw.beginRev + <span class="number">1</span></span><br><span class="line">        	c := rev</span><br><span class="line">        	|- _, created, ver, err := tw.s.kvindex.Get(key, rev) <span class="comment">// 如果key存在则获取</span></span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        		c = created.main</span><br><span class="line">        		oldLease = tw.s.le.GetLease(lease.LeaseItem&#123;Key: <span class="keyword">string</span>(key)&#125;)</span><br><span class="line">        	&#125;</span><br><span class="line">        	|- ibytes := newRevBytes()</span><br><span class="line">            |- idxRev := revision&#123;main: rev, sub: <span class="keyword">int64</span>(<span class="built_in">len</span>(tw.changes))&#125;</span><br><span class="line">            |- revToBytes(idxRev, ibytes)</span><br><span class="line">            |- ver = ver + <span class="number">1</span></span><br><span class="line">            |- kv := mvccpb.KeyValue&#123;</span><br><span class="line">            		Key:            key,</span><br><span class="line">            		Value:          value,</span><br><span class="line">            		CreateRevision: c,</span><br><span class="line">            		ModRevision:    rev,</span><br><span class="line">            		Version:        ver,</span><br><span class="line">            		Lease:          <span class="keyword">int64</span>(leaseID),</span><br><span class="line">            	&#125;</span><br><span class="line">            |- d, err := kv.Marshal()</span><br><span class="line">            |- 	tw.tx.UnsafeSeqPut(keyBucketName, ibytes, d) <span class="comment">// 存储到boltDB中，key为`revision`</span></span><br><span class="line">            |- tw.s.kvindex.Put(key, idxRev) <span class="comment">// 将key到 revision的映射存储到treeIndex中</span></span><br></pre></td></tr></table></figure>
<p>到此就完成了存储模块的讲解。</p>
<h1 id="2-网络通信"><a href="#2-网络通信" class="headerlink" title="2. 网络通信"></a>2. 网络通信</h1><p>在上一节，我们介绍了<code>etcd</code>集群的启动过程。在其中也简单介绍了会初始化与其他成员节点通信的连接，以及启动为其他成员节点提供服务的<code>GRPC</code>服务和<code>Http</code>服务以及启动服务客户端的服务。本章我们将详细介绍通信相关的实现。</p>
<h2 id="2-1-成员节点间通信（peer）"><a href="#2-1-成员节点间通信（peer）" class="headerlink" title="2.1 成员节点间通信（peer）"></a>2.1 成员节点间通信（peer）</h2><p>前一章节介绍了peer服务端启动过程。下面，我们来讲解下调用端是如何初始化以及如何调用的。<br>与成员节点间通信传输的初始化之前介绍过，是调用<code>Transport.AddPeer</code>方法。<br>前面我们介绍了<code>Transport</code>的作用：向成员节点发送raft消息，并从成员节点获取raft消息。下面将详细描述其作用。<br>首先来看其初始化和启动过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">tr := &amp;rafthttp.Transport&#123;</span><br><span class="line">	DialTimeout: cfg.peerDialTimeout(),</span><br><span class="line">	ID:          id,</span><br><span class="line">	URLs:        cfg.PeerURLs,</span><br><span class="line">	ClusterID:   cl.ID(),</span><br><span class="line">	Raft:        srv, <span class="comment">// EtcdServer</span></span><br><span class="line">	Snapshotter: ss,</span><br><span class="line">	ServerStats: sstats,</span><br><span class="line">	LeaderStats: lstats,</span><br><span class="line">	ErrorC:      srv.errorc,</span><br><span class="line">&#125;</span><br><span class="line">tr.Start()</span><br><span class="line">|- t.streamRt = newStreamRoundTripper(t.TLSInfo, t.DialTimeout) <span class="comment">// 其作用前面介绍过：可以执行事务性HTTP请求，给定请求获取结果</span></span><br><span class="line">|- t.pipelineRt = NewRoundTripper(t.TLSInfo, t.DialTimeout) <span class="comment">//</span></span><br><span class="line">|- t.remotes = <span class="built_in">make</span>(<span class="keyword">map</span>[types.ID]*remote) <span class="comment">// 初始化复制节点映射</span></span><br><span class="line">|- t.peers = <span class="built_in">make</span>(<span class="keyword">map</span>[types.ID]Peer) <span class="comment">// 初始化成员节点映射</span></span><br><span class="line">|- t.pipelineProber = probing.NewProber(t.pipelineRt) <span class="comment">// Prober的作用是探测，探测链路监控状态</span></span><br><span class="line">|- t.streamProber = probing.NewProber(t.streamRt)</span><br></pre></td></tr></table></figure>
<p>接下来，继续了解<code>AddPeer</code>实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Transport/AddPeer</span><br><span class="line">|- startPeer</span><br><span class="line">    |- picker := newURLPicker(urls) <span class="comment">// 其用于选取通信通道（负载均衡作用）</span></span><br><span class="line">    |- pipeline := &amp;pipeline&#123;...&#125; <span class="comment">// 创建pipeline，多通道发送消息。</span></span><br><span class="line">    |- pipeline.start() <span class="comment">// 开启多个异步任务，监听 msgC通道，进行数据发送</span></span><br><span class="line">    |- p := &amp;peer&#123;...&#125; <span class="comment">// 创建peer结构体，初始化其属性，如recev、propc通道、消息发送器 msgAppV2Writer、writer（StreamWriter）</span></span><br><span class="line">    |- <span class="keyword">go</span> <span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> mm := &lt;-p.recvc:  <span class="comment">//监听 recev通道发来的消息，并将其丢给 EtcdServer.`Process`方法处理</span></span><br><span class="line">				<span class="keyword">if</span> err := r.Process(ctx, mm)</span><br><span class="line">			&#125;</span><br><span class="line">    |- <span class="keyword">go</span> <span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> mm := &lt;-p.propc: <span class="comment">// 监听 propc 通道发来的消息，将其丢给...</span></span><br><span class="line">				<span class="keyword">if</span> err := r.Process(ctx, mm);</span><br><span class="line">		  &#125;</span><br><span class="line">    |-  初始化 <span class="string">`p.msgAppV2Reader`</span>、<span class="string">`p.msgAppReader`</span> 用于读取消息</span><br><span class="line">    |- p.msgAppV2Reader.start() <span class="comment">// 开启监听消息读取</span></span><br><span class="line">    |- p.msgAppReader.start()    </span><br><span class="line">|- addPeerToProber(t.Logger, t.pipelineProber, id.String(), us, RoundTripperNameSnapshot, rttSec) <span class="comment">// 将该节点添加到探测器中，进行定期探测状态</span></span><br><span class="line">|-	addPeerToProber(t.Logger, t.streamProber, id.String(), us, RoundTripperNameRaftMessage, rttSec)</span><br></pre></td></tr></table></figure>
<p>从上面的流程可以看出 <code>peer</code>使用stream模式通信方式。读写分别用不同的协程去监听处理。其中<code>streamWriter</code>负责消息发送，<code>streamReader</code>负责消息接收。见下面详情：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">w := &amp;streamWriter&#123;</span><br><span class="line">	peerID:  id,</span><br><span class="line">	status: status,</span><br><span class="line">	fs:     fs,</span><br><span class="line">	r:      r,</span><br><span class="line">	msgc:   <span class="built_in">make</span>(<span class="keyword">chan</span> raftpb.Message, streamBufSize),</span><br><span class="line">	connc:  <span class="built_in">make</span>(<span class="keyword">chan</span> *outgoingConn),</span><br><span class="line">	stopc:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">	done:   <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">&#125;</span><br><span class="line">w.run:</span><br><span class="line">|- <span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-heartbeatc:</span><br><span class="line">	<span class="comment">//发送心跳消息</span></span><br><span class="line">	<span class="keyword">case</span> m := &lt;-msgc:</span><br><span class="line">	<span class="comment">// 接收到需要发送的消息，进行编码并使用conn进行发送</span></span><br><span class="line">    <span class="keyword">case</span> conn := &lt;-cw.connc:</span><br><span class="line">    <span class="comment">// 监听附加上来的连接通道，进行初始化 编码器、Flusher等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>streamWriter</code>里比较关键的一点是，这里的<code>conn</code>从哪来？往<code>cw.connc</code>传递<code>conn</code>的只有<code>peer.attachOutgoingConn</code>方法。<br>而在上面初始化并启动<code>peer</code>的时候是没有发现调用这个方法的 ？？？哪是哪里进行执行的呢？通过 追踪<code>peer.attachOutgoingConn</code>的调用方，最终发现，其在<code>rafthhtp/http.go/ServeHTTP() L483</code>处调用。而这个方法会在客户端建立连接<strong>进行http服务调用</strong>的时候执行。所以，在这里调用 <code>peer.attachOutgoingConn</code> 的作用是复用<code>连接</code>。当我们分析完读处理过程后，再来整体看 <code>etcd</code>节点是怎么建立通信链路的。</p>
<p><code>StreamReader</code>的处理比<code>StreamWriter</code>的处理要简单一些。初始化完其属性后，调用<code>start</code>方法启动监听读请求过程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StreamReader/start</span><br><span class="line">|- run</span><br><span class="line">    |- rc, err := cr.dial(t) <span class="comment">// 进行拨号，建立起与peer之间的连接</span></span><br><span class="line">    |- err = cr.decodeLoop(rc, t) <span class="comment">// 获取返回结果，进行解码</span></span><br><span class="line">        |- <span class="keyword">for</span>&#123; m, err := dec.decode() <span class="comment">//循环解码</span></span><br><span class="line">        |- 如果 m 是<span class="string">`MsgProp`</span>类型，则将消息传递到 propc通道，否则到 recv通道</span><br></pre></td></tr></table></figure>
<p>这样每个peer之间的链路就建立了。回过头来，可以看出每对<code>peer</code>之间至少会有两条<code>connection</code>。且他们之间交互交错使用。</p>
<p>单<code>peer</code>往对方发送的消息，是通过 <strong>对方跟自己建立的连接</strong> 来发送的。</p>
<p>最后，我们通过单次请求响应过程，来介绍节点间的通信过程。</p>
<p>当要想集群其他成员节点发送消息时，最终会调用<code>peer.send</code>方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">peer.send</span><br><span class="line">|- writec, name := p.pick(m) <span class="comment">// 首先peer会根据m的类型来选择一个发送通道</span></span><br><span class="line">    |- isMsgSnap(m) <span class="keyword">return</span> p.pipeline.msgc, pipelineMsg <span class="comment">// 如果是快照消息，则通过pipeline.msgc来发送消息</span></span><br><span class="line">    |- isMsgApp(m) <span class="keyword">return</span> p.msgAppV2Writer.writec(),streamAppV2 <span class="comment">// 如果是MsgApp消息</span></span><br><span class="line">    |- 如果 p.writer.writec() 可用，<span class="keyword">return</span> p.writer.writec()</span><br><span class="line">    |- 备用 p.pipeline.msgc, pipelineMsg</span><br><span class="line">|- writec &lt;- m: <span class="comment">// 即发送数据到 写通道中，`StreamWriter` 中会监听此通道。</span></span><br><span class="line"></span><br><span class="line">StreamWriter.run</span><br><span class="line">|- <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> m := &lt;-msgc:</span><br><span class="line">     |- enc.encode(&amp;m)</span><br><span class="line">        |- binary.Write(enc.w, binary.BigEndian, <span class="keyword">uint64</span>(m.Size())) <span class="comment">// 对于 messageEncoder，首先发送字节长度</span></span><br><span class="line">        |- enc.w.Write(pbutil.MustMarshal(m)) <span class="comment">//再发送字节内容</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目标节点的 <strong>StreamReader</strong>（<code>p.msgAppReader</code>）接收到消息后，通过解析后传递到 <code>EtcdServer</code>(Process)，即完成单次通信；对于请求的响应，则通过对方的<code>peer</code>来发送给本节点，本节点的<code>StreamReader</code>来接受响应消息。</p>
<h2 id="2-2-客户端通信"><a href="#2-2-客户端通信" class="headerlink" title="2.2 客户端通信"></a>2.2 客户端通信</h2><p>对于客户端通信，因为是<code>GRPC</code>或者<code>HTTP</code>简单的请求响应方式，因此这里就不再介绍了。</p>
<h1 id="4-事务请求"><a href="#4-事务请求" class="headerlink" title="4. 事务请求"></a>4. 事务请求</h1><p>[TOC]</p>
<p>本节我们将讲述 <code>etcd</code>集群的事务请求处理过程。首先我们将以<code>put</code>操作为例来讲解一般性事务请求过程。其次，我们将介绍 <code>etcd</code>特有的线性一致性读请求过程。</p>
<h2 id="put-请求"><a href="#put-请求" class="headerlink" title="put 请求"></a>put 请求</h2><p>通过 <code>etcdctl put ty dj</code> 命令，向本地监听<code>2380</code>端口的节点发送 写请求。<br>该请求为<code>GRPC</code>请求，会中转到<code>quotaKVServer</code>进行处理。</p>
<h3 id="Leader接收请求，并广播消息"><a href="#Leader接收请求，并广播消息" class="headerlink" title="Leader接收请求，并广播消息"></a><code>Leader</code>接收请求，并广播消息</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">quotaKVServer.Put</span><br><span class="line">|- s.qa.check(ctx,r) <span class="comment">//检查是否满足quota,即是否有足够的内存，如果没有则忽略请求，并发报警</span></span><br><span class="line">|- EtcdServer.Put <span class="comment">// 调用EtcdServer进行写</span></span><br><span class="line">    |- s.raftRequest(ctx, pb.InternalRaftRequest&#123;Put: r&#125;) <span class="comment">// EtcdServer将请求进行包装成 `InternalRaftRequest`</span></span><br><span class="line">      并调用<span class="string">`raftRequest`</span>进行请求，并等待获取结果</span><br><span class="line">        |- s.processInternalRaftRequestOnce<span class="comment">// 最终会调用此方法  </span></span><br><span class="line">            |- <span class="keyword">if</span> ci &gt; ai+maxGapBetweenApplyAndCommitIndex <span class="comment">//首先检查apply索引和 commit索引是否相差太大，若太大则忽略请求（自我保护机制）</span></span><br><span class="line">            |- 生成请求头，并生成请求ID <span class="string">`s.reqIDGen.Next()`</span></span><br><span class="line">            |- r.Marshal() <span class="comment">// 对请求进行编码</span></span><br><span class="line">            |- ch := s.w.Register(id) <span class="comment">// 注册请求响应回调</span></span><br><span class="line">            |- err = s.r.Propose(cctx, data) <span class="comment">// 向 raftNode 发起提议，申请写入数据</span></span><br><span class="line">            |- <span class="keyword">select</span> &#123; <span class="comment">// 等待结果，或超时</span></span><br><span class="line">            	   <span class="keyword">case</span> x := &lt;-ch:</span><br><span class="line">            		  <span class="keyword">return</span> x.(*applyResult), <span class="literal">nil</span></span><br><span class="line">            		  <span class="keyword">case</span> timeout</span><br><span class="line">            	&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就进入了主要的处理流程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node.Propose</span><br><span class="line">|- n.stepWait(ctx, pb.Message&#123;Type: pb.MsgProp, Entries: []pb.Entry&#123;&#123;Data: data&#125;&#125;&#125;) <span class="comment">// 将请求包装成 `MsgProp`消息</span></span><br><span class="line">    |- n.stepWithWaitOption</span><br><span class="line">        |- pm := msgWithResult&#123;m: m&#125; <span class="comment">// 将消息再一次封装</span></span><br><span class="line">        |- 将消息传递给 通道<span class="string">`n.propc`</span></span><br></pre></td></tr></table></figure>
<p>可以看出 将请求两层封装之后传递给通道<code>n.propc</code>。<br>在<code>node</code>的循环中，其会监听<code>proc</code>通道，当有消息到来时：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">node.start | <span class="number">360</span>+L</span><br><span class="line">|- m.From = r.id <span class="comment">// 将自己的id设置到消息的Form字段里</span></span><br><span class="line">|- err := r.Step(m) <span class="comment">// 再交给raft处理</span></span><br><span class="line">    |- r.step(r, m) <span class="comment">//此处就会根据节点的角色不同进行不同处理，若本节点是Follower则会转交给Leader节点进行处理，然后再进行如上的流程。这里假设本节点是主节点 即 stepLeader方法</span></span><br><span class="line">        |- r.appendEntry(m.Entries...) <span class="comment">// 将该记录追加到`raftLog`中</span></span><br><span class="line">            |- r.increaseUncommittedSize(es) <span class="comment">// 校验是否超过上界</span></span><br><span class="line">            |- r.raftLog.<span class="built_in">append</span>(es...) <span class="comment">// 追加到日志中记录下来（unstable中）</span></span><br><span class="line">            |- r.getProgress(r.id).maybeUpdate(li) <span class="comment">//更新本节点的复制进度</span></span><br><span class="line">            |- r.maybeCommit() <span class="comment">//对于单节点，尝试更新一次 raftLog中的 commit索引。//大多数节点都到达的索引</span></span><br><span class="line">        |- r.bcastAppend()  <span class="comment">// 广播消息</span></span><br><span class="line">            |- 对于每个其他成员节点，都执行 <span class="string">`r.sendAppend(id)`</span></span><br><span class="line">                |- pr := r.getProgress(to) <span class="comment">//获取节点的复制进程</span></span><br><span class="line">                |- term, errt := r.raftLog.term(pr.Next - <span class="number">1</span>) <span class="comment">// p.Next为该节点下次复制的索引号</span></span><br><span class="line">                |- ents, erre := r.raftLog.entries(pr.Next, r.maxMsgSize) <span class="comment">// 获取需要复制给对方节点的记录</span></span><br><span class="line">                |- 叫这些信息都封装成<span class="string">`MsgApp`</span>消息，进行发送</span><br><span class="line">                    |- r.send(m)</span><br><span class="line">                        |- r.msgs = <span class="built_in">append</span>(r.msgs, m) <span class="comment">// 将消息追加到了r.msgs中</span></span><br></pre></td></tr></table></figure>
<p>当本节点将需要发送给每个成员节点的消息都放到<code>r.msgs</code>后，<code>node.run</code>会进入下一轮循环。此时：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">node.run</span><br><span class="line">|- rd = newReady(r, prevSoftSt, prevHardSt) <span class="comment">// 准备准备好发送的消息结构体 Ready</span></span><br><span class="line">    |- rd := Ready&#123;</span><br><span class="line">    		Entries:          r.raftLog.unstableEntries(),</span><br><span class="line">    		CommittedEntries: r.raftLog.nextEnts(),</span><br><span class="line">    		Messages:         r.msgs, <span class="comment">// 消息在此进行包装</span></span><br><span class="line">    	&#125;</span><br><span class="line">|- readyc = n.readyc    	</span><br><span class="line">|- <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> readyc &lt;- rd: <span class="comment">// 此处即将消息传递到 n.readyc通道中</span></span><br><span class="line">     <span class="comment">//完成传递后，会进行一些状态的更新</span></span><br><span class="line">     <span class="keyword">if</span> index := rd.appliedCursor(); index != <span class="number">0</span> &#123;</span><br><span class="line">			applyingToI = index <span class="comment">// 提交消息的最大索引号</span></span><br><span class="line">		&#125;</span><br><span class="line">     advancec = n.advancec <span class="comment">// 赋值后，待本次消息发送完成后，进入下次循环。（等待 `raftNode`的通知）</span></span><br><span class="line">     <span class="keyword">case</span> &lt;-advancec:</span><br><span class="line">        <span class="comment">// 得到通知后，即知道之前的已提交的消息都已经发送出去了可以应用了</span></span><br><span class="line">			<span class="keyword">if</span> applyingToI != <span class="number">0</span> &#123;</span><br><span class="line">				r.raftLog.appliedTo(applyingToI)</span><br><span class="line">				applyingToI = <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送到<code>n.readyc</code>通道中的消息，会被<code>raftNode</code>捕获：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> rd := &lt;-r.Ready():</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">			<span class="keyword">if</span> islead &#123; <span class="comment">// 发送消息给相应节点</span></span><br><span class="line">		      r.transport.Send(r.processMessages(rd.Messages))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">			r.Advance() <span class="comment">// 这里是通知 node.advancec 可以处理下一个循坏</span></span><br><span class="line">    <span class="comment">// ...   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是<code>Leader</code>角色接收到<code>Put</code>请求，然后自身进行处理，然后向 <code>Follower</code>发送<code>MsgApp</code>消息。</p>
<h3 id="Follower接收到Leader的广播，进行处理回复"><a href="#Follower接收到Leader的广播，进行处理回复" class="headerlink" title="Follower接收到Leader的广播，进行处理回复"></a><code>Follower</code>接收到<code>Leader</code>的广播，进行处理回复</h3><p>当<code>Follower</code>收到消息后，会执行<code>EtcdServer.Process</code>方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EtcdServer.Process</span><br><span class="line">|- node.Step</span><br><span class="line">    |- node.step</span><br><span class="line">        |- n.recvc &lt;- m <span class="comment">// 最终传递给node.recvc通道</span></span><br><span class="line">            |- raft.Step <span class="comment">// node监听node.recvc，接收到消息后调用 raft执行逻辑</span></span><br><span class="line">            |- stepFollower</span><br><span class="line">                |- r.handleAppendEntries(m) <span class="comment">//处理追加记录</span></span><br><span class="line">                    |- r.raftLog.maybeAppend(m.Index, m.LogTerm, m.Commit, m.Entries...) <span class="comment">// 尝试追加消息</span></span><br><span class="line">                        |- l.matchTerm(index, logTerm) <span class="comment">// 校验 term 和index信息是否跟本节点一致</span></span><br><span class="line">                        |- l.findConflict(ents) <span class="comment">//找出冲突的索引号</span></span><br><span class="line">                        |- l.<span class="built_in">append</span>(ents[ci-offset:]...) <span class="comment">// 追加记录到raftLog中(unstable中)</span></span><br><span class="line">                        |- l.commitTo(min(committed, lastnewi)) <span class="comment">// 更新 commitId</span></span><br><span class="line">                    |- r.send(pb.Message&#123;To: m.From, Type: pb.MsgAppResp, Index: mlastIndex&#125;) <span class="comment">// 向 Leader反馈 信息`MsgAppResp`和索引号</span></span><br><span class="line">                        |- r.msgs = <span class="built_in">append</span>(r.msgs, m) <span class="comment">// 将消息追加到了r.msgs中</span></span><br></pre></td></tr></table></figure>
<p>发送的消息最终被 <code>raftNode</code>接收:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> rd := &lt;-r.Ready():</span><br><span class="line">        notifyc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">			ap := apply&#123;</span><br><span class="line">				entries:  rd.CommittedEntries, <span class="comment">// raft中已经提交的消息，</span></span><br><span class="line">				snapshot: rd.Snapshot,</span><br><span class="line">				notifyc:  notifyc,</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 将Committed数据应用到</span></span><br><span class="line">			updateCommittedIndex(&amp;ap, rh) <span class="comment">// 更新 EtcdServer的CommitId</span></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> r.applyc &lt;- ap: <span class="comment">// 将应用信息传递到 raftNode.applyc通道中，其被EtcdServer所监听。后续详解</span></span><br><span class="line">			&#125;</span><br><span class="line">			r.storage.Save(rd.HardState, rd.Entries) <span class="comment">// 实际调用WAL的Save方法，将记录写入到文件中 // ... wal</span></span><br><span class="line">			r.raftStorage.Append(rd.Entries) <span class="comment">// 将消息追加到 MemoryStorage中  </span></span><br><span class="line">		   <span class="keyword">if</span> !islead &#123;</span><br><span class="line">		      notifyc &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		      r.transport.Send(msgs)</span><br><span class="line">		   &#125;</span><br><span class="line">			r.Advance() <span class="comment">// 这里是通知 node.advancec 可以处理下一个循坏</span></span><br><span class="line">    <span class="comment">// ...   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看<code>EtcdServer</code>接收到<code>apply</code>消息后的处理：<br>再来看 <code>EtcdServer</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">EtcdServer/<span class="number">1020</span>L+-</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> ap := &lt;-s.r.apply():</span><br><span class="line">		f := <span class="function"><span class="keyword">func</span><span class="params">(context.Context)</span></span> &#123; s.applyAll(&amp;ep, &amp;ap) &#125;</span><br><span class="line">		sched.Schedule(f) <span class="comment">// 顺序调用`s.appAll`方法</span></span><br><span class="line">		s.applySnapshot(ep, apply)</span><br><span class="line">	   s.applyEntries(ep, apply) <span class="comment">//这里是应用服务最重要的地方</span></span><br><span class="line">	   |- 首先筛选出需要应用到此<span class="string">`EtcdServer`</span>的记录</span><br><span class="line">	   |- s.apply(ents, &amp;ep.confState)<span class="comment">//然后将这些记录应用到 `EtcdServer`中</span></span><br><span class="line">	       |- 对于正常的记录（<span class="string">`EntryNormal`</span>类型）</span><br><span class="line">	           |- <span class="keyword">case</span> raftpb.EntryNormal:</span><br><span class="line">            		s.applyEntryNormal(&amp;e)</span><br><span class="line">            		  |- s.consistIndex.setConsistentIndex(e.Index)<span class="comment">// 设置一致性索引号</span></span><br><span class="line">            		  |- 解码消息 Unmarshal</span><br><span class="line">            		  |- ar = s.applyV3.Apply(&amp;raftReq) <span class="comment">// 应用到应用数据存储中</span></span><br><span class="line">            		  |- s.w.Trigger(id, ar) <span class="comment">// 回调，通知该记录对应的请求</span></span><br><span class="line">           		    s.setAppliedIndex(e.Index)</span><br><span class="line">           			s.setTerm(e.Term)</span><br><span class="line"></span><br><span class="line">    |- &lt;-apply.notifyc <span class="comment">// 接到raftNode的通知已经完成发送等操作</span></span><br><span class="line">    |- s.triggerSnapshot(ep) <span class="comment">// 检查是否有 SnapshotCount操作，如果有则进行快照</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结起来，<code>Follower</code>节点接收到<code>Leader</code>节点的<code>MsgApp</code>应用到其节点中，然后向反馈<code>Leader</code> <code>MsgAppResp</code>消息，并带上自己的最大记录号。</p>
<h3 id="Leader收到Follower的回复进行处理"><a href="#Leader收到Follower的回复进行处理" class="headerlink" title="Leader收到Follower的回复进行处理"></a><code>Leader</code>收到<code>Follower</code>的回复进行处理</h3><p><code>Leader</code>收到<code>MsgAppResp</code>消息后，经过层层传递到<code>stepLeader</code>方法中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|- pr := r.getProgress(m.From) <span class="comment">// 获取该节点的进度</span></span><br><span class="line">|- <span class="keyword">switch</span> m.Type &#123;</span><br><span class="line">	<span class="keyword">case</span> pb.MsgAppResp:</span><br><span class="line">	   pr.RecentActive = <span class="literal">true</span> <span class="comment">//设置该节点状态</span></span><br><span class="line">	   |- pr.maybeUpdate(m.Index) <span class="comment">//更新该节点在 主节点中的进度信息（已经复制到什么位置了）</span></span><br><span class="line">	   |- 根据该节点的状态进行相应操作</span><br><span class="line">	   |- <span class="keyword">if</span> r.maybeCommit() &#123; <span class="comment">// 判断是否可以提交</span></span><br><span class="line">			r.bcastAppend()  <span class="comment">// 若可以提交，则广播消息</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们先来看判断是否可以提交的逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">raft.maybeCommit</span><br><span class="line">mis := r.matchBuf[:<span class="built_in">len</span>(r.prs)]</span><br><span class="line">idx := <span class="number">0</span></span><br><span class="line"><span class="comment">// 首先将每个成员节点确认的同步消息索引号放入数组中</span></span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> r.prs &#123;</span><br><span class="line">	mis[idx] = p.Match</span><br><span class="line">	idx++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按索引号排序</span></span><br><span class="line">sort.Sort(mis)</span><br><span class="line"><span class="comment">// 获取 len(mis)-r.quorum()位的索引位置</span></span><br><span class="line">mci := mis[<span class="built_in">len</span>(mis)-r.quorum()]</span><br><span class="line"><span class="keyword">return</span> r.raftLog.maybeCommit(mci, r.Term) <span class="comment">//判断是否比raftLog中的CommitId大，若是则表示有数据可以提交</span></span><br><span class="line">    |- <span class="keyword">if</span> maxIndex &gt; l.committed &amp;&amp; l.zeroTermOnErrCompacted(l.term(maxIndex)) == term &#123;</span><br><span class="line">		l.commitTo(maxIndex) <span class="comment">// 更新commitId</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>r.bcastAppend()</code>的处理过程之前以及介绍过，其会构造一遍<code>Ready</code>数据结构，带上<code>CommitedEntries</code>提交的数据、其他节点未同步的<code>Entries</code>，传递给<code>raftNode</code>。<code>raftNode</code>接收到此消息后，会执行与上面分析的<code>Follower</code>的逻辑类似。</p>
<h2 id="线性一致性读"><a href="#线性一致性读" class="headerlink" title="线性一致性读"></a>线性一致性读</h2><p>线性一致性读和一般的读不通的时候，会在进行真正的读请求之前，先与其他节点进行一个check，查看当前集群主是否发生了变化。通过<code>etcdctl get ty</code>命令，向监听本地<code>2380</code>端口的节点发送<code>GRPC</code>请求，会被中转到<code>quotaKVServer</code>上。<br><code>get</code>请求在<code>etcdctl</code>中会被转换成<code>Range</code>请求。<code>quotaKVServer</code>最终会调用<code>EtcdServer.Range</code>方法。</p>
<h3 id="Leader节点收到请求后，广播心跳消息"><a href="#Leader节点收到请求后，广播心跳消息" class="headerlink" title="Leader节点收到请求后，广播心跳消息"></a><code>Leader</code>节点收到请求后，广播心跳消息</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">quotaKVServer</span><br><span class="line">|- kvServer.Range</span><br><span class="line">    |- EtcdServer.Range</span><br><span class="line">        |- <span class="keyword">if</span> !r.Serializable &#123; <span class="comment">//是否线性一致性</span></span><br><span class="line">    		err = s.linearizableReadNotify(ctx)</span><br><span class="line">    		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    		&#125;</span><br><span class="line">    		resp, err = s.applyV3Base.Range(<span class="literal">nil</span>, r)</span><br><span class="line">    	&#125;</span><br></pre></td></tr></table></figure>
<p>线性一致性读的主要逻辑体现在 <code>s.linearizableReadNotify</code>中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s.linearizableReadNotify  <span class="comment">// 线性读通知</span></span><br><span class="line">|- nc := s.readNotifier <span class="comment">// 用于通知读协程可以进行读操作</span></span><br><span class="line">|- <span class="keyword">select</span> &#123;</span><br><span class="line">	   <span class="keyword">case</span> s.readwaitc &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;: <span class="comment">//通知读等待通道</span></span><br><span class="line">	&#125;</span><br><span class="line">|- <span class="keyword">select</span> &#123;</span><br><span class="line">	   <span class="keyword">case</span> &lt;-nc.c: <span class="comment">// 等待读状态通知</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>EtcdServer</code>在启动的时候会启动<code>linearizableReadLoop</code>线性一致性读循环。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">linearizableReadLoop</span><br><span class="line">|- ctxToSend := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">8</span>)</span><br><span class="line">|- id1 := s.reqIDGen.Next()</span><br><span class="line">|- binary.BigEndian.PutUint64(ctxToSend, id1)</span><br><span class="line">|- <span class="keyword">for</span> ;; &#123;</span><br><span class="line">     <span class="keyword">select</span> &#123;</span><br><span class="line">    	<span class="keyword">case</span> &lt;-s.readwaitc: <span class="comment">// 当接收到线性一致性读请求后，循环就可以往下走</span></span><br><span class="line">    	&#125;</span><br><span class="line">    	nextnr := newNotifier() <span class="comment">// 创建新的读通知器，给下一个读请求使用</span></span><br><span class="line">    	nr := s.readNotifier</span><br><span class="line">		s.readNotifier = nextnr</span><br><span class="line">		err := s.r.ReadIndex(cctx, ctxToSend) <span class="comment">// 调用`node.ReadeIndex`发起读索引请求</span></span><br><span class="line">	   <span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> rs = &lt;-s.r.readStateC:</span><br><span class="line">			done = bytes.Equal(rs.RequestCtx, ctxToSend)</span><br><span class="line">		<span class="keyword">case</span> &lt;-leaderChangedNotifier:</span><br><span class="line">			nr.notify(ErrLeaderChanged)</span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(s.Cfg.ReqTimeout()):</span><br><span class="line">			nr.notify(ErrTimeout)</span><br><span class="line">			timeout = <span class="literal">true</span></span><br><span class="line">			slowReadIndex.Inc()</span><br><span class="line">		<span class="keyword">case</span> &lt;-s.stopping:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">|- nr.notify(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">node.ReadIndex</span><br><span class="line">|- n.step(ctx, pb.Message&#123;Type: pb.MsgReadIndex, Entries: []pb.Entry&#123;&#123;Data: rctx&#125;&#125;&#125;) <span class="comment">//</span></span><br><span class="line">    |- raft.Step</span><br><span class="line">        |- raft.stepLeader</span><br><span class="line">            |- <span class="keyword">if</span> r.raftLog.zeroTermOnErrCompacted(r.raftLog.term(r.raftLog.committed)) != r.Term &#123; <span class="comment">// 当本任期没有提交任何消息时，拒绝读</span></span><br><span class="line">    				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    			&#125;</span><br><span class="line">    			<span class="keyword">switch</span> r.readOnly.option &#123;</span><br><span class="line">    			<span class="keyword">case</span> <span class="string">`ReadOnlySafe`</span>:</span><br><span class="line">    				r.readOnly.addRequest(r.raftLog.committed, m) <span class="comment">// 将只读请求添加到`readyOnly`结构里。</span></span><br><span class="line">    				r.bcastHeartbeatWithCtx(m.Entries[<span class="number">0</span>].Data)<span class="comment">// 带上请求的ID，向所有成员节点发送心跳。</span></span><br><span class="line">    			<span class="keyword">case</span> <span class="string">`ReadOnlyLeaseBased`</span>:</span><br><span class="line">    				ri := r.raftLog.committed</span><br><span class="line">    				<span class="keyword">if</span> m.From == None || m.From == r.id &#123; <span class="comment">// from local member</span></span><br><span class="line">    					r.readStates = <span class="built_in">append</span>(r.readStates, ReadState&#123;Index: r.raftLog.committed, RequestCtx: m.Entries[<span class="number">0</span>].Data&#125;)</span><br><span class="line">    				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    					r.send(pb.Message&#123;To: m.From, Type: pb.MsgReadIndexResp, Index: ri, Entries: m.Entries&#125;)</span><br><span class="line">    				&#125;</span><br><span class="line">    			&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Follower接收到Leader的心跳请求，并返回"><a href="#Follower接收到Leader的心跳请求，并返回" class="headerlink" title="Follower接收到Leader的心跳请求，并返回"></a><code>Follower</code>接收到<code>Leader</code>的心跳请求，并返回</h3><p><code>Follower</code>接收到<code>Leader</code>的心跳请求，最终会调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r.raftLog.commitTo(m.Commit)</span><br><span class="line">r.send(pb.Message&#123;To: m.From, Type: pb.MsgHeartbeatResp, Context: m.Context&#125;) <span class="comment">// 发送心跳回复</span></span><br></pre></td></tr></table></figure>
<h3 id="Leader接收Follower回复，通知客户端请求继续"><a href="#Leader接收Follower回复，通知客户端请求继续" class="headerlink" title="Leader接收Follower回复，通知客户端请求继续"></a><code>Leader</code>接收<code>Follower</code>回复，通知客户端请求继续</h3><p><code>Leader</code>节点接收到<code>Follower</code>的回复后，最终会调用如下逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">pr.RecentActive = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> pr.Match &lt; r.raftLog.lastIndex() &#123; <span class="comment">// 当Follower节点有数据没复制时，进行发送</span></span><br><span class="line">	r.sendAppend(m.From)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 操作readyOnly接收Ack，并返回有多少节点已经确认</span></span><br><span class="line">ackCount := r.readOnly.recvAck(m)</span><br><span class="line"><span class="keyword">if</span> ackCount &lt; r.quorum() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回有哪些请求可以继续往下走</span></span><br><span class="line">rss := r.readOnly.advance(m)</span><br><span class="line"><span class="keyword">for</span> _, rs := <span class="keyword">range</span> rss &#123;</span><br><span class="line">	req := rs.req</span><br><span class="line">	<span class="keyword">if</span> req.From == None || req.From == r.id &#123;</span><br><span class="line">	   <span class="comment">// 将可以读的请求信息放到 r.readStates中，等后面提交到 ReadyC结构体，向上提交进行处理。</span></span><br><span class="line">		r.readStates = <span class="built_in">append</span>(r.readStates, ReadState&#123;Index: rs.index, RequestCtx: req.Entries[<span class="number">0</span>].Data&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ro *readOnly)</span> <span class="title">recvAck</span><span class="params">(m pb.Message)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	rs, ok := ro.pendingReadIndex[<span class="keyword">string</span>(m.Context)]  <span class="comment">// m.Context 为请求ID</span></span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	rs.acks[m.From] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(rs.acks) + <span class="number">1</span> <span class="comment">// 返回已经有多少Follower进行了应答</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回容许读的请求ID列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ro *readOnly)</span> <span class="title">advance</span><span class="params">(m pb.Message)</span> []*<span class="title">readIndexStatus</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		i     <span class="keyword">int</span></span><br><span class="line">		found <span class="keyword">bool</span></span><br><span class="line">	)</span><br><span class="line">	ctx := <span class="keyword">string</span>(m.Context)</span><br><span class="line">	rss := []*readIndexStatus&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, okctx := <span class="keyword">range</span> ro.readIndexQueue &#123;</span><br><span class="line">		i++</span><br><span class="line">		rs, ok := ro.pendingReadIndex[okctx]</span><br><span class="line">		rss = <span class="built_in">append</span>(rss, rs)</span><br><span class="line">		<span class="comment">// 找到匹配的读，以及可以触发读的请求队列。</span></span><br><span class="line">		<span class="keyword">if</span> okctx == ctx &#123;</span><br><span class="line">			found = <span class="literal">true</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> found &#123;</span><br><span class="line">		ro.readIndexQueue = ro.readIndexQueue[i:]<span class="comment">// 剔除之前的读请求</span></span><br><span class="line">		<span class="keyword">for</span> _, rs := <span class="keyword">range</span> rss &#123;</span><br><span class="line">			<span class="built_in">delete</span>(ro.pendingReadIndex, <span class="keyword">string</span>(rs.req.Entries[<span class="number">0</span>].Data))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> rss</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>raftNode</code>结构体接收到<code>Ready</code>消息时，会检查是否有<code>ReadStates</code>，然后对其进行处理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(rd.ReadStates) != <span class="number">0</span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> r.readStateC &lt;- rd.ReadStates[<span class="built_in">len</span>(rd.ReadStates)<span class="number">-1</span>]:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再回到<code>linearizableReadLoop</code>中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> rs = &lt;-s.r.readStateC:</span><br><span class="line">	<span class="keyword">case</span> &lt;-leaderChangedNotifier:</span><br><span class="line">		nr.notify(ErrLeaderChanged)</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(s.Cfg.ReqTimeout()):</span><br><span class="line">		nr.notify(ErrTimeout)</span><br><span class="line">	<span class="keyword">case</span> &lt;-s.stopping:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">nr.notify(<span class="literal">nil</span>) <span class="comment">// 通知客户端可以进行查询请求</span></span><br></pre></td></tr></table></figure>
<p>到此就完成线性一致性读的全过程。</p>
<h1 id="5-TTL-amp-Lease-实现"><a href="#5-TTL-amp-Lease-实现" class="headerlink" title="5. TTL &amp; Lease 实现"></a>5. TTL &amp; Lease 实现</h1><p><code>etcd</code>中用来实现<code>TTL</code>的机制叫<code>Lease</code>，<code>Lease</code>可以用来绑定多个key。<code>Lease</code>的主要用法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> etcdctl lease grant <span class="number">1900</span> <span class="comment">// 申请一个租约，返回租约ID</span></span><br><span class="line"> - lease <span class="number">326969472</span>b0c5d05 granted with TTL(<span class="number">1900</span>s)</span><br><span class="line"><span class="number">2.</span> etcdctl lease revoke <span class="number">326969472</span>b0c5d05 <span class="comment">// 取消租约</span></span><br><span class="line">- lease <span class="number">326969472</span>b0c5d05 revoked</span><br><span class="line"><span class="number">3.</span> etcdctl lease timetolive  <span class="number">326969472</span>b0c5d08 <span class="comment">// 查询剩余多长时间</span></span><br><span class="line">- lease <span class="number">326969472</span>b0c5d08 granted with TTL(<span class="number">190</span>s), remaining(<span class="number">182</span>s)</span><br><span class="line"><span class="number">4.</span> etcdctl lease keep-alive <span class="number">326969472</span>b0c5d05 <span class="comment">// 到期续约</span></span><br><span class="line">- lease <span class="number">326969472</span>b0c5d05 keepalived with TTL(<span class="number">1900</span>)</span><br><span class="line"><span class="number">5.</span> etcdctl lease keep-alive --once=<span class="literal">true</span> <span class="number">326969472</span>b0c5d0c <span class="comment">// 单次续约</span></span><br><span class="line">- lease <span class="number">326969472</span>b0c5d0c keepalived with TTL(<span class="number">200</span>)</span><br></pre></td></tr></table></figure>
<p>下面将解析其工作原理，首先将介绍其初始化过程，然后介绍创建、以及绑定<code>key</code>以及过期的操作。</p>
<h2 id="5-1-初始化"><a href="#5-1-初始化" class="headerlink" title="5.1 初始化"></a>5.1 初始化</h2><p><code>Lessor</code>是在创建<code>EtcdServer</code>是进行初始化的：<code>lease.NewLessor(...)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">minTTL := time.Duration((<span class="number">3</span>*cfg.ElectionTicks)/<span class="number">2</span>) * heartbeat <span class="comment">// 首先计算最小TTL单元，为选举跳数的1.5倍*心跳间隔时间</span></span><br><span class="line">srv.lessor = lease.NewLessor(log, srv.be, lease.LessorConfig&#123;MinLeaseTTL: <span class="keyword">int64</span>(math.Ceil(minTTL.Seconds())), CheckpointInterval: cfg.LeaseCheckpointInterval&#125;) <span class="comment">// 创建`Lessor`，传入最小租约TTL时间，和租约周期性检测时间间隔。租约的TTL时间最小不能小于最小租约时间（秒级别）</span></span><br><span class="line">|- <span class="keyword">if</span> checkpointInterval == <span class="number">0</span> &#123; <span class="comment">// 设置默认时间为5分钟</span></span><br><span class="line">		checkpointInterval = <span class="number">5</span> * time.Minute</span><br><span class="line">	&#125;</span><br><span class="line">|- l := &amp;lessor&#123;</span><br><span class="line">		leaseMap:            <span class="built_in">make</span>(<span class="keyword">map</span>[LeaseID]*Lease),</span><br><span class="line">		itemMap:             <span class="built_in">make</span>(<span class="keyword">map</span>[LeaseItem]LeaseID),</span><br><span class="line">		leaseHeap:           <span class="built_in">make</span>(LeaseQueue, <span class="number">0</span>), <span class="comment">// 根据租约到期时间排序的小根堆</span></span><br><span class="line">		leaseCheckpointHeap: <span class="built_in">make</span>(LeaseQueue, <span class="number">0</span>),</span><br><span class="line">		b:                   b,</span><br><span class="line">		minLeaseTTL:         cfg.MinLeaseTTL,</span><br><span class="line">		checkpointInterval:  checkpointInterval,</span><br><span class="line">		expiredC: <span class="built_in">make</span>(<span class="keyword">chan</span> []*Lease, <span class="number">16</span>),</span><br><span class="line">		stopC:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		doneC:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">	&#125;</span><br><span class="line">|- l.initAndRecover() <span class="comment">// 初始化并恢复</span></span><br><span class="line">    |- vs := tx.UnsafeRange(leaseBucketName...) <span class="comment">// 从`boltDB`中，查询`lease` bucket中所有数组</span></span><br><span class="line">    |- 对于每个记录，解码<span class="string">`lpb.Unmarshal(vs[i])`</span>，然后插进<span class="string">`le.leaseMap`</span>中</span><br><span class="line">        |- le.leaseMap[ID] = &amp;Lease&#123;</span><br><span class="line">			ID:  ID,</span><br><span class="line">			ttl: lpb.TTL,</span><br><span class="line">			itemSet: <span class="built_in">make</span>(<span class="keyword">map</span>[LeaseItem]<span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">			expiry:  forever,</span><br><span class="line">			revokec: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		&#125;</span><br><span class="line">	|- heap.Init(&amp;le.leaseHeap) <span class="comment">//初始化堆</span></span><br><span class="line">	|- heap.Init(&amp;le.leaseCheckpointHeap)</span><br><span class="line">|- <span class="keyword">go</span> l.runLoop() <span class="comment">// 运行500ms一次的任务，撤销过期的租约，周期性调度`Lease`检测。后续将详细分析其执行过程</span></span><br></pre></td></tr></table></figure>
<p>完成了<code>Lessor</code>的初始化后，随着进入<code>kvstore.restore</code>的初始化，会伴随着恢复<code>key</code>与<code>lease</code>的映射关系。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当从 bucket<span class="string">`key`</span>中获取所有key-val后，执行<span class="string">`restoreChunk`</span>方法</span><br><span class="line">restoreChunk</span><br><span class="line">|- 其会检测kv是否带<span class="string">`Lease`</span>，若有则加入到<span class="string">`keyToLease`</span><span class="keyword">map</span>中</span><br><span class="line">|- 对<span class="string">`keyToLease`</span><span class="keyword">map</span>中的每个entry</span><br><span class="line">    |- s.le.Attach(lid, []lease.LeaseItem&#123;&#123;Key: key&#125;&#125;)</span><br><span class="line">        |- 将<span class="string">`key`</span>绑定到<span class="string">`lease`</span>中，并建立<span class="string">`key`</span>到<span class="string">`lease`</span>的映射</span><br></pre></td></tr></table></figure>
<h2 id="5-2-Lease创建"><a href="#5-2-Lease创建" class="headerlink" title="5.2 Lease创建"></a>5.2 <code>Lease</code>创建</h2><p>创建<code>Lease</code>，最终会调用<code>EtcdServer.LeaseGrant</code>方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">EtcdServer.LeaseGrant</span><br><span class="line">|- r.ID = <span class="keyword">int64</span>(s.reqIDGen.Next() &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">63</span>) - <span class="number">1</span>)) <span class="comment">// 首先创建 leaseId</span></span><br><span class="line">|- s.raftRequestOnce 发起提议</span><br><span class="line">    |- 当集群确认提交此提议后，会进行应用。调用<span class="string">`lessor.Grant`</span></span><br><span class="line">        |- l := &amp;Lease&#123; <span class="comment">// 创建 Lease</span></span><br><span class="line">        		ID:      id,</span><br><span class="line">        		ttl:     ttl,</span><br><span class="line">        		itemSet: <span class="built_in">make</span>(<span class="keyword">map</span>[LeaseItem]<span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">        		revokec: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">        	&#125;</span><br><span class="line">        |- <span class="keyword">if</span> l.ttl &lt; le.minLeaseTTL &#123; <span class="comment">// 保证租约ttl不小于`minLeaseTTL`</span></span><br><span class="line">        		l.ttl = le.minLeaseTTL</span><br><span class="line">        	&#125;</span><br><span class="line">        |- l.refresh(<span class="number">0</span>) <span class="comment">// 设置 `Lease`的 `expiry`时间</span></span><br><span class="line">        |- le.leaseMap[id] = l <span class="comment">// 放入 `leaseId`与`lease`的映射</span></span><br><span class="line">        |- item := &amp;LeaseWithTime&#123;id: l.ID, time: l.expiry.UnixNano()&#125; <span class="comment">// 过期时间戳、leaseId item</span></span><br><span class="line">        |- heap.Push(&amp;le.leaseHeap, item) <span class="comment">// 存入堆中</span></span><br><span class="line">        |- l.persistTo(le.b) <span class="comment">// 将lease信息存储 boltDB中</span></span><br><span class="line">        |- le.scheduleCheckpointIfNeeded(l)</span><br><span class="line">            |- <span class="keyword">if</span> lease.RemainingTTL() &gt; <span class="keyword">int64</span>(le.checkpointInterval.Seconds()) &#123; <span class="comment">// 若`lease`的剩余时间比`检测点间隔`大时，则存进`le.leaseCheckpointHeap`中</span></span><br><span class="line">                |- heap.Push(&amp;le.leaseCheckpointHeap, &amp;LeaseWithTime&#123;</span><br><span class="line">        			id:   lease.ID,</span><br><span class="line">        			time: time.Now().Add(le.checkpointInterval).UnixNano(),</span><br><span class="line">        		&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="5-3-Lease绑定key"><a href="#5-3-Lease绑定key" class="headerlink" title="5.3 Lease绑定key"></a>5.3 <code>Lease</code>绑定<code>key</code></h2><p>在<code>put</code>操作时通过添加参数<code>--lease=326969472b0c5d08</code>即将<code>key</code>绑定到<code>lease</code>上。直接定位<code>storeTxnWrite.put</code>方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">oldLease = tw.s.le.GetLease(lease.LeaseItem&#123;Key: <span class="keyword">string</span>(key)&#125;) <span class="comment">// 获取key之前绑定的`lease`</span></span><br><span class="line"><span class="keyword">if</span> oldLease != lease.NoLease &#123;</span><br><span class="line">    err = tw.s.le.Detach(oldLease, []lease.LeaseItem&#123;&#123;Key: <span class="keyword">string</span>(key)&#125;&#125;) <span class="comment">// 剔除`key`与老`lease`的映射关系</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> leaseID != lease.NoLease &#123;</span><br><span class="line">    err = tw.s.le.Attach(leaseID, []lease.LeaseItem&#123;&#123;Key: <span class="keyword">string</span>(key)&#125;&#125;)</span><br><span class="line">    |- <span class="keyword">for</span> _, it := <span class="keyword">range</span> items &#123;</span><br><span class="line">    		l.itemSet[it] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    		le.itemMap[it] = id</span><br><span class="line">    	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-4-Lease过期"><a href="#5-4-Lease过期" class="headerlink" title="5.4 Lease过期"></a>5.4 <code>Lease</code>过期</h2><p>上文中介绍过在初始化<code>Lease</code>后，会启动<code>lessor.runLoop</code>任务：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="comment">// 注销过期的租约</span></span><br><span class="line">	le.revokeExpiredLeases()</span><br><span class="line">	<span class="comment">// 检测调度的租约</span></span><br><span class="line">	le.checkpointScheduledLeases()</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="comment">// 500ms 一次</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(<span class="number">500</span> * time.Millisecond):</span><br><span class="line">	<span class="keyword">case</span> &lt;-le.stopC:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">le.revokeExpiredLeases</span><br><span class="line">|- revokeLimit := leaseRevokeRate / <span class="number">2</span> <span class="comment">// 限流</span></span><br><span class="line">|- ls = le.findExpiredLeases(revokeLimit) <span class="comment">// 查询出过期的租约</span></span><br><span class="line">|- <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> le.expiredC &lt;- ls:</span><br><span class="line">   &#125;</span><br><span class="line">|- <span class="string">`EtcdServer`</span> 会监听<span class="string">`lessor.expiredC`</span>通道：</span><br><span class="line">|- 异步串行执行：<span class="string">`s.LeaseRevoke(ctx, &amp;pb.LeaseRevokeRequest&#123;ID: int64(lid)&#125;)`</span></span><br><span class="line">    |- 提交Revoke提议，最后进行应用：</span><br><span class="line">        |- lessor.Revoke</span><br><span class="line">            |- keys := l.Keys()</span><br><span class="line">            	sort.StringSlice(keys).Sort()</span><br><span class="line">            	<span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123; <span class="comment">// 删除key</span></span><br><span class="line">            		txn.DeleteRange([]<span class="keyword">byte</span>(key), <span class="literal">nil</span>)</span><br><span class="line">            	&#125;</span><br><span class="line">            |- <span class="built_in">delete</span>(le.leaseMap, l.ID)</span><br><span class="line">            |- le.b.BatchTx().UnsafeDelete(leaseBucketName, int64ToBytes(<span class="keyword">int64</span>(l.ID))) <span class="comment">// 从`lease`bucket中删除租约</span></span><br></pre></td></tr></table></figure>

<h1 id="6-Watch机制"><a href="#6-Watch机制" class="headerlink" title="6. Watch机制"></a>6. Watch机制</h1><p><code>watch</code>用于监听指定<code>key</code>或指定<code>key</code>前缀的键值对的变动。其 <code>api</code> 如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">etcdctl watch --prefix[=<span class="literal">false</span>] <span class="comment">// 带前缀</span></span><br><span class="line">              --prev-kv[=<span class="literal">false</span>]<span class="comment">// 是否获取之前的key-val对</span></span><br><span class="line">              --rev=<span class="number">0</span> <span class="comment">// 开始监听的主Revision</span></span><br></pre></td></tr></table></figure>
<p>下面将详细解析其工作原理。首先将介绍其初始化过程，其次介绍创建<code>watch</code>过程以及相关键值对修改时的操作。</p>
<h2 id="6-1-初始化过程"><a href="#6-1-初始化过程" class="headerlink" title="6.1 初始化过程"></a>6.1 初始化过程</h2><p>在初始化存储的时候，提到了<code>newWatchableStore</code>方法，其对<code>boltDB</code>进行了一次封装。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s := &amp;watchableStore&#123;</span><br><span class="line">	store:    NewStore(lg, b, le, ig),</span><br><span class="line">	victimc:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>),</span><br><span class="line">	unsynced: newWatcherGroup(), <span class="comment">// 包含所有未同步的watchers，有事件发生需要进行同步</span></span><br><span class="line">	synced:   newWatcherGroup(), <span class="comment">// 包含与存储进程同步的所有同步了的watchers，map的key即为watcher监听的key。</span></span><br><span class="line">	stopc:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> s.syncWatchersLoop()<span class="comment">// 启动每100ms一次的同步未同步映射中的监听者</span></span><br><span class="line"><span class="keyword">go</span> s.syncVictimsLoop()<span class="comment">// 同步预先发送未成功的watchers</span></span><br></pre></td></tr></table></figure>
<p>首先来看下<code>WatcherGroup</code>的数据结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> watcherGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// key到监听此key的watcher集合</span></span><br><span class="line">	keyWatchers watcherSetByKey</span><br><span class="line"> <span class="comment">// 监听范围的监听者 (红黑树)</span></span><br><span class="line">	ranges adt.IntervalTree</span><br><span class="line">  <span class="comment">// watcher 集合</span></span><br><span class="line">	watchers watcherSet</span><br><span class="line">&#125;</span><br><span class="line">watchableStore.syncWatchers</span><br><span class="line">|- curRev := s.store.currentRev</span><br><span class="line">|- compactionRev := s.store.compactMainRev</span><br><span class="line">|- wg, minRev := s.unsynced.choose(maxWatchersPerSync, curRev, compactionRev) <span class="comment">// 从未同步的监听组中获取watcher集合</span></span><br><span class="line">    |- wg.chooseAll <span class="comment">// 选择所有watcher中最小`Revision`</span></span><br><span class="line">        |- <span class="keyword">for</span> w := <span class="keyword">range</span> wg.watchers &#123;</span><br><span class="line">            <span class="keyword">if</span> w.minRev &lt; compactRev &#123; <span class="comment">// 当小于当前压缩版本的时候直接做一次响应</span></span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">           			<span class="keyword">case</span> w.ch &lt;- WatchResponse&#123;WatchID: w.id, CompactRevision: compactRev&#125;:</span><br><span class="line">           				w.compacted = <span class="literal">true</span></span><br><span class="line">           				wg.<span class="built_in">delete</span>(w)</span><br><span class="line">           			<span class="keyword">default</span>:</span><br><span class="line">           				<span class="comment">// retry next time</span></span><br><span class="line">       			&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> minRev &gt; w.minRev &#123;</span><br><span class="line">    			minRev = w.minRev</span><br><span class="line">    		&#125;</span><br><span class="line">         &#125;</span><br><span class="line">    |- revs, vs := tx.UnsafeRange(keyBucketName, minBytes, maxBytes, <span class="number">0</span>) <span class="comment">// 查询大于revision的所有 key-val</span></span><br><span class="line">    |- evs = kvsToEvents(s.store.lg, wg, revs, vs) <span class="comment">// 转变成 事件</span></span><br><span class="line">        |- <span class="keyword">for</span> i, v := <span class="keyword">range</span> vals &#123;</span><br><span class="line">            |- kv.Unmarshal(v)</span><br><span class="line">            |- <span class="keyword">if</span> !wg.contains(<span class="keyword">string</span>(kv.Key)) &#123; <span class="comment">// 查询是否有监听此key的watcher</span></span><br><span class="line">       			<span class="keyword">continue</span></span><br><span class="line">       		 &#125;</span><br><span class="line">       		 |- ty := mvccpb.PUT</span><br><span class="line">        		<span class="keyword">if</span> isTombstone(revs[i]) &#123;</span><br><span class="line">        			ty = mvccpb.DELETE</span><br><span class="line">        			kv.ModRevision = bytesToRev(revs[i]).main</span><br><span class="line">        		&#125;</span><br><span class="line">       		 |- evs = <span class="built_in">append</span>(evs, mvccpb.Event&#123;Kv: &amp;kv, Type: ty&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        |- newWatcherBatch(wg, evs)<span class="comment">// 将变更事件与关注该事件的watcher建立映射 map[*watcher]*eventBatch</span></span><br><span class="line">        |- 对<span class="string">`WatcherBatch`</span>中的每一项作如下处理：</span><br><span class="line">            |- 如果一次性未发送完成，则设置下次发送的Rev <span class="string">`w.minRev = eb.moreRev`</span></span><br><span class="line">            |- <span class="keyword">if</span> w.send(WatchResponse&#123;WatchID: w.id, Events: eb.evs, Revision: curRev&#125;) &#123; <span class="comment">// 发送变更响应。将消息传递到`watcher.ch`中</span></span><br><span class="line">        		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        			<span class="keyword">if</span> victims == <span class="literal">nil</span> &#123;</span><br><span class="line">        				victims = <span class="built_in">make</span>(watcherBatch)</span><br><span class="line">        			&#125;</span><br><span class="line">        			w.victim = <span class="literal">true</span></span><br><span class="line">        		&#125;</span><br><span class="line">        	|- <span class="keyword">if</span> w.victim &#123; <span class="comment">// 若发送未成功，则将要发送的`WatcherBatch`存储到`victims`中</span></span><br><span class="line">        			victims[w] = eb</span><br><span class="line">        		&#125; <span class="keyword">else</span> &#123; <span class="comment">//发送成功的话，则</span></span><br><span class="line">        			<span class="keyword">if</span> eb.moreRev != <span class="number">0</span> &#123;</span><br><span class="line">        				<span class="keyword">continue</span></span><br><span class="line">        			&#125;</span><br><span class="line">        			s.synced.add(w)</span><br><span class="line">        		&#125;</span><br><span class="line">        	|- s.unsynced.<span class="built_in">delete</span>(w)</span><br><span class="line">   	|- s.addVictim(victims)</span><br></pre></td></tr></table></figure>
<p>总结整体流程如下：</p>
<ol>
<li>首先从未同步watcherGroup中获取最多<code>maxWatchersPerSync</code>个<code>watcher</code>对应的关注最小的<code>Revision</code>，并删除已经被压缩的<code>watcher</code>；</li>
<li>使用上面得到的最小<code>Revision</code>去获取所有<code>key-val</code>对；</li>
<li>对所有<code>key-val</code>对，去寻找关注其变化的<code>watcher</code>最终生成WactherBatch</li>
<li>发送给客户端，然后将watcher从<code>unsync WatcherGroup</code>中移动到<code>sync WatcherGroup</code>中。对于未发送完成的消息添加到<code>victims</code>中，在<code>syncVictimsLoop</code>中重试。</li>
</ol>
<p>接下来即系了解<code>syncVictimsLoop</code>的实现逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123; <span class="comment">// 循环执行moveVictims方法</span></span><br><span class="line">	<span class="keyword">for</span> s.moveVictims() != <span class="number">0</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	isEmpty := <span class="built_in">len</span>(s.victims) == <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> tickc &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line">	<span class="keyword">if</span> !isEmpty &#123;</span><br><span class="line">		tickc = time.After(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-tickc:</span><br><span class="line">	<span class="keyword">case</span> &lt;-s.victimc:</span><br><span class="line">	<span class="keyword">case</span> &lt;-s.stopc:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">s.moveVictims</span><br><span class="line">|- 对victims中每一项：</span><br><span class="line">    |- 首先尝试进行发送<span class="string">`w.send(WatchResponse&#123;WatchID: w.id, Events: eb.evs, Revision: rev&#125;)`</span>。不成功的话，则加到<span class="string">`newVictim`</span>中</span><br><span class="line">    |- 其后根据当前集群情况将其加入到<span class="string">`unsynced WatcherGroup`</span>中（w.minRev &lt;= curRev）或者<span class="string">`synced WatcherGroup`</span>中</span><br></pre></td></tr></table></figure>

<h2 id="6-2-创建watch"><a href="#6-2-创建watch" class="headerlink" title="6.2 创建watch"></a>6.2 创建<code>watch</code></h2><p>当通过客户端执行如下命令<code>etcdctl watch /ty/dj --prefix</code>命令时，客户端与服务端建立<code>grpc</code>双工通道进行交互，其最终会调用<code>watchServer.Watch</code>方法，在其中建立双工通道交互方式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sws := serverWatchStream&#123;</span><br><span class="line">	clusterID: ws.clusterID,</span><br><span class="line">	memberID:  ws.memberID,</span><br><span class="line">	maxRequestBytes: ws.maxRequestBytes,</span><br><span class="line">	sg:        ws.sg,</span><br><span class="line">	watchable: ws.watchable,</span><br><span class="line">	ag:        ws.ag,</span><br><span class="line">	gRPCStream:  stream,</span><br><span class="line">	watchStream: ws.watchable.NewWatchStream(),</span><br><span class="line">	ctrlStream: <span class="built_in">make</span>(<span class="keyword">chan</span> *pb.WatchResponse, ctrlStreamBufLen),</span><br><span class="line">	progress: <span class="built_in">make</span>(<span class="keyword">map</span>[mvcc.WatchID]<span class="keyword">bool</span>), <span class="comment">// 记录watcher是否需要发送精度</span></span><br><span class="line">	prevKV:   <span class="built_in">make</span>(<span class="keyword">map</span>[mvcc.WatchID]<span class="keyword">bool</span>), <span class="comment">// 是否需要查询历史值</span></span><br><span class="line">	fragment: <span class="built_in">make</span>(<span class="keyword">map</span>[mvcc.WatchID]<span class="keyword">bool</span>), <span class="comment">// 是否需要分片</span></span><br><span class="line">	closec: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> sws.sendLoop() <span class="comment">// 异步建立起发送消息的过程</span></span><br><span class="line"><span class="keyword">go</span> sws.recvLoop() <span class="comment">// 异步接收请求，并进行处理</span></span><br></pre></td></tr></table></figure>
<p>首先来看<code>sws.recvLoop</code>处理过程，通过<code>grpc</code>stream通道获取请求，然后调用<code>watchStream.Watch</code>方法创建<code>watch</code>，并注册到相应的<code>WatcherGroup</code>上。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ;;</span><br><span class="line">req, err := sws.gRPCStream.Recv() <span class="comment">// 接收请求</span></span><br><span class="line"><span class="keyword">switch</span> uv := req.RequestUnion.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *pb.WatchRequest_CreateRequest:</span><br><span class="line">	id, err := sws.watchStream.Watch(mvcc.WatchID(creq.WatchId), creq.Key, creq.RangeEnd, rev, filters...) <span class="comment">// 注册一个Watch</span></span><br><span class="line">    	|- watchableStore.watch</span><br><span class="line">    	   |- synced := startRev &gt; s.store.currentRev || startRev == <span class="number">0</span> <span class="comment">//查看需要同步</span></span><br><span class="line">    	   |- 如果不需要，则放入<span class="string">`synced WatcherGroup`</span>中，否则放入<span class="string">`unsynced WatcherGroup`</span></span><br></pre></td></tr></table></figure>

<p>再来看发送流程：<br>通过<code>watcher.send</code>发送变更消息的时候，实际上是传递到<code>watcher</code>的<code>ch</code>通道上，而这个通道则是<code>serverWatchStream</code>的发送通道：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> wresp, ok := &lt;-sws.watchStream.Chan():</span><br><span class="line">	evs := wresp.Events</span><br><span class="line">	events := <span class="built_in">make</span>([]*mvccpb.Event, <span class="built_in">len</span>(evs))</span><br><span class="line">	sws.mu.RLock()</span><br><span class="line">	needPrevKV := sws.prevKV[wresp.WatchID]</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> evs &#123;</span><br><span class="line">		events[i] = &amp;evs[i]</span><br><span class="line">		<span class="keyword">if</span> needPrevKV &#123; <span class="comment">// 对于需要查询历史版本的数据</span></span><br><span class="line">			opt := mvcc.RangeOptions&#123;Rev: evs[i].Kv.ModRevision - <span class="number">1</span>&#125;</span><br><span class="line">			r, err := sws.watchable.Range(evs[i].Kv.Key, <span class="literal">nil</span>, opt)</span><br><span class="line">			<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(r.KVs) != <span class="number">0</span> &#123;</span><br><span class="line">				events[i].PrevKv = &amp;(r.KVs[<span class="number">0</span>])</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//是否需要分割发送</span></span><br><span class="line">	fragmented, ok := sws.fragment[wresp.WatchID]</span><br><span class="line">	<span class="keyword">if</span> !fragmented &amp;&amp; !ok &#123; <span class="comment">//不需要是，则直接发送</span></span><br><span class="line">		serr = sws.gRPCStream.Send(wr)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		serr = sendFragments(wr, sws.maxRequestBytes, sws.gRPCStream.Send)</span><br><span class="line">	&#125;</span><br><span class="line">	sws.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(evs) &gt; <span class="number">0</span> &amp;&amp; sws.progress[wresp.WatchID] &#123;</span><br><span class="line">		<span class="comment">// elide next progress update if sent a key update</span></span><br><span class="line">		sws.progress[wresp.WatchID] = <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	sws.mu.Unlock()</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-3-键值对更改"><a href="#6-3-键值对更改" class="headerlink" title="6.3 键值对更改"></a>6.3 键值对更改</h2><p>建设有两个客户端A，B<br>A客户端先执行了操作<code>etcdctl watch /ty/dj</code>；B客户端随后执行了操作<code>etcdctl put /ty/dj hello</code>。那么在B执行该操作时<code>watcher</code>机制是如何work的？<br>对于<code>put</code>操作，会执行<code>storeTxnWrite.put</code>方法，会将更新的数据添加到 <code>tw.changes</code>中，最后会执行<code>watchableStoreTxnWrite.End</code>方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">changes := tw.Changes()</span><br><span class="line">rev := tw.Rev() + <span class="number">1</span></span><br><span class="line">evs := <span class="built_in">make</span>([]mvccpb.Event, <span class="built_in">len</span>(changes))</span><br><span class="line"><span class="keyword">for</span> i, change := <span class="keyword">range</span> changes &#123; <span class="comment">// 将变更转换为事件</span></span><br><span class="line">	evs[i].Kv = &amp;changes[i]</span><br><span class="line">	<span class="keyword">if</span> change.CreateRevision == <span class="number">0</span> &#123;</span><br><span class="line">		evs[i].Type = mvccpb.DELETE</span><br><span class="line">		evs[i].Kv.ModRevision = rev</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		evs[i].Type = mvccpb.PUT</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">tw.s.notify(rev, evs) <span class="comment">// 调用 watchableStore.notify方法</span></span><br><span class="line">|- <span class="keyword">for</span> w, eb := <span class="keyword">range</span> newWatcherBatch(&amp;s.synced, evs) &#123;</span><br><span class="line">		<span class="keyword">if</span> w.send(WatchResponse&#123;WatchID: w.id, Events: eb.evs, Revision: rev&#125;) &#123; <span class="comment">// 发送更新</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// move slow watcher to victims</span></span><br><span class="line">			w.minRev = rev + <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> victim == <span class="literal">nil</span> &#123;</span><br><span class="line">				victim = <span class="built_in">make</span>(watcherBatch)</span><br><span class="line">			&#125;</span><br><span class="line">			w.victim = <span class="literal">true</span></span><br><span class="line">			victim[w] = eb</span><br><span class="line">			s.synced.<span class="built_in">delete</span>(w)</span><br><span class="line">			slowWatcherGauge.Inc()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	s.addVictim(victim)</span><br></pre></td></tr></table></figure>
<p>总结过程如下：在进行<code>put</code>操作时会将变更添加到<code>changes</code>中。当<code>put</code>操作结束时，执行<code>watchableStoreTxnWrite.End</code>方法，转换成<code>newWatcherBatch</code>事件，然后调用<code>watchableStore.notify</code>方法进行发送更新。</p>
<h1 id="7-集群管理"><a href="#7-集群管理" class="headerlink" title="7. 集群管理"></a>7. 集群管理</h1><h2 id="7-1-集群间数据同步"><a href="#7-1-集群间数据同步" class="headerlink" title="7.1 集群间数据同步"></a>7.1 集群间数据同步</h2><h2 id="7-2-变更节点"><a href="#7-2-变更节点" class="headerlink" title="7.2 变更节点"></a>7.2 变更节点</h2><h3 id="7-2-1-新增节点"><a href="#7-2-1-新增节点" class="headerlink" title="7.2.1 新增节点"></a>7.2.1 新增节点</h3><h3 id="7-2-2-下线节点"><a href="#7-2-2-下线节点" class="headerlink" title="7.2.2 下线节点"></a>7.2.2 下线节点</h3><h2 id="7-3-节点宕机"><a href="#7-3-节点宕机" class="headerlink" title="7.3 节点宕机"></a>7.3 节点宕机</h2><h3 id="7-3-1-主节点宕机"><a href="#7-3-1-主节点宕机" class="headerlink" title="7.3.1 主节点宕机"></a>7.3.1 主节点宕机</h3><h3 id="7-3-2-follower节点宕机"><a href="#7-3-2-follower节点宕机" class="headerlink" title="7.3.2 follower节点宕机"></a>7.3.2 follower节点宕机</h3><h2 id="7-4-节点迁移、替换"><a href="#7-4-节点迁移、替换" class="headerlink" title="7.4 节点迁移、替换"></a>7.4 节点迁移、替换</h2>
      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>您的支持是我创作源源不断的动力</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="Zamperini 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.png" alt="Zamperini 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/etcd/" rel="tag"># etcd</a>
          
            <a href="/tags/apiserver/" rel="tag"># apiserver</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/25/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/etcd/8.etcd-%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86/" rel="next" title="ETCD 集群管理(is comming)">
                <i class="fa fa-chevron-left"></i> ETCD 集群管理(is comming)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/02/03/k8s/1.k8s%E7%AE%80%E4%BB%8B/" rel="prev" title="k8s简介">
                k8s简介 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avator.png"
                alt="Zamperini" />
            
              <p class="site-author-name" itemprop="name">Zamperini</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/%7C%7C%20archive">
                
                    <span class="site-state-item-count">56</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">23</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/DorgenJones" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:dblpfilter@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/1938368215" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0-ETCD简介"><span class="nav-number">1.</span> <span class="nav-text">0. ETCD简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Etcd初始化流程解析"><span class="nav-number">2.</span> <span class="nav-text">1. Etcd初始化流程解析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-数据存储"><span class="nav-number">3.</span> <span class="nav-text">3. 数据存储</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-raft数据存储"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 raft数据存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-应用数据存储"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 应用数据存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-启动过程"><span class="nav-number">3.2.1.</span> <span class="nav-text">3.2.1 启动过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-请求应用到存储"><span class="nav-number">3.2.2.</span> <span class="nav-text">3.2.2 请求应用到存储</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-网络通信"><span class="nav-number">4.</span> <span class="nav-text">2. 网络通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-成员节点间通信（peer）"><span class="nav-number">4.1.</span> <span class="nav-text">2.1 成员节点间通信（peer）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-客户端通信"><span class="nav-number">4.2.</span> <span class="nav-text">2.2 客户端通信</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-事务请求"><span class="nav-number">5.</span> <span class="nav-text">4. 事务请求</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#put-请求"><span class="nav-number">5.1.</span> <span class="nav-text">put 请求</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Leader接收请求，并广播消息"><span class="nav-number">5.1.1.</span> <span class="nav-text">Leader接收请求，并广播消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Follower接收到Leader的广播，进行处理回复"><span class="nav-number">5.1.2.</span> <span class="nav-text">Follower接收到Leader的广播，进行处理回复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leader收到Follower的回复进行处理"><span class="nav-number">5.1.3.</span> <span class="nav-text">Leader收到Follower的回复进行处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线性一致性读"><span class="nav-number">5.2.</span> <span class="nav-text">线性一致性读</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Leader节点收到请求后，广播心跳消息"><span class="nav-number">5.2.1.</span> <span class="nav-text">Leader节点收到请求后，广播心跳消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Follower接收到Leader的心跳请求，并返回"><span class="nav-number">5.2.2.</span> <span class="nav-text">Follower接收到Leader的心跳请求，并返回</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leader接收Follower回复，通知客户端请求继续"><span class="nav-number">5.2.3.</span> <span class="nav-text">Leader接收Follower回复，通知客户端请求继续</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-TTL-amp-Lease-实现"><span class="nav-number">6.</span> <span class="nav-text">5. TTL &amp; Lease 实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-初始化"><span class="nav-number">6.1.</span> <span class="nav-text">5.1 初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-Lease创建"><span class="nav-number">6.2.</span> <span class="nav-text">5.2 Lease创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-Lease绑定key"><span class="nav-number">6.3.</span> <span class="nav-text">5.3 Lease绑定key</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-Lease过期"><span class="nav-number">6.4.</span> <span class="nav-text">5.4 Lease过期</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-Watch机制"><span class="nav-number">7.</span> <span class="nav-text">6. Watch机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-初始化过程"><span class="nav-number">7.1.</span> <span class="nav-text">6.1 初始化过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-创建watch"><span class="nav-number">7.2.</span> <span class="nav-text">6.2 创建watch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-键值对更改"><span class="nav-number">7.3.</span> <span class="nav-text">6.3 键值对更改</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-集群管理"><span class="nav-number">8.</span> <span class="nav-text">7. 集群管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-集群间数据同步"><span class="nav-number">8.1.</span> <span class="nav-text">7.1 集群间数据同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-变更节点"><span class="nav-number">8.2.</span> <span class="nav-text">7.2 变更节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-1-新增节点"><span class="nav-number">8.2.1.</span> <span class="nav-text">7.2.1 新增节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-2-下线节点"><span class="nav-number">8.2.2.</span> <span class="nav-text">7.2.2 下线节点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-节点宕机"><span class="nav-number">8.3.</span> <span class="nav-text">7.3 节点宕机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-1-主节点宕机"><span class="nav-number">8.3.1.</span> <span class="nav-text">7.3.1 主节点宕机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-2-follower节点宕机"><span class="nav-number">8.3.2.</span> <span class="nav-text">7.3.2 follower节点宕机</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-节点迁移、替换"><span class="nav-number">8.4.</span> <span class="nav-text">7.4 节点迁移、替换</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zamperini</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.0.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.3"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
