<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.3">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.3" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Hexo, NexT" />


<meta property="og:type" content="website">
<meta property="og:title" content="Zamperini">
<meta property="og:url" content="https://dorgenjones.github.io/page/6/index.html">
<meta property="og:site_name" content="Zamperini">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zamperini">
<meta name="twitter:card" content="summary">






  <link rel="canonical" href="https://dorgenjones.github.io/page/6/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>Zamperini</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Zamperini</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2017/08/12/%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7/hystrix/1.hystrix-%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/12/%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7/hystrix/1.hystrix-%E7%AE%80%E4%BB%8B/" itemprop="url">Hystrix-简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-12T00:00:00+08:00">2017-08-12</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/hystrix/" itemprop="url" rel="index"><span itemprop="name">hystrix</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#Hystrix 简介<br>“<strong>Excuse me? 头戴金冠 北极熊??</strong>“<br><img src="/media/15018147277400.jpg" alt="set up-w300"></p>
<blockquote>
<p>Netflix(世界最大在线影片租赁服务商)开源的延迟容错工具包，用于隔离分布式系统之间的依赖访问。防止级联故障，使得复杂的分布式系统在错误不可避免的条件下仍具有弹性，具有自我保护的能力。</p>
</blockquote>
<p><a href="https://github.com/Netflix/Hystrix/wiki/FAQ%20:%20General#where-does-the-name-come-from" target="_blank" rel="noopener"><strong>Where does the name from?</strong></a></p>
<p><img src="/media/14980602061637.jpg" alt="set up-w300"></p>
<h2 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h2><ul>
<li>防护并控制因依赖第三方服务导致的延时和故障；</li>
<li>阻止级联故障；</li>
<li>快速失败并且能快速恢复；</li>
<li>支持失败降级和提供优雅的服务降级机制；</li>
<li>支持近实时监控、报警以及操作控制。</li>
</ul>
<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><p>在复杂的分布式系统里会有很多依赖，每个依赖都会不可避免地在某些时候发生故障。如果主应用没有隔离这些故障，那么就有被拖垮的风险。(<em>mmdb</em>大面积超时就是最有说服力的🌰)<br>Hystrix官网给出了这样一个例子：</p>
<blockquote>
<p>一个应用依赖30个外部服务，每个服务的可用性为<code>99.99%</code>，那么主应用的可用性即为<code>99.99^30</code> = <code>99.7%</code><br><code>0.3%</code>的故障率意味着每月有2+小时的时间服务不可用。可用性是相当差的<br>当服务依赖数越多时，整体可用性越差</p>
</blockquote>
<p>服务正常运行时，如下图所示:<br><img src="/media/14980612634741.jpg" alt=""></p>
<p>当有一个后台系统延时较高时，会阻塞整个用户的请求：</p>
<p><img src="/media/14980612716095.jpg" alt=""><br>在高并发的场景下，单个后台依赖接口超时后会造成所有服务器上的资源都被耗尽，造成更多级联故障。</p>
<p><img src="/media/14980612832009.jpg" alt=""></p>
<p>因此，所有这些延时和故障都应该被隔离和管理，使得单个接口故障不会拖累整个应用。</p>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><ul>
<li>通过<strong>线程隔离</strong>来防止单个依赖耗尽所有的容器内所有用户线程；</li>
<li>在系统无法及时处理请求时<strong>快速失败</strong>，而不是入队，以降低系统负载；</li>
<li>提供<strong>失败降级</strong>，在必要的时候让失效对用户透明。</li>
<li>利用隔离术（舱壁、泳道、熔断器模式）来隔离单个依赖对整个系统的影响；</li>
<li>针对系统服务的度量、监控、报警，提供优化以满足近实时性的需求；</li>
<li>Hystrix的大部分属性都支持<strong>动态配置</strong>并且快速应用，从而可以辅助我们做实时的操作修改；</li>
<li>可以<strong>隔离</strong>应用整个执行过程中失败的影响，而不仅仅在网络通信中。</li>
</ul>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><ul>
<li>将所有对外部系统的调用都<strong>包装</strong>在命令模式的对象 <code>HystrixCommand</code> or <code>HystrixObservableCommand</code>中，它通过在一个隔离的线程中执行远程调用。</li>
<li>默认情况下，支持<strong>自动超时机制</strong>，也支持人工配置超时时间（995线）。</li>
<li>对于每个依赖都维持一个<strong>线程池</strong>，如果线程池变满了，则立即拒绝而不是排队。</li>
<li><strong>记录成功、失败、超时和被线程拒绝的请求数</strong>。</li>
<li>引入<strong>断路器机制</strong>以阻断一段时间内对特定服务的访问。支持手动开启断路器，或者根据失败率自动开启模式。</li>
<li>在请求失败、超时、拒绝时，可以执行降级逻辑。</li>
<li>监控计量数据和配置修改信息并支持近实时地修改配置。</li>
</ul>
<p>当使用Hystrix来包装每个依赖服务时，上面的架构即变为如下图所示。其中每个依赖都相互隔离，当延迟发生时只会耗尽其内部资源而不影响其他资源，同时也覆盖了降级逻辑用于依赖服务发生错误时向用户返回信息。</p>
<p><img src="/media/14980613555431.jpg" alt=""></p>
<p>参考：</p>
<ol>
<li><a href="https://github.com/Netflix/Hystrix/wiki" target="_blank" rel="noopener">Hystrix</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2017/03/14/%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7/log/4.log4j2%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/14/%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7/log/4.log4j2%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%A4%84%E7%90%86/" itemprop="url">Log4j2 格式化处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-14T00:00:00+08:00">2017-03-14</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/log4j/" itemprop="url" rel="index"><span itemprop="name">log4j</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="PatternFormatter"><a href="#PatternFormatter" class="headerlink" title="PatternFormatter"></a>PatternFormatter</h1><h2 id="LogEventPatternConverter"><a href="#LogEventPatternConverter" class="headerlink" title="LogEventPatternConverter"></a>LogEventPatternConverter</h2><pre><code>### - LevelPatternConverter
### - ThreadPatternConvter
### - DatePatternConverter</code></pre><h2 id="FormattingInfo"><a href="#FormattingInfo" class="headerlink" title="FormattingInfo"></a>FormattingInfo</h2><h1 id="PatternLayout"><a href="#PatternLayout" class="headerlink" title="PatternLayout"></a>PatternLayout</h1><blockquote>
<p>在对PatternLayout的pattern字段进行解析（PatternParser的parse(final String pattern, final boolean alwaysWriteExceptions,final boolean noConsoleNoAnsi)中进行）时，会生成 List<PatternFormatter> formatters<br>PatternFormatter(LogEventPatternConverter,FormattingInfo) 其中LogEventPatternConverter用来将日志事件LogEvent转换为指定格式的字符串并追加到输出字符串后。</p>
</blockquote>
<h2 id="插件的初始化入口在"><a href="#插件的初始化入口在" class="headerlink" title="插件的初始化入口在:"></a>插件的初始化入口在:</h2><blockquote>
<p>PluginManager.collectPlugins里，它会创建一个PluginRegistry单例，其<code>decodeCacheFiles</code>方法用于从META-INF/org/apache/logging/log4j/core/config/plugins/Log4j2Plugins.dat文件中加载并解析插件对象，并按类别存储。目前共有6中类型插件：converter,lookup,core,configurationfactory,fileconverter,typeconverter</p>
</blockquote>
<h2 id="PatternLayout的处理"><a href="#PatternLayout的处理" class="headerlink" title="PatternLayout的处理:"></a>PatternLayout的处理:</h2><blockquote>
<p>在实例化PatternFormatter时，同时会通过PatternParser将 字符串转换成转换器列表<code>PatternFormater(LogEventPatternConverter,FormattingInfo)</code>。LogEventPatternConverter是转换类插件的抽象类。<br>下图演示的就是其对应关系：<br><img src="/media/14933065402517.jpg" alt="set up-w888"></p>
</blockquote>
<!--
**修改：**
- 1.首先，寻找org.apache.commons.logging.LogFactory 属性配置。
- 否则，利用JDK1.3 开始提供的service 发现机制，会扫描classpah 下的META-INF/services/org.apache.commons.logging.LogFactory文件，若找到则装载里面的配置，使用里面的配置。
- 否则，从Classpath 里寻找commons-logging.properties ，找到则根据里面的配置加载。
- 否则，使用默认的配置：如果能找到Log4j 则默认使用log4j 实现，如果没有则使用JDK14Logger 实现，再没有则使用commons-logging 内部提供的SimpleLog 实现。-->


<p>个人感觉SLF4J的实现更加灵活，并且它还提供了Maker和MDC的接口</p>
<h3 id="3-SLF4J-与-Common-logging对比"><a href="#3-SLF4J-与-Common-logging对比" class="headerlink" title="3. SLF4J 与 Common-logging对比"></a>3. SLF4J 与 Common-logging对比</h3><ol>
<li><p>common-logging通过<strong>动态查找</strong>的机制，在程序运行时自动找出真正使用的日志库。由于它使用了ClassLoader寻找和载入底层的日志库， 导致了像OSGI这样的框架无法正常工作，因为OSGI的不同的插件使用自己的ClassLoader。 OSGI的这种机制保证了插件互相独立，然而却使Common-logging无法工作。</p>
</li>
<li><p>slf4j在编译时<strong>静态绑定</strong>真正的Log库,因此可以在OSGI中使用。另外，SLF4J 支持参数化的log字符串；其次其避免了之前为了减少字符串拼接的性能损耗而不得不写的if(logger.isDebugEnable())，可以直接写：logger.debug(“current user is: {}”, user)。拼装消息被推迟到了它能够确定是不是要显示这条消息的时候，但是获取参数的代价并没有幸免。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2017/03/13/%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7/log/3.log4j2%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/13/%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7/log/3.log4j2%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" itemprop="url">Log4j2源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-13T00:00:00+08:00">2017-03-13</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/log4j/" itemprop="url" rel="index"><span itemprop="name">log4j</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Log4j2-源码浅析"><a href="#Log4j2-源码浅析" class="headerlink" title="Log4j2 源码浅析"></a>Log4j2 源码浅析</h1><p>[TOC]</p>
<p>介绍Log4j2的原理之前，回顾下之前配置文件中提到的几个概念：Configuration、LoggerConfig、Logger、Appender、Layout、Filter。Log4j2的官网上给出了类图，能清晰地看清楚它们之间的关联。<br>从图中可以看出LoggerContext、Configuration是一对一的关系，在一般的应用中通常也都只存在一个实例(Share one ClassLoader(<strong>Standalone Application、Web Application、Java EE Applications、”Shared” Web Applications and REST Service Containers</strong>)，<strong>Not</strong> <strong>OSGi Applications</strong> <a href="http://logging.apache.org/log4j/2.x/manual/logsep.html" target="_blank" rel="noopener">Logging Separation</a>)。</p>
<ol>
<li><strong>LoggerContext</strong>: 整个日志系统的<strong>锚点</strong>（承载全局日志上下文信息），类似于Spring的WebApplicationContext</li>
<li><strong>Configuration</strong>: <strong>全局配置信息</strong>，每个LoggerContext对应一个Configuration</li>
<li><strong>Appender</strong>: 追加器，对应配置文件中的<code>&lt;Appenders&gt;</code>下定义的Appender，定义日志输出位置以及日志输出格式，。用户可以自定义Appender，只需继承AbstractAppender并实现append(LogEvent)方法。<ul>
<li><strong>Layout</strong>: 定义日志的输出格式</li>
</ul>
</li>
<li><strong>Filter</strong>: <strong>过滤器</strong>，在整个日志系统的类图中，多个地方应用。起到一个过滤的作用，用于过滤特定日志级别的日志事件。有多个地方引用<code>Filter</code>：日志事件进入LoggerConfig之前；进入LoggerConfig后调用任何Appender之前；进入LoggerConfig后调用特殊的Appender之前；每个Appender内部。</li>
<li><strong>LoggerConfig</strong>: 真正的日志操作实体，对应配置文件中的<code>&lt;Logger&gt;</code>下定义的Logger。含有全局唯一标识（名称），一般对应的是一个包目录名称。</li>
<li><strong>Logger</strong>: 壳，每个Logger内部都对应一个LoggerConfig（通过名称来对应）。对日志事件的操作，都交由其对应的LoggerConfig进行处理<br><img src="/media/14930134238097.jpg" alt="set up-w666"></li>
</ol>
<ul>
<li>在使用日志系统前，首先需要初始化日志系统：解析日志配置信息<code>Configuration</code>，建立日志上下文<code>LoggerContext</code>（属性、Appender、LogerConfig…）</li>
<li>给定name获取日志对象Logger时，<code>LoggerContext</code>结合上下文信息，返回一个绑定了特定名称的<code>LoggerConfig</code>的<code>Loger</code></li>
<li>在执行日志操作时，会经过多层过滤(Filter)，并且真正的日志操作由LoggerConfig来处理。</li>
</ul>
<p>因此下面，将从<strong>这三方面</strong>来分析日志系统。1. 日志系统的初始化；2.获取日志对象；3.日志操作过程。其中，日志系统的初始化较其他两部分稍复杂。</p>
<h2 id="1-日志系统的初始化过程，获取LoggerContext"><a href="#1-日志系统的初始化过程，获取LoggerContext" class="headerlink" title="1. 日志系统的初始化过程，获取LoggerContext"></a>1. 日志系统的初始化过程，获取LoggerContext</h2><p>初始化的过程关键是 加载并解析配置文件，建立日志上下文。<br>初始化过程的时序图：<br><img src="/media/log%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="log初始化时序图"></p>
<p>当应用首次调动<code>LogManager.getLogger</code>方法时，触发日志系统的初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getLogger</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">//获取LoggerContext，通过其获取指定类名称的Logger</span></span><br><span class="line">   <span class="keyword">return</span> getContext(clazz.getClassLoader(), <span class="keyword">false</span>).getLogger(clazz.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getContext</code>方法是建立日志系统上下文的<strong>起点</strong>。LogManager在类初始化时，会初始化一个生成LogerContext工厂，用户可以指定这个工厂，默认情况下为Log4jContextFactory。下文我们以Log4jContextFactory为主线来分析，其他情况类似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LoggerContext <span class="title">getContext</span><span class="params">(<span class="keyword">final</span> ClassLoader loader, <span class="keyword">final</span> <span class="keyword">boolean</span> currentContext)</span> </span>&#123;</span><br><span class="line"><span class="comment">//factory为LoggerContextFactory接口的实现类，获取LoggerContext的工厂，</span></span><br><span class="line"><span class="comment">//而fatory的真正类型的初始化是在LogerManager的静态语句中进行。这里我们主要关注Log4jContextFactory</span></span><br><span class="line">   <span class="keyword">return</span> factory.getContext(FQCN, loader, <span class="keyword">null</span>, currentContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在初始化Log4jContextFactory工厂对象时，同时会实例化一个实现<code>ContextSelector</code>（用于定位<code>LogerContext</code>）接口的日志上下文选择器。同样，用户可以指定这个选择器（属性配置：<code>Log4jContextSelector</code>）；默认为<code>ClassLoaderContextSelector</code>（前面一节提到的全异步化是将<code>ClassLoaderContextSelector</code>设置为<code>AsyncLoggerContextSelector</code>）。下文同样以<code>ClassLoaderContextSelector</code>为例。</p>
<p>进一步，<code>Log4jContextFactory</code>会调动<code>ClassLoaderContextSelector</code>的<code>getContext</code>方法来获取<code>LoggerContext</code>，然后调用LoggerContext的start方法进行日志系统的初始化（<strong>核心部分</strong>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LoggerContext <span class="title">getContext</span><span class="params">(<span class="keyword">final</span> String fqcn, <span class="keyword">final</span> ClassLoader loader, <span class="keyword">final</span> Object externalContext,<span class="keyword">final</span> <span class="keyword">boolean</span> currentContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例化LoggerContext</span></span><br><span class="line">   <span class="keyword">final</span> LoggerContext ctx = selector.getContext(fqcn, loader, currentContext);</span><br><span class="line">   <span class="keyword">if</span> (externalContext != <span class="keyword">null</span> &amp;&amp; ctx.getExternalContext() == <span class="keyword">null</span>) &#123;</span><br><span class="line">       ctx.setExternalContext(externalContext);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (ctx.getState() == LifeCycle.State.INITIALIZED) &#123;</span><br><span class="line">       ctx.start();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，首先会拿ClassLoader去缓存中拿，如果有则直接返回，没有则创建一个。<br>因为是<strong>根据ClassLoader来进行缓存LoggerContext</strong>，所以对于同一个应用来说其所有的日志对象对应同一个LoggerContext。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> LoggerContext <span class="title">locateContext</span><span class="params">(<span class="keyword">final</span> ClassLoader loaderOrNull, <span class="keyword">final</span> URI configLocation)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> ClassLoader loader = loaderOrNull != <span class="keyword">null</span> ? loaderOrNull : ClassLoader.getSystemClassLoader();</span><br><span class="line">   <span class="keyword">final</span> String name = toContextMapKey(loader);</span><br><span class="line">   <span class="comment">//此处，首先会从CONTEXT_MAP中查看指定类型ClassLoader的LoggerContext是否已经存在，</span></span><br><span class="line">   <span class="comment">//若存在则直接返回，这里也能看到为什么OSGI每个Budle有不同的日志系统。</span></span><br><span class="line">   AtomicReference&lt;WeakReference&lt;LoggerContext&gt;&gt; ref = CONTEXT_MAP.get(name);</span><br><span class="line">   <span class="keyword">if</span> (ref == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (configLocation == <span class="keyword">null</span>) &#123;</span><br><span class="line">           ClassLoader parent = loader.getParent();</span><br><span class="line">           <span class="keyword">while</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">               ref = CONTEXT_MAP.get(toContextMapKey(parent));</span><br><span class="line">               <span class="keyword">if</span> (ref != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">final</span> WeakReference&lt;LoggerContext&gt; r = ref.get();</span><br><span class="line">                   <span class="keyword">final</span> LoggerContext ctx = r.get();</span><br><span class="line">                   <span class="keyword">if</span> (ctx != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="keyword">return</span> ctx;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               parent = parent.getParent();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//实例化一个LoggerContext，并将LoggerContext放进CONTEXT_MAP中</span></span><br><span class="line">       LoggerContext ctx = createContext(name, configLocation);</span><br><span class="line">       <span class="keyword">final</span> AtomicReference&lt;WeakReference&lt;LoggerContext&gt;&gt; r = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">       r.set(<span class="keyword">new</span> WeakReference&lt;&gt;(ctx));</span><br><span class="line">       CONTEXT_MAP.putIfAbsent(name, r);</span><br><span class="line">       ctx = CONTEXT_MAP.get(name).get().get();</span><br><span class="line">       <span class="keyword">return</span> ctx;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LoggerContext的初始化方法<code>start</code>会间接调用reconfigure(URI) （start() -&gt; reconfigure() -&gt; reconfigure(URI)），其是<strong>加载并解析配置文件的核心内容</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reconfigure</span><span class="params">(<span class="keyword">final</span> URI configURI)</span> </span>&#123;</span><br><span class="line">   final ClassLoader cl = ClassLoader.class.isInstance(externalContext) ? (ClassLoader) externalContext : null;</span><br><span class="line">   <span class="comment">//通过配置工厂生成配置类</span></span><br><span class="line">   <span class="keyword">final</span> Configuration instance = ConfigurationFactory.getInstance().getConfiguration(name, configURI, cl);</span><br><span class="line">   <span class="comment">//对Configuration中的树形结构数据进行解析成对象，然后设置到LogerContext中</span></span><br><span class="line">   setConfiguration(instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其主要内容如下：</p>
<ol>
<li>首先获取所有可用的配置工厂(ConfigurationFactory)，然后根据应用中有的的配置文件类型（yml|json|xml）来适配一种配置对象生成工厂，通过工厂对象生成相应的配置对象。下面将以XMLConfigurationFactory为例，来介绍XMLConfiguration的生成和文件解析过程。其他两种（<code>YamlConfigurationFactory</code>,<code>JsonConfigurationFactory</code>）类似。<ul>
<li>在生成XMLConfiguration的同时，也会利用XML解析器将配置文件解析成Document类型，便于后面解析。</li>
</ul>
</li>
<li><code>setConfiguration(instance)</code>是将Xml文档对象解析成真正的日志对象的主要过程。其调用start方法来完成解析的整个过程。</li>
</ol>
<p>解析的过程分两步：1.<code>setup</code>利用XML文档对象构建起Node配置信息结构树（带有XML标签对应的插件类型信息）; 2.<code>doConfigure</code>利用Node配置信息结构树，进一步完成从插件对象到实体对象的转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.setStarting();</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">//通过递归的方式将XMl的标签元素转换成Node(插件类)</span></span><br><span class="line">   setup();</span><br><span class="line">   setupAdvertisement();</span><br><span class="line">   <span class="comment">//通过反射的形式将带插件类型的Node转换成真正的类型并实例化相应的对象，并设置到XMlConfiguration属性中</span></span><br><span class="line">   doConfigure();</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">super</span>.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>setup</code>方法通过递归调用<code>constructHierarchy</code>完成从XML标签元素到Node的转换，Node中最重要的属性是PluginType信息，它是配置文件Tag标签对应的插件类。（pluginManager是啥？为啥能根据tag标签名获取插件类型？<strong>留到最后讲解</strong>）</p>
<blockquote>
<p>以<code>&lt;Console&gt;</code>标签为例，它的插件类型为<code>ConsoleAppender</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   constructHierarchy(rootNode, rootElement);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">constructHierarchy</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">final</span> Element element)</span> </span>&#123;</span><br><span class="line">   processAttributes(node, element);</span><br><span class="line">   <span class="keyword">final</span> StringBuilder buffer = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">   <span class="keyword">final</span> NodeList list = element.getChildNodes();</span><br><span class="line">   <span class="keyword">final</span> List&lt;Node&gt; children = node.getChildren();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.getLength(); i++) &#123;</span><br><span class="line">       <span class="keyword">final</span> org.w3c.dom.Node w3cNode = list.item(i);</span><br><span class="line">       <span class="keyword">if</span> (w3cNode <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">           <span class="keyword">final</span> Element child = (Element) w3cNode;</span><br><span class="line">           <span class="comment">//获取元素的名称，并通过名称获取对应的插件类信息，构建与配置文件结构一一对应的Node树结构。</span></span><br><span class="line">           <span class="comment">//如上一届的Console，它的插件类型为ConsoleAppender</span></span><br><span class="line">           <span class="keyword">final</span> String name = getType(child);</span><br><span class="line">           <span class="keyword">final</span> PluginType&lt;?&gt; type = pluginManager.getPluginType(name);</span><br><span class="line">           <span class="keyword">final</span> Node childNode = <span class="keyword">new</span> Node(node, name, type);</span><br><span class="line">           <span class="comment">//递归 DFS</span></span><br><span class="line">           constructHierarchy(childNode, child);</span><br><span class="line">           <span class="keyword">if</span> (type == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">final</span> String value = childNode.getValue();</span><br><span class="line">               <span class="keyword">if</span> (!childNode.hasChildren() &amp;&amp; value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   node.getAttributes().put(name, value);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   status.add(<span class="keyword">new</span> Status(name, element, ErrorType.CLASS_NOT_FOUND));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               children.add(childNode);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (w3cNode <span class="keyword">instanceof</span> Text) &#123;</span><br><span class="line">           <span class="keyword">final</span> Text data = (Text) w3cNode;</span><br><span class="line">           buffer.append(data.getData());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">final</span> String text = buffer.toString().trim();</span><br><span class="line">   <span class="keyword">if</span> (text.length() &gt; <span class="number">0</span> || (!node.hasChildren() &amp;&amp; !node.isRoot())) &#123;</span><br><span class="line">       node.setValue(text);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>doConfigure</code> 递归执行<code>createConfiguration</code>方法，其通过插件类信息构建日志对象（<code>Appender</code>、<code>LogerConfig</code>、<code>Filter</code>）。创建完日志成员对象后，会进一步建立他们之间的联系。最后对于<code>LogerConfig</code>会构建起其层次结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doConfigure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">boolean</span> setLoggers = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">boolean</span> setRoot = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">final</span> Node child : rootNode.getChildren()) &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="comment">//关键！！</span></span><br><span class="line">       createConfiguration(child, <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">if</span> (child.getObject() == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (child.getName().equalsIgnoreCase(<span class="string">"Appenders"</span>)) &#123;</span><br><span class="line">           appenders = child.getObject();</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.isInstanceOf(Filter<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">           addFilter(child.getObject(Filter<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getName().equalsIgnoreCase(<span class="string">"Loggers"</span>)) &#123;</span><br><span class="line">           <span class="keyword">final</span> Loggers l = child.getObject();</span><br><span class="line">           loggers = l.getMap();</span><br><span class="line">           setLoggers = <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">if</span> (l.getRoot() != <span class="keyword">null</span>) &#123;</span><br><span class="line">               root = l.getRoot();</span><br><span class="line">               setRoot = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;...</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 建立起 LogerConfig与Appender之间的引用关系</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">final</span> Map.Entry&lt;String, LoggerConfig&gt; entry : loggers.entrySet()) &#123;</span><br><span class="line">       <span class="keyword">final</span> LoggerConfig l = entry.getValue();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">final</span> AppenderRef ref : l.getAppenderRefs()) &#123;</span><br><span class="line">           <span class="keyword">final</span> Appender app = appenders.get(ref.getRef());</span><br><span class="line">           <span class="keyword">if</span> (app != <span class="keyword">null</span>) &#123;</span><br><span class="line">               l.addAppender(app, ref.getLevel(), ref.getFilter());</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               LOGGER.error(<span class="string">"Unable to locate appender &#123;&#125; for logger &#123;&#125;"</span>, ref.getRef(), l.getName());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 构建起LogerConfig之间的父子关系（通过name）</span></span><br><span class="line">   setParents();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>createConfiguration</code>会调动<code>createPluginObject(type, node, event)</code>方法来生成对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createConfiguration</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">final</span> LogEvent event)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> PluginType&lt;?&gt; type = node.getType();</span><br><span class="line">   <span class="keyword">if</span> (type != <span class="keyword">null</span> &amp;&amp; type.isDeferChildren()) &#123;</span><br><span class="line">       node.setObject(createPluginObject(type, node, event));</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">final</span> Node child : node.getChildren()) &#123;</span><br><span class="line">           createConfiguration(child, event);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (type == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (node.getParent() != <span class="keyword">null</span>) &#123;</span><br><span class="line">               LOGGER.error(<span class="string">"Unable to locate plugin for &#123;&#125;"</span>, node.getName());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           node.setObject(createPluginObject(type, node, event));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过构建器来穿件对象，首先通过<code>createBuilder(this.class)</code>来创建构建器，然后，通过反射对构建器设置属性值，最后调用构建器的<code>build()</code>来生成对象。通过工厂的方式也是类似的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">createPluginObject</span><span class="params">(<span class="keyword">final</span> PluginType&lt;?&gt; type, <span class="keyword">final</span> Node node, <span class="keyword">final</span> LogEvent event)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Class&lt;?&gt; clazz = type.getPluginClass();</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> PluginBuilder(type)</span><br><span class="line">           .withConfiguration(<span class="keyword">this</span>)</span><br><span class="line">           .withConfigurationNode(node)</span><br><span class="line">           .forLogEvent(event)</span><br><span class="line">           .build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   verify();</span><br><span class="line">   <span class="comment">// first try to use a builder class if one is available</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">final</span> Builder&lt;?&gt; builder = createBuilder(<span class="keyword">this</span>.clazz);</span><br><span class="line">       <span class="keyword">if</span> (builder != <span class="keyword">null</span>) &#123;</span><br><span class="line">           injectFields(builder);</span><br><span class="line">           <span class="keyword">final</span> Object result = builder.build();</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;...</span><br><span class="line">   <span class="comment">// or fall back to factory method if no builder class is available</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">final</span> Method factory = findFactoryMethod(<span class="keyword">this</span>.clazz);</span><br><span class="line">       <span class="keyword">final</span> Object[] params = generateParameters(factory);</span><br><span class="line">       <span class="keyword">final</span> Object plugin = factory.invoke(<span class="keyword">null</span>, params);</span><br><span class="line">       <span class="keyword">return</span> plugin;</span><br><span class="line">   &#125;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>createBuilder(this.clazz)</code>是通过反射的形式扫描clazz类的方法，找到带有<code>@PluginBuilderFactory</code>注解静态方法，并调用它来生成构建器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Builder&lt;?&gt; createBuilder(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span><br><span class="line">        <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">final</span> Method method : clazz.getDeclaredMethods()) &#123;</span><br><span class="line">   <span class="comment">//通过反射获取加了 @PluginBuilderFactory 的方法，并通过反射调用此方法来获取构建器。</span></span><br><span class="line">       <span class="keyword">if</span> (method.isAnnotationPresent(PluginBuilderFactory<span class="class">.<span class="keyword">class</span>) &amp;&amp;</span></span><br><span class="line"><span class="class">           <span class="title">Modifier</span>.<span class="title">isStatic</span>(<span class="title">method</span>.<span class="title">getModifiers</span>()) &amp;&amp;</span></span><br><span class="line"><span class="class">           <span class="title">TypeUtil</span>.<span class="title">isAssignable</span>(<span class="title">Builder</span>.<span class="title">class</span>, <span class="title">method</span>.<span class="title">getGenericReturnType</span>())) </span>&#123;</span><br><span class="line">           ReflectionUtil.makeAccessible(method);</span><br><span class="line">           <span class="keyword">final</span> Builder&lt;?&gt; builder = (Builder&lt;?&gt;) method.invoke(<span class="keyword">null</span>);</span><br><span class="line">           <span class="keyword">return</span> builder;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一个具体的栗子，加深理解。</p>
<p>配置文件中配置了一个追加器 <code>Console</code>，其对应的插件类型为 <code>ConsoleAppender</code>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">"WARN"</span> <span class="attr">monitorInterval</span>=<span class="string">"1000"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"[%level][%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;][%thread][%class][%method][%line]:%message%n"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>在<code>setup()</code>方法中会将XML转换成<code>Node(PluginType=ConsoleAppender.class,...)</code></li>
<li>在doConfigure方法中会扫描ConsoleAppender类的所有方法，找到带有<code>@PluginBuilderFactory</code>的静态方法<code>newBuilder()</code>，通过调用<code>newBuilder</code>方法获得构造器<code>ConsoleAppender.Builder</code></li>
</ol>
<p>到此，LoggerContext的初始化就完成了。</p>
<h2 id="2-通过LoggerContext获取Logger"><a href="#2-通过LoggerContext获取Logger" class="headerlink" title="2. 通过LoggerContext获取Logger"></a>2. 通过LoggerContext获取Logger</h2><p>通过LoggerContext获取Logger的逻辑比较简单。</p>
<ol>
<li>首先尝试从缓存中获取，有则直接返回，没有则到下一步；</li>
<li>调用<code>newInstance</code>来创建一个Logger。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Logger <span class="title">getLogger</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> getLogger(name, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Logger <span class="title">getLogger</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> MessageFactory messageFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先尝试从缓存中</span></span><br><span class="line">   Logger logger = loggers.get(name);</span><br><span class="line">   <span class="keyword">if</span> (logger != <span class="keyword">null</span>) &#123;</span><br><span class="line">       AbstractLogger.checkMessageFactory(logger, messageFactory);</span><br><span class="line">       <span class="keyword">return</span> logger;</span><br><span class="line">   &#125;</span><br><span class="line">   logger = newInstance(<span class="keyword">this</span>, name, messageFactory);</span><br><span class="line">   <span class="keyword">final</span> Logger prev = loggers.putIfAbsent(name, logger);</span><br><span class="line">   <span class="keyword">return</span> prev == <span class="keyword">null</span> ? logger : prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>newInstance</code>方法间接调用 Logger的构造函数来实例化一个Logger对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Logger</span><span class="params">(<span class="keyword">final</span> LoggerContext context, <span class="keyword">final</span> String name, <span class="keyword">final</span> MessageFactory messageFactory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>(name, messageFactory);</span><br><span class="line">   <span class="keyword">this</span>.context = context;</span><br><span class="line">   config = <span class="keyword">new</span> PrivateConfig(context.getConfiguration(), <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，PrivateConfig建立起Logger与具体的LoggerConfig的关联。<br><code>getLoggerConfig</code>方法中可以看出：<br>    1. 先通过Logger的名称看是否有与其名称一致的LoggerConfig，有则返回；<br>    2. 通过以 <code>.</code>为分割符，从后往前截取字符串<code>name.substring(0,name.lastIndexOf(&#39;.&#39;))</code>，并以此来寻找是否能找到相应的LoggerConfig。若都没找到，则直接返回根LoggerConfig</p>
<blockquote>
<p>比如Logger的名称为com.maoyan.order.biz，会顺序查找是否有 以 “com.maoyan.order.biz”、“com.maoyan.order” “com.maoyan”、“com”命名的LoggerConfig，若找到则直接返回，否则返回根LoggerConfig</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrivateConfig</span><span class="params">(<span class="keyword">final</span> Configuration config, <span class="keyword">final</span> Logger logger)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.config = config;</span><br><span class="line">  <span class="keyword">this</span>.loggerConfig = config.getLoggerConfig(getName());</span><br><span class="line">  <span class="keyword">this</span>.level = <span class="keyword">this</span>.loggerConfig.getLevel();</span><br><span class="line">  <span class="keyword">this</span>.intLevel = <span class="keyword">this</span>.level.intLevel();</span><br><span class="line">  <span class="keyword">this</span>.logger = logger;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AbstractConfig的getLoggerConfig</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LoggerConfig <span class="title">getLoggerConfig</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (loggers.containsKey(name)) &#123;</span><br><span class="line">       <span class="keyword">return</span> loggers.get(name);</span><br><span class="line">   &#125;</span><br><span class="line">   String substr = name;</span><br><span class="line">   <span class="keyword">while</span> ((substr = NameUtil.getSubName(substr)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (loggers.containsKey(substr)) &#123;</span><br><span class="line">           <span class="keyword">return</span> loggers.get(substr);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/media/14930152428677.jpg" alt="set up-w666"></p>
<p>最终就完成了Logger对象的创建。</p>
<h2 id="3-触发日志事件"><a href="#3-触发日志事件" class="headerlink" title="3. 触发日志事件"></a>3. 触发日志事件</h2><p>下面将从一条日志语句出发，分析进行日志操作的过程中，经过了哪些过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.info(<span class="string">"Hello World"</span>);</span><br></pre></td></tr></table></figure>
<p>首先，这条日志会间接调用AbstractLogger中的<code>logIfEnabled</code>方法，其中<code>IsEnabled</code> 会第一次调用<code>Filter</code>对象，判断是否可以继续下去；若Configuration没有配置<code>Filter</code>，则判断日志事件的Level是否大于对应的LoggerConfig的Level。ps:这里的<code>Filter</code>是<strong>Configuration的全局<code>Filter</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logIfEnabled</span><span class="params">(<span class="keyword">final</span> String fqcn, <span class="keyword">final</span> Level level, <span class="keyword">final</span> Marker marker, <span class="keyword">final</span> String message,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> Throwable t)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (isEnabled(level, marker, message, t)) &#123;</span><br><span class="line">       logMessage(fqcn, level, marker, message, t);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当操作不被拦截后，进入Logger的<code>logMessage</code>方法。可以看出，操作最终交由LoggerConfig来处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logMessage</span><span class="params">(<span class="keyword">final</span> String fqcn, <span class="keyword">final</span> Level level, <span class="keyword">final</span> Marker marker, <span class="keyword">final</span> Message message, <span class="keyword">final</span> Throwable t)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Message msg = message == <span class="keyword">null</span> ? <span class="keyword">new</span> SimpleMessage(Strings.EMPTY) : message;</span><br><span class="line">   config.config.getConfigurationMonitor().checkConfiguration();</span><br><span class="line">    <span class="comment">//由LoggerConfig来执行操作</span></span><br><span class="line">   config.loggerConfig.log(getName(), fqcn, marker, level, msg, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LoggerConfig的<code>log</code>方法会对日志操作进行一次包装，封装成LogEvent，随后调用<code>log(event)</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">final</span> String loggerName, <span class="keyword">final</span> String fqcn,<span class="keyword">final</span> Marker marker, <span class="keyword">final</span> Level level, <span class="keyword">final</span> Message data,<span class="keyword">final</span> Throwable t)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">final</span> LogEvent event = logEventFactory.createEvent(loggerName, marker, fqcn, level, data, props, t);</span><br><span class="line">   log(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，第二次调用<code>filter</code>，这里调用的是<strong>LoggerConfig配置的Filter</strong>。进行过滤后开始调用LoggerConfig中配置的每个Appender。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">final</span> LogEvent event)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (isFiltered(event)) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       event.setIncludeLocation(isIncludeLocation());</span><br><span class="line">       callAppenders(event);</span><br><span class="line">       <span class="keyword">if</span> (additive &amp;&amp; parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">           parent.log(event);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法中进行了两次过滤，第一次是调用Appender的Filter进行过滤，第二次当Appender实现了Filerable接口时，则执行接口方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callAppender</span><span class="params">(<span class="keyword">final</span> LogEvent event)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (getFilter() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//第三次调用filter，此处的Filter为Appender的Filter</span></span><br><span class="line">       <span class="keyword">final</span> Filter.Result r = getFilter().filter(event);</span><br><span class="line">       <span class="keyword">if</span> (r == Filter.Result.DENY) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (level != <span class="keyword">null</span> &amp;&amp; intLevel &lt; event.getLevel().intLevel()) &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (recursive.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">       appender.getHandler().error(<span class="string">"Recursive call to appender "</span> + appender.getName());</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       recursive.set(<span class="keyword">this</span>);</span><br><span class="line">       ...</span><br><span class="line">       <span class="comment">//第四次调用，当Appender是接口Filterable的实现类，则进行一次过滤</span></span><br><span class="line">       <span class="keyword">if</span> (appender <span class="keyword">instanceof</span> Filterable &amp;&amp; ((Filterable) appender).isFiltered(event)) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用Appender进行追加</span></span><br><span class="line">           appender.append(event);</span><br><span class="line">       &#125;...</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       recursive.set(<span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-附加信息"><a href="#4-附加信息" class="headerlink" title="4. 附加信息"></a>4. 附加信息</h2><h3 id="获取ConfigurationFactory"><a href="#获取ConfigurationFactory" class="headerlink" title="获取ConfigurationFactory"></a>获取ConfigurationFactory</h3><p>上面提到ConfigurationFactory会根据配置文件的文件类型来使用相应的配置工厂类，那么整个过程是怎么进行的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Configuration instance = ConfigurationFactory.getInstance().getConfiguration(name, configURI, cl);</span><br></pre></td></tr></table></figure>
<p>首先<code>getInstance</code>方法会收集所有可用的<code>ConfigurationFactory</code>,然后<code>getConfiguration</code>遍历所有可用的<code>ConfigurationFactory</code>，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurationFactory <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (factories == <span class="keyword">null</span>) &#123;</span><br><span class="line">       LOCK.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (factories == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//首先，如果用户配置了log4j.configurationFactory，则将此加入可用的ConfigurationFactory队列中</span></span><br><span class="line">               <span class="keyword">final</span> List&lt;ConfigurationFactory&gt; list = <span class="keyword">new</span> ArrayList&lt;ConfigurationFactory&gt;();</span><br><span class="line">               <span class="keyword">final</span> String factoryClass = PropertiesUtil.getProperties().getStringProperty(CONFIGURATION_FACTORY_PROPERTY);</span><br><span class="line">               <span class="keyword">if</span> (factoryClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   addFactory(list, factoryClass);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//CATEGROY: ConfigurationFactory，通过PluginManager获取所有“ConfigurationFactory”类型的插件，加到工厂队列中</span></span><br><span class="line">               <span class="keyword">final</span> PluginManager manager = <span class="keyword">new</span> PluginManager(CATEGORY);</span><br><span class="line">               manager.collectPlugins();</span><br><span class="line">               <span class="keyword">final</span> Map&lt;String, PluginType&lt;?&gt;&gt; plugins = manager.getPlugins();</span><br><span class="line">               <span class="keyword">final</span> List&lt;Class&lt;? extends ConfigurationFactory&gt;&gt; ordered =</span><br><span class="line">                   <span class="keyword">new</span> ArrayList&lt;Class&lt;? extends ConfigurationFactory&gt;&gt;(plugins.size());</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">final</span> PluginType&lt;?&gt; type : plugins.values()) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       ordered.add(type.getPluginClass().asSubclass(ConfigurationFactory<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">                   &#125;...</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//每个工厂类都有一个@Order(n)注解，按n的大小进行排序</span></span><br><span class="line">               Collections.sort(ordered, OrderComparator.getInstance());</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">final</span> Class&lt;? extends ConfigurationFactory&gt; clazz : ordered) &#123;</span><br><span class="line">                   addFactory(list, clazz);</span><br><span class="line">               &#125;</span><br><span class="line">               factories = Collections.unmodifiableList(list);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           LOCK.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> configFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在获得所有可用的配置工厂后，接下来就来确定到底用那种类型的配置工厂。其逻辑在<code>getConfiguration(isTest,name)</code>方法中。</p>
<p><strong>需要注意的是</strong>：在能找到多个不同类型的日志配置文件(json、yml、xml)，因为会按yml -&gt; json -&gt; xml的顺序来加载配置文件并确定配置工厂。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Configuration <span class="title">getConfiguration</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> isTest, <span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> named = name != <span class="keyword">null</span> &amp;&amp; name.length() &gt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">final</span> ClassLoader loader = LoaderUtil.getThreadContextClassLoader();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> ConfigurationFactory factory : factories) &#123;</span><br><span class="line">      String configName;</span><br><span class="line">      <span class="keyword">final</span> String prefix = isTest ? TEST_PREFIX : DEFAULT_PREFIX;</span><br><span class="line">      <span class="comment">//获取工厂支持的所有文件类型，然后拼接成最终的文件路径</span></span><br><span class="line">      <span class="keyword">final</span> String [] types = factory.getSupportedTypes();</span><br><span class="line">      <span class="keyword">if</span> (types == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> String suffix : types) &#123;</span><br><span class="line">          <span class="keyword">if</span> (suffix.equals(<span class="string">"*"</span>)) &#123;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          configName = named ? prefix + name + suffix : prefix + suffix;</span><br><span class="line">        <span class="comment">// 如果能加载到文件名文件，则返回该工厂。</span></span><br><span class="line">          <span class="keyword">final</span> ConfigurationSource source = getInputFromResource(configName, loader);</span><br><span class="line">          <span class="keyword">if</span> (source != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> factory.getConfiguration(source);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PluginManager的初始化"><a href="#PluginManager的初始化" class="headerlink" title="PluginManager的初始化"></a>PluginManager的初始化</h3><p>在上面整个分析过程中，可以看到多处用到了<code>PluginManager</code>,通过它可以获得特定类型的插件，那么这些插件是怎么初始化的呢？</p>
<blockquote>
<p>事实上，在PluginManger初始化时，其属性 pluginRegistry（单例）初始化时，会调用<code>decodeCacheFiles</code>方法用于从META-INF/org/apache/logging/log4j/core/config/plugins/Log4j2Plugins.dat文件中加载并解析所有的插件类型对象，并按类别存储。目前共有6中类型插件：converter,lookup,core,configurationfactory,fileconverter,typeconverter</p>
</blockquote>
<h3 id="PatternLayout的特殊处理"><a href="#PatternLayout的特殊处理" class="headerlink" title="PatternLayout的特殊处理"></a>PatternLayout的特殊处理</h3><p>在对配置文件解析时，一件有意思的事是，对日志输出样式的处理。<br>在日志系统初始化阶段，会对字符串形式的输出样式进行解析，将其转换为convetor的列表。在日志输出时，只需要顺序调用这些转换器，拼接返回结果得到输出内容。这样使得日志输出效率高。<br><img src="/media/14933065402517.jpg" alt="set up-w888"></p>
<p>[TOC]</p>
<p>参考：</p>
<ol>
<li><a href="http://logging.apache.org/log4j/2.x/manual/architecture.html" target="_blank" rel="noopener">Log4j2 Architecture</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2017/03/12/%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7/log/2.log4j2%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/12/%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7/log/2.log4j2%E9%85%8D%E7%BD%AE/" itemprop="url">Log4j2配置文件&描述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-12T00:00:00+08:00">2017-03-12</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/log4j/" itemprop="url" rel="index"><span itemprop="name">log4j</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Log4j2-配置文件及描述"><a href="#Log4j2-配置文件及描述" class="headerlink" title="Log4j2 配置文件及描述"></a>Log4j2 配置文件及描述</h1><p>前面介绍Java Log的总体情况，以及两个日志框架和具体日志实现框架间的桥接。本章主要介绍日常工作中用的比较多的Log4j2的配置信息以及解释。</p>
<h2 id="1-配置文件解析"><a href="#1-配置文件解析" class="headerlink" title="1. 配置文件解析"></a>1. 配置文件解析</h2><h3 id="1-同步模式"><a href="#1-同步模式" class="headerlink" title="1. 同步模式"></a>1. 同步模式</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    全局配置</span></span><br><span class="line"><span class="comment">    status : 这个用于设置log4j2自身内部的信息输出,可以不设置,当设置成trace时,会看到log4j2内部各种详细输出</span></span><br><span class="line"><span class="comment">    monitorInterval : Log4j能够自动检测修改配置文件和重新配置本身, 设置间隔秒数。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">"WARN"</span> <span class="attr">monitorInterval</span>=<span class="string">"1000"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置日志目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"LOG_HOME"</span>&gt;</span>./logs<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志输出地址--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--输出控制台--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志格式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"[%level][%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;][%thread][%class][%method][%line]:%message%n"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingRandomAccessFile</span> <span class="attr">name</span>=<span class="string">"infoLog"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;LOG_HOME&#125;/info.log"</span></span></span><br><span class="line"><span class="tag">                                 <span class="attr">filePattern</span>=<span class="string">"$&#123;LOG_HOME&#125;/info.%d&#123;yyyy-MM-dd&#125;.log.gz"</span> <span class="attr">append</span>=<span class="string">"true"</span>&gt;</span><span class="comment">&lt;!--压缩文件名--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"[%level][%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;][%thread][%class][%method][%line]:%message%n"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                 %c&#123;precision&#125; | %logger&#123;precision&#125; : name of the logger</span></span><br><span class="line"><span class="comment">                 %class&#123;precision&#125; | %C&#123;precision&#125;: class name of the caller</span></span><br><span class="line"><span class="comment">                 %date&#123;pattern&#125; | %d&#123;pattern&#125; :the date of the logging event</span></span><br><span class="line"><span class="comment">                 %L | %line:line number</span></span><br><span class="line"><span class="comment">                 %level : the level of the logging event</span></span><br><span class="line"><span class="comment">                 %m&#123;nolookups&#125;&#123;ansi&#125; | %msg&#123;nolookups&#125;&#123;ansi&#125; | %message&#123;nolookups&#125;&#123;ansi&#125;:application supplied message</span></span><br><span class="line"><span class="comment">                 %method | %M: method name where the logging request</span></span><br><span class="line"><span class="comment">                 %t | %tn | %thread | %threadName :name of the thread</span></span><br><span class="line"><span class="comment">                 %n :</span></span><br><span class="line"><span class="comment">             --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Filters</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"error"</span> <span class="attr">onMatch</span>=<span class="string">"DENY"</span> <span class="attr">onMismatch</span>=<span class="string">"NEUTRAL"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"warn"</span> <span class="attr">onMatch</span>=<span class="string">"DENY"</span> <span class="attr">onMismatch</span>=<span class="string">"NEUTRAL"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"info"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"debug"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Filters</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                     TimeBased Triggering Policy: The policy to use to determine if a rollover should occur.</span></span><br><span class="line"><span class="comment">                    interval单位与filePattern相关 yyyy-MM-dd 一天一个文件, yyyy-MM-dd-HH 每小时一个文件</span></span><br><span class="line"><span class="comment">                    基于时间的触发策略。该策略主要是完成周期性的log文件封存工作。有两个参数：</span></span><br><span class="line"><span class="comment">                    interval，integer型，指定两次封存动作之间的时间间隔。单位:以日志的命名精度来确定单位</span></span><br><span class="line"><span class="comment">                    modulate，boolean型，说明是否对封存时间进行调制。若modulate=true，则封存时间将以0点为边界进行偏移计算。</span></span><br><span class="line"><span class="comment">                --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"100 MB"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingRandomAccessFile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingRandomAccessFile</span> <span class="attr">name</span>=<span class="string">"errorLog"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;LOG_HOME&#125;/error.log"</span></span></span><br><span class="line"><span class="tag">                                 <span class="attr">filePattern</span>=<span class="string">"$&#123;LOG_HOME&#125;/error.%d&#123;yyyy-MM-dd&#125;.log.gz"</span> <span class="attr">append</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Filters</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"ERROR"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Filters</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"[%level][%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;][%thread][%class][%method][%line]:%message%n"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> <span class="attr">interval</span>=<span class="string">"1"</span> <span class="attr">modulate</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingRandomAccessFile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--日志配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"experiment"</span> <span class="attr">level</span>=<span class="string">"info"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"infoLog"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"errorLog"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"experiment.test"</span> <span class="attr">level</span>=<span class="string">"warn"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"infoLog"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"errorLog"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"algorithm"</span> <span class="attr">level</span>=<span class="string">"info"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"infoLog"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置日志的根节点 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"warn"</span> <span class="attr">includeLocation</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"errorLog"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-全异步模式"><a href="#2-全异步模式" class="headerlink" title="2. 全异步模式"></a>2. 全异步模式</h3><ol>
<li>只需要将<strong>系统属性</strong><code>Log4jContextSelector</code>设置为<code>AsyncLoggerContextSelector</code></li>
<li>在配置属性文件<code>log4j2.component.properties</code>中配置<code>Log4jContextSelector</code>为<code>AsyncLoggerContextSelector</code></li>
</ol>
<h3 id="3-混合模式"><a href="#3-混合模式" class="headerlink" title="3.混合模式"></a>3.混合模式</h3><p>todo 修改<br>不需要改系统属性或者引入属性配置文件，只需要将相应的<code>Loger</code>换成<code>AsyncLoger</code>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">logers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">AsyncLogger</span> <span class="attr">name</span>=<span class="string">"experiment.test"</span> <span class="attr">level</span>=<span class="string">"trace"</span> <span class="attr">includeLocation</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"warnLog"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">AsyncLogger</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>##2. 同步、异步以及混合模式的比较<br>虽然异步日志有很大的优势，但是它并不是适合于所有应用场景。如下将通过分析异步日志的优劣来比较同步日志和异步日志：</p>
<ol>
<li><p>优势</p>
<ul>
<li>更高的峰值吞吐量，相同场景下，异步日志的能打印的日志量是同步的6-58倍</li>
<li>更快的响应时间，调用后立即返回，而不用等到appender执行完成。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>错误处理方便，如果在打印日志的过程中抛了异常，对于异步日志来说很难记录。即使通过ExceptionHander可以减轻这种情况，但是并不能解决所有的情况。因此，当日志是业务逻辑的一部分（比如讲Log4j作为审计日志框架）时，则推荐使用同步日志；</li>
<li>在某些极端的情况下，打印的日志对象，可能会有变化。如：<code>MapMessage</code>、<code>StructuredDataMessage</code>，用户有可能会看到非触发打印时的对象快照</li>
<li>如果应用CPU资源吃紧的话，不适合于异步。因为它的速度是以牺牲CPU为代价的。</li>
<li>当应用打日志的速率比底层追加器的最大速率都要快，最后队列会被打满，最终也会以最慢追加器的速率打日志</li>
</ul>
</li>
</ol>
<h3 id="主要工作流程："><a href="#主要工作流程：" class="headerlink" title="主要工作流程："></a>主要工作流程：</h3><ol>
<li>LogManager.getLogger(xx.class) 会根据class文件的具体类名来获取最匹配的LogConfig</li>
<li>会遍历所有Appender，打印日志；</li>
<li>当LoggerConfig配置了additivity=”true” 会将日志事件传递给父节点LoggerConfig</li>
</ol>
<p>LogerConfig会根据name来建立一个关系树，root是根节点。如下图：<br>additivity（是否可叠加） 用于控制：子LogConfig里的日志事件是否往父LogConfig中传递。</p>
<h2 id="3-LogConfig继承关系图"><a href="#3-LogConfig继承关系图" class="headerlink" title="3. LogConfig继承关系图"></a>3. LogConfig继承关系图</h2><p><img src="/media/14931361439660.jpg" alt="set up-w400"></p>
<p>参考：</p>
<ol>
<li><a href="http://logging.apache.org/log4j/2.x/manual/layouts.html" target="_blank" rel="noopener">Layouts</a></li>
<li><a href="http://logging.apache.org/log4j/2.x/manual/appenders.html" target="_blank" rel="noopener">Appenders</a></li>
<li><a href="http://blog.csdn.net/jiangguilong2000/article/details/11397557" target="_blank" rel="noopener">Log4j2使用总结</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&mid=2651477099&idx=2&sn=1e06a34aaa899ceef8bf380bb98f813f&scene=0#wechat_redirect" target="_blank" rel="noopener">Log4j架构解析</a></li>
<li><a href="http://ifeve.com/disruptor/" target="_blank" rel="noopener">并发框架Disruptor</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dorgenjones.github.io/2017/03/11/%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7/log/1.java%20log%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zamperini">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zamperini">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/11/%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7/log/1.java%20log%E7%AE%80%E4%BB%8B/" itemprop="url">Java Log简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-11T00:00:00+08:00">2017-03-11</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/log4j/" itemprop="url" rel="index"><span itemprop="name">log4j</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java-Log-简介"><a href="#Java-Log-简介" class="headerlink" title="Java Log 简介"></a>Java Log 简介</h1><p>[TOC]</p>
<h2 id="初衷及目的"><a href="#初衷及目的" class="headerlink" title="初衷及目的"></a>初衷及目的</h2><h3 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h3><p>为什么项目里会引入这么多关于log的jar包？<br>都是干嘛吃的？<br>日志圈真<strong>乱</strong>！！！</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">commons-logging-1.2.jar</span><br><span class="line">log4j-1.2.17.jar</span><br><span class="line">log4j-1.2-api-2.3.jar</span><br><span class="line">log4j-api-2.1.jar</span><br><span class="line">log4j-core-2.1.jar</span><br><span class="line">log4j-over-slf4j-1.7.7.jar</span><br><span class="line">log4j-slf4j-impl-2.1.jar</span><br><span class="line">jcl-over-slf4j-1.7.7.jar</span><br><span class="line">jul-to-slf4j-1.7.7.jar</span><br><span class="line">slf4j-api-1.7.7.jar</span><br></pre></td></tr></table></figure>

<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ol>
<li>介绍java日志体系的脉络和关系</li>
<li>重点介绍Log4j2的配置</li>
<li>Log4j2的原理浅析</li>
</ol>
<p>Java日志体系分为日志门面和日志实现。下面将分别介绍它们。</p>
<h2 id="日志门面"><a href="#日志门面" class="headerlink" title="日志门面"></a>日志门面</h2><ul>
<li><strong>代理系统</strong>，自身不实现具体的日志打印逻辑。接受日志请求，将真正的打印逻辑交给具体的日志实现系统。</li>
<li><strong>可插拔</strong>，业务可以通过配置或者加入一些jar包的方式切换到其他日志实现框架，而不需要修改代码逻辑，<strong>解耦</strong>。</li>
</ul>
<p>目前主要有两套通用日志门面：common-logging、slf4j。</p>
<p>###1. <a href="https://commons.apache.org/proper/commons-logging/" target="_blank" rel="noopener">common-logging：Apache Commons Logging</a><br>使用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Log log = LogFactory.getLog(xx<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ol>
<li>简单、非常轻的一种桥接（<strong>动态查找</strong>）方式。</li>
<li>限制：不支持OSGI，模块化应用</li>
<li>功能单一：只能支持到具体日志系统间的桥接，而不能支持从具体日志系统到其自身的桥接。</li>
</ol>
<p>###2. <a href="https://www.slf4j.org/" target="_blank" rel="noopener">SLF4J：Simple Logging Facade for JAVA</a><br>使用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logger logger &#x3D; LoggerFactory.getLogger(xx.class);</span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ol>
<li>功能强大，不仅支持到具体日志实现之间的桥接，同时也支持从具体日志系统到自身的桥接</li>
<li>支持OSGI模块化应用</li>
<li>通过<strong>静态绑定</strong>的桥接方式</li>
</ol>
<h2 id="日志实现"><a href="#日志实现" class="headerlink" title="日志实现"></a>日志实现</h2><p>###1. <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/logging/" target="_blank" rel="noopener">Jdk-logging</a><br>JDK自带的一种自定义的、可扩展的日志框架（java.util.logging)。但是其API并不完善，不是很很友好，而且对于日志的级别分类也不是很清晰<br>    <a href="http://blog.csdn.net/qingkangxu/article/details/7514770" target="_blank" rel="noopener">JDK Logging深入分析</a></p>
<p>###2. <a href="http://logging.apache.org/log4j/1.2/" target="_blank" rel="noopener">Log4j1</a><br>Log4j也是Apache的开源项目，最早被广泛应用的日志解决方案。</p>
<blockquote>
</blockquote>
<ol>
<li>日志输出目的地可控；</li>
<li>输出格式可控；</li>
<li>通过日志级别，更细致控制日志的生成过程</li>
<li>通过配置文件来灵活地进行配置日志输出，而不需要修改程序代码。</li>
</ol>
<blockquote>
<p>1.x系列在15年8月被Apache宣布停止维护（<a href="https://blogs.apache.org/foundation/entry/apache_logging_services_project_announces" target="_blank" rel="noopener">Apache Blog</a>）</p>
</blockquote>
<p>###3. <a href="https://logback.qos.ch/" target="_blank" rel="noopener">LogBack</a><br>也是出自Log4j的创始人，最初的意图是用来替代Log4j。在日志性能、功能、可用性上有了很大程度的提升： <a href="https://logback.qos.ch/reasonsToSwitch.html" target="_blank" rel="noopener">Reasons to prefer logback over log4j</a></p>
<blockquote>
<p>Logback当前分为三个模块：logback-core, logback-classic and logback-access；<br><strong>logback-core</strong>模块是其他两个模块的基石；<br><strong>logback-classic</strong>是log4j的改良版，别外，其也实现了SLF4J API，使其可以便捷地更换其他日志实现系统<br> <strong>logback-access</strong>与Servlet容器集成，提供通过Http来访问日志的功能</p>
</blockquote>
<p>###4. <a href="http://logging.apache.org/log4j/2.x/index.html" target="_blank" rel="noopener">Log4j2</a><br>Log4j2也是Apache的开源项目，它对Log4j1做了巨大的提升。并且也提供了很多Logback的改进，并且改进了Logback框架存在的一些问题。</p>
<blockquote>
<ol>
<li><strong>性能提升</strong>:包含下一代基于the LMAX Disruptor library的异步日志框架。多线程场景下，吞吐量是 Log4j1和Logback的18倍,响应时间也比它们小很多。性能报告：<a href="http://logging.apache.org/log4j/2.x/performance.html" target="_blank" rel="noopener">http://logging.apache.org/log4j/2.x/performance.html</a></li>
<li><strong>插件式结构</strong>:可以根据需要扩展Log4j2. 可以实现Appender、Logger、Filter</li>
<li><strong>动态加载配置</strong>:可以动态地加载修改的配置，并且在重配置时，不会丢失日志时间</li>
<li><strong>支持多种API</strong>，Log4j2自己实现了Log4j1、Common-logging、Slf4j的桥接(log4j-1.2-api、log4j-jcl、log4j-slf4j-impl)<br>…</li>
</ol>
</blockquote>
<h2 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a>桥接</h2><p>日志门面通过什么方法与具体的日志实现进行绑定。</p>
<h3 id="1-Common-logging-桥接"><a href="#1-Common-logging-桥接" class="headerlink" title="1.Common-logging 桥接"></a>1.Common-logging 桥接</h3><p>其通过<strong>动态查找</strong>的机制，在程序运行时自动找出真正使用的日志库。也是比较粗略的一种方式<br>其运行原理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Log log = LogFactory.getLog(xx<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>其首先获取一个日志对象的工厂，然后通过工厂来生成对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> getFactory().getInstance(clazz);</span><br></pre></td></tr></table></figure>
<p>getFactory()方法中展示了日志工厂的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.全局系统变量中寻找 org.apache.commons.logging.LogFactory</span></span><br><span class="line"> String factoryClass = getSystemProperty(FACTORY_PROPERTY, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 找 META-INF/services/org.apache.commons.logging.LogFactory 文件中定义的LogFactory名称，</span></span><br><span class="line"><span class="comment">// log4j2的桥接就提供了这样的文件</span></span><br><span class="line"> <span class="keyword">final</span> InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID);</span><br><span class="line"> <span class="keyword">if</span>( is != <span class="keyword">null</span> ) &#123;</span><br><span class="line">     BufferedReader rd;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         rd = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is, <span class="string">"UTF-8"</span>));</span><br><span class="line">     &#125; <span class="keyword">catch</span> (java.io.UnsupportedEncodingException e) &#123;</span><br><span class="line">         rd = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">     &#125;</span><br><span class="line">     String factoryClassName;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         factoryClassName = rd.readLine();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         rd.close();</span><br><span class="line">     &#125;</span><br><span class="line">     factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.找用户配置的属性文件中key为org.apache.commons.logging.LogFactory的配置值作为日志工厂               </span></span><br><span class="line"> String factoryClass = props.getProperty(FACTORY_PROPERTY);</span><br><span class="line"> <span class="keyword">if</span> (factoryClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">     factory = newFactory(factoryClass, baseClassLoader, contextClassLoader);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 默认的日志工厂 org.apache.commons.logging.impl.LogFactoryImpl               </span></span><br><span class="line">factory = newFactory(FACTORY_DEFAULT, thisClassLoader, contextClassLoader);</span><br></pre></td></tr></table></figure>

<p>获取工厂对象后，就由工厂对象跟据相应的配置来生成日志对象。以默认的工厂类LogFactoryImpl为例，我们来分析生成日志对象的过程：<br>其核心代码在discoverLogImplementation(String logCategory)方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.首先 判断用户是否自定义了日志实现类 org.apache.commons.logging.Log、org.apache.commons.logging.log 为key的用户配置文件项或系统属性</span></span><br><span class="line">String specifiedLogClassName = findUserSpecifiedLogClassName();</span><br><span class="line"><span class="comment">//2. 如果没有，就按以下顺序去尝试创建日志对象，创建成功后立即返回相应日志对象</span></span><br><span class="line"><span class="string">"org.apache.commons.logging.impl.Log4JLogger"</span>,</span><br><span class="line"><span class="string">"org.apache.commons.logging.impl.Jdk14Logger"</span>,</span><br><span class="line"><span class="string">"org.apache.commons.logging.impl.Jdk13LumberjackLogger"</span>,</span><br><span class="line"><span class="string">"org.apache.commons.logging.impl.SimpleLog"</span></span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>首先<strong>寻找日志工厂类</strong>：<br>通过检查系统属性、执行路径文件和用户配置文件，看是否定义了相应的日志工程类。若有则加载此类，并通过其来生成日志对象；否则选择默认的日志工厂：<code>org.apache.commons.logging.impl.LogFactoryImpl</code></li>
<li>默认日志工厂获取日志适配器的过程：首先去寻找用户是否自己配置了日志适配器。若有则加载此类并初始化返回；若没有，则按一个固定的顺序来尝试来实例化日志适配器，若实例化成功则返回。</li>
</ol>
<h3 id="2-SLF4J-桥接"><a href="#2-SLF4J-桥接" class="headerlink" title="2. SLF4J 桥接"></a>2. SLF4J 桥接</h3><p>下图展示的是SLF4J和其他实现日志框架的桥接示意图：<br>可以看到通过jar包和其他日志实现框架起桥梁作用。这些起桥接作用的jar包是怎么起作用的呢？<br><img src="/media/14928715112128.jpg" alt="set up-w520"></p>
<p>是因为<code>StaticLoggerBinder</code>的作用！<br>从SLF4J的入口来寻找答案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getLogger</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取日志工厂</span></span><br><span class="line">   ILoggerFactory iLoggerFactory = getILoggerFactory();</span><br><span class="line">   <span class="keyword">return</span> iLoggerFactory.getLogger(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ILoggerFactory <span class="title">getILoggerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">    <span class="comment">//加载StaticLoggerBinder类</span></span><br><span class="line">    performInitialization();</span><br><span class="line">   ...</span><br><span class="line">           <span class="comment">//初始化StaticLoggerBinder，并获取其初始化的日志工厂</span></span><br><span class="line">           <span class="keyword">return</span> StaticLoggerBinder.getSingleton().getLoggerFactory();</span><br><span class="line">           ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>performInitialization 初始化日志系统， 通过加载项目中引入的桥接jar包中的StaticLoggerBinder，绑定特定日志实现框架的作用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">performInitialization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//绑定操作</span></span><br><span class="line">   bind();</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       Set&lt;URL&gt; staticLoggerBinderPathSet = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (!isAndroid()) &#123;</span><br><span class="line">       <span class="comment">//获取项目中所有的“org/slf4j/impl/StaticLoggerBinder.class”文件</span></span><br><span class="line">           staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();</span><br><span class="line">           <span class="comment">//当检测到有多个StaticLoggerBinder，会发出警告信息</span></span><br><span class="line">           reportMultipleBindingAmbiguity(staticLoggerBinderPathSet);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 实现绑定</span></span><br><span class="line">       StaticLoggerBinder.getSingleton();</span><br><span class="line">       INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;</span><br><span class="line">       reportActualBinding(staticLoggerBinderPathSet);</span><br><span class="line">       fixSubstituteLoggers();</span><br><span class="line">       replayEvents();</span><br><span class="line">       <span class="comment">// release all resources in SUBST_FACTORY</span></span><br><span class="line">       SUBST_FACTORY.clear();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (NoClassDefFoundError ncde) &#123;</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String STATIC_LOGGER_BINDER_PATH = <span class="string">"org/slf4j/impl/StaticLoggerBinder.class"</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Set&lt;URL&gt; <span class="title">findPossibleStaticLoggerBinderPathSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Set&lt;URL&gt; staticLoggerBinderPathSet = <span class="keyword">new</span> LinkedHashSet&lt;URL&gt;();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       ClassLoader loggerFactoryClassLoader = LoggerFactory<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">       Enumeration&lt;URL&gt; paths;</span><br><span class="line">       <span class="keyword">if</span> (loggerFactoryClassLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">           paths = ClassLoader.getSystemResources(STATIC_LOGGER_BINDER_PATH);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//获取项目中所有"org/slf4j/impl/StaticLoggerBinder.class"文件</span></span><br><span class="line">           paths = loggerFactoryClassLoader.getResources(STATIC_LOGGER_BINDER_PATH);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (paths.hasMoreElements()) &#123;</span><br><span class="line">           URL path = paths.nextElement();</span><br><span class="line">           staticLoggerBinderPathSet.add(path);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">       Util.report(<span class="string">"Error getting resources from path"</span>, ioe);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> staticLoggerBinderPathSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与SLF4J相关的桥接包里都有<code>org/slf4j/impl/StaticLoggerBinder</code>类，同时所有的<code>StaticLoggerBinder</code>都实现了<code>LoggerFactoryBinder</code>接口，方法<code>getLoggerFactory()</code>用于返回桥接包内的具体工厂对象(这些工厂对象都在StaticLoggerBinder对象的构造函数中进行了初始化)，比如Log4jLoggerFactory、JDK14LoggerFactory、JDK14LoggerFactory…</p>
<p><img src="/media/log.jpg" alt="log"></p>
<p>SLF4j官方给出了通过SLF4J桥接其他日志实现框架所依赖的jar。这些包文件中无一例外地包含类<code>StaticLoggerBinder</code><br><img src="/media/14925649741957.jpg" alt="set up-w888"></p>
<p>总结：</p>
<ol>
<li>SLF4j是通过<code>StaticLoggerBinder</code>来与具体日志实现框架进行桥接的。</li>
<li>当SLF4J扫描到有多个<code>StaticLoggerBinder</code>的实现时，会发出报警。同时会随机选一个。因此应该尽量杜绝这种情况发生。</li>
</ol>
<p>另外，SLF4J也给出了在业务代码中也使用了其他日志API的情况下，桥接到SLF4J所依赖的包。<br>其<strong>原理</strong>是：在这些包内部(log4j-over-slf4j…)实现相应日志API的类（相同的类名称）。比如<code>log4j-over-slf4j</code> 实现了和log4j1同类名的<code>org.apache.log4j.LogManager</code>，而在<code>log4j-over-slf4j</code>的<code>LogManager</code>里就实现了桥接SLF4J。<br><img src="/media/14925647803336.jpg" alt="set up-w888"></p>
<h3 id="3-补充说Log4j2的桥接"><a href="#3-补充说Log4j2的桥接" class="headerlink" title="3. 补充说Log4j2的桥接"></a>3. 补充说Log4j2的桥接</h3><p>Log4j2的特殊是因为Log4j2在SLF4j和Common-logging等之后诞生，而Log4j2为了适配这些通用日志接口，不得不做配合它们的适配工作。<br>下图展示的是 通过其他日志接口桥接到日志实现框架Log4j2所需要引入的依赖。<br><img src="/media/14930140754811.jpg" alt="set up-w580"></p>
<p>从图中可以看出：</p>
<ol>
<li><p>Log4j2为了桥接Common-logging 提供了Log4j-jcl.jar，资源文件：META-INF/services/org.apache.commons.logging.LogFactory内容:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.logging.log4j.jcl.LogFactoryImpl</span><br></pre></td></tr></table></figure>
<p> 对应的即为 上文 Common-logging包 getFactory()方法的第二步。<br> <img src="/media/14931740155318.jpg" alt="set up-w520"></p>
</li>
<li><p>Log4j2为了桥接SLF4j 也提供了log4j-slf4j-impl.jar。其包内容如下：提供了org.slf4j.impl.StaticLoggerBinder.class；以起到桥接的作用。</p>
<p> <img src="/media/14931744694782.jpg" alt="set up-w520"></p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">commons-logging-1.2.jar         X</span><br><span class="line">log4j-1.2.17.jar                X</span><br><span class="line">log4j-1.2-api-2.3.jar           X</span><br><span class="line">log4j-api-2.1.jar          </span><br><span class="line">log4j-core-2.1.jar         </span><br><span class="line">log4j-over-slf4j-1.7.7.jar</span><br><span class="line">jcl-over-slf4j-1.7.7.jar</span><br><span class="line">jul-to-slf4j-1.7.7.jar</span><br><span class="line">log4j-slf4j-impl-2.1.jar</span><br><span class="line">slf4j-api-1.7.7.jar</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Zamperini</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/%7C%7C%20archive">
                
                    <span class="site-state-item-count">55</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/DorgenJones" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:dblpfilter@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/1938368215" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zamperini</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.0.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.3"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
